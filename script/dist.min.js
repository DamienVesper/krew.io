/**
 * @author Christian Cesar Robledo Lopez aka Masquerade circus (christian@masquerade-circus.net)
 */
(function () {
    var CanvasMap = function (element, width, height, contextMode) {
        var canvas = {};
        canvas.element = element;
        canvas.contextMode = contextMode || '2d';
        canvas.context = canvas.element.getContext(canvas.contextMode);
        canvas.useRadians = false;
        canvas.zoom = 1;
        canvas.world = {
            width: width,
            height: height,
            rotation: 0,
        };
        canvas.scale = {
            width: 0,
            height: 0,
        };
        canvas.elements = {};

        canvas.randomId = function () {
            var id = (0 | Math.random() * 9e6).toString(36);
            if (canvas.elements[id] !== undefined) {
                id = canvas.randomId();
            }

            return id;
        };

        canvas.add = function (object) {
            if (object) {
                object.id = object.id || canvas.randomId();
                if (canvas.elements[object.id] === undefined) {
                    canvas.elements[object.id] = object;
                }
            }

            return canvas;
        };

        canvas.remove = function (object) {
            if (object && object.id && canvas.elements[object.id]) {
                delete canvas.elements[object.id];
            }

            return canvas;
        };

        canvas.draw = function () {
            var i;
            var newWidth = (canvas.context.canvas.width * canvas.zoom);
            var newHeight = (canvas.context.canvas.height * canvas.zoom);

            canvas.scale.width = 1 / canvas.world.width * canvas.context.canvas.width;
            canvas.scale.height = 1 / canvas.world.height * canvas.context.canvas.height;

            canvas.context.resetTransform();

            canvas.context.clearRect(0, 0, canvas.context.canvas.width, canvas.context.canvas.height);

            if (canvas.world.rotation) {
                canvas.context.translate(canvas.context.canvas.width / 2, canvas.context.canvas.height / 2);

                canvas.context.rotate(
                    canvas.useRadians ?
                        canvas.world.rotation :
                        Math.PI / 180 * canvas.world.rotation
                );

                canvas.context.translate(-canvas.context.canvas.width / 2, -canvas.context.canvas.height / 2);
            }

            canvas.context.translate(
                -((newWidth - canvas.context.canvas.width) / 2),
                -((newHeight - canvas.context.canvas.height) / 2)
            );
            canvas.context.scale(canvas.zoom, canvas.zoom);

            for (i in canvas.elements) {
                if (canvas.elements[i].draw) {
                    canvas.elements[i].draw();
                }
            }

            return canvas;
        };

        canvas.toWorld = function (obj) {
            var result = Object.assign({}, obj);
            if (obj.x && obj.x !== 0) {
                result.x = obj.x * canvas.scale.width;
            }

            if (obj.y && obj.y !== 0) {
                result.y = obj.y * canvas.scale.height;
            }

            if (obj.r && obj.r !== 0) {
                result.r = obj.r * canvas.scale.width;
            }

            if (obj.width && obj.width !== 0) {
                result.width = obj.width * canvas.scale.width;
            }

            if (obj.height && obj.height !== 0) {
                result.height = obj.height * canvas.scale.height;
            }

            if (obj.size && obj.size !== 0) {
                result.size = obj.size * canvas.scale.width;
            }

            if (obj.rotation && obj.rotation !== 0) {
                result.rotation =
                    canvas.useRadians ?
                        obj.rotation :
                        Math.PI / 180 * obj.rotation;
            }

            delete result.draw;
            delete result.id;
            delete result.toWorld;

            return result;
        };

        canvas.point = function (options) {
            var el = Object.assign(
                {
                    id: undefined,
                    x: 0,
                    y: 0,
                    r: 1,
                    fill: undefined,
                    stroke: options.stroke ? {
                        color: options.stroke.color || 'black',
                        width: options.stroke.width || 1,
                    } : undefined,
                },
                options
            );

            el.toWorld = function () {
                return canvas.toWorld(el);
            };

            el.draw = function () {
                var worldPosition = el.toWorld();
                if (el.fill) {
                    canvas.context.fillStyle = el.fill;
                    canvas.context.beginPath();
                    canvas.context.arc(
                      worldPosition.x,
                      worldPosition.y,
                      worldPosition.r,
                      0,
                      Math.PI * 2,
                      true
                    );
                    canvas.context.fill();
                }

                if (el.stroke) {
                    canvas.context.strokeStyle = el.stroke.color;
                    canvas.context.lineWidth = el.stroke.width * canvas.scale.width;
                    canvas.context.beginPath();
                    canvas.context.arc(
                      worldPosition.x,
                      worldPosition.y,
                      worldPosition.r,
                      0,
                      Math.PI * 2,
                      true
                    );
                    canvas.context.stroke();
                }
            };

            return el;
        };

        canvas.rect = function (options) {
            var el = Object.assign(
                {
                    id: undefined,
                    x: 0,
                    y: 0,
                    width: 1,
                    height: 1,
                    fill: undefined,
                    stroke: options.stroke ? {
                        color: options.stroke.color || 'black',
                        width: options.stroke.width || 1,
                    } : undefined,
                },
                options
            );

            el.toWorld = function () {
                return canvas.toWorld(el);
            };

            el.draw = function () {
                var worldPosition = el.toWorld();

                if (el.fill) {
                    canvas.context.fillStyle = el.fill;
                    canvas.context.fillRect(worldPosition.x, worldPosition.y, worldPosition.width, worldPosition.height);
                }

                if (el.stroke) {
                    canvas.context.strokeStyle = el.stroke.color;
                    canvas.context.lineWidth = el.stroke.width * canvas.scale.width;
                    canvas.context.strokeRect(worldPosition.x, worldPosition.y, worldPosition.width, worldPosition.height);
                }
            };

            return el;
        };

        canvas.triangle = function (options) {
            var el = Object.assign(
                {
                    id: undefined,
                    x: 0,
                    y: 0,
                    size: 1,
                    rotation: 0,
                    fill: undefined,
                    stroke: options.stroke ? {
                        color: options.stroke.color || 'black',
                        width: options.stroke.width || 1,
                    } : undefined,
                },
                options
            );

            el.toWorld = function () {
                return canvas.toWorld(el);
            };

            el.draw = function () {
                var worldPosition = el.toWorld();
                var s = worldPosition.size / 2;
                canvas.context.save();
                canvas.context.translate(worldPosition.x, worldPosition.y);
                canvas.context.rotate(worldPosition.rotation);
                canvas.context.translate(-(worldPosition.x), -(worldPosition.y));

                if (el.fill) {
                    canvas.context.fillStyle = el.fill;
                    canvas.context.beginPath();
                    canvas.context.moveTo(worldPosition.x - s, worldPosition.y + s);
                    canvas.context.lineTo(worldPosition.x, worldPosition.y - s);
                    canvas.context.lineTo(worldPosition.x + s, worldPosition.y + s);
                    canvas.context.lineTo(worldPosition.x - s, worldPosition.y + s);
                    canvas.context.fill();
                }

                if (el.stroke) {
                    canvas.context.strokeStyle = el.stroke.color;
                    canvas.context.lineWidth = el.stroke.width * canvas.scale.width;
                    canvas.context.beginPath();
                    canvas.context.moveTo(worldPosition.x - s, worldPosition.y + s);
                    canvas.context.lineTo(worldPosition.x, worldPosition.y - worldPosition.size);
                    canvas.context.lineTo(worldPosition.x + s, worldPosition.y + s);
                    canvas.context.lineTo(worldPosition.x - s, worldPosition.y + s);
                    canvas.context.stroke();
                }

                canvas.context.restore();
            };

            return el;
        };

        canvas.text = function (options) {
            var el = Object.assign(
                {
                    id: undefined,
                    x: 0,
                    y: 0,
                    text: '',
                    width: undefined,
                    font: 'serif',
                    size: 48,
                    align: 'center',
                    baseline: 'alphabetic',
                    fill: undefined,
                    stroke: options.stroke ? {
                        color: options.stroke.color || 'black',
                        width: options.stroke.width || 1,
                    } : undefined,
                },
                options
            );

            el.toWorld = function () {
                return canvas.toWorld(el);
            };

            el.draw = function () {
                var worldPosition = el.toWorld();
                canvas.context.textAlign = el.align;
                canvas.context.textBaseline = el.baseline;
                canvas.context.font = worldPosition.size + 'px ' + el.font;

                if (el.fill) {
                    canvas.context.fillStyle = el.fill;
                    canvas.context.fillText(el.text, worldPosition.x, worldPosition.y, worldPosition.width);
                }

                if (el.stroke) {
                    canvas.context.strokeStyle = el.stroke.color;
                    canvas.context.lineWidth = el.stroke.width * canvas.scale.width;
                    canvas.context.strokeText(el.text, worldPosition.x, worldPosition.y, worldPosition.width);
                }
            };

            return el;
        };

        return canvas;
    };

    window.CanvasMap = CanvasMap;
})(window);

/*jslint browser: true, regexp: true, maxerr: 50, indent: 4 */
/**
 * A UserAgent detection library.
 *
 * This library relies on the navigator.userAgent property and hence does not
 * work for custom UserAgent settings.
 *
 * Apart from supporting detection of major browser vendors, the library also
 * supports detection of various devices.
 *
 * Copyright (c) 2012-2014, Gopalarathnam Venkatesan
 * All rights reserved.
 *
 * @module UA
 */
(function (window, navigator) {
    'use strict';

    var userAgent = (window.navigator && navigator.userAgent) || '';

    function detect(pattern) {
        return function () {
            return (pattern).test(userAgent);
        };
    }

    var UA =  {
        /**
         * Return true if the browser is Chrome or compatible.
         *
         * @method isChrome
         */
        isChrome: detect(/webkit\W.*(chrome|chromium)\W/i),

        /**
         * Return true if the browser is Firefox.
         *
         * @method isFirefox
         */
        isFirefox: detect(/mozilla.*\Wfirefox\W/i),

        /**
         * Return true if the browser is using the Gecko engine.
         *
         * This is probably a better way to identify Firefox and other browsers
         * that use XulRunner.
         *
         * @method isGecko
         */
        isGecko: detect(/mozilla(?!.*webkit).*\Wgecko\W/i),

        /**
         * Return true if the browser is Internet Explorer.
         *
         * @method isIE
         */
        isIE: function () {
            if (navigator.appName === 'Microsoft Internet Explorer') {
                return true;
            } else if (detect(/\bTrident\b/)) {
                return true;
            } else {
                return false;
            }
        },


        /**
         * Return true if the browser is running on Kindle.
         *
         * @method isKindle
         */
        isKindle: detect(/\W(kindle|silk)\W/i),

        /**
         * Return true if the browser is running on a mobile device.
         *
         * @method isMobile
         */
        isMobile: detect(/(iphone|ipod|((?:android)?.*?mobile)|blackberry|nokia)/i),

        /**
         * Return true if we are running on Opera.
         *
         * @method isOpera
         */
        isOpera: detect(/opera.*\Wpresto\W|OPR/i),

        /**
         * Return true if the browser is Safari.
         *
         * @method isSafari
         */
        isSafari: detect(/webkit\W(?!.*chrome).*safari\W/i),

        /**
         * Return true if the browser is running on a tablet.
         *
         * One way to distinguish Android mobiles from tablets is that the
         * mobiles contain the string "mobile" in their UserAgent string.
         * If the word "Android" isn't followed by "mobile" then its a
         * tablet.
         *
         * @method isTablet
         */
        isTablet: detect(/(ipad|android(?!.*mobile)|tablet)/i),

        /**
         * Return true if the browser is running on a TV!
         *
         * @method isTV
         */
        isTV: detect(/googletv|sonydtv/i),

        /**
         * Return true if the browser is running on a WebKit browser.
         *
         * @method isWebKit
         */
        isWebKit: detect(/webkit\W/i),

        /**
         * Return true if the browser is running on an Android browser.
         *
         * @method isAndroid
         */
        isAndroid: detect(/android/i),

        /**
         * Return true if the browser is running on any iOS device.
         *
         * @method isIOS
         */
        isIOS: detect(/(ipad|iphone|ipod)/i),

        /**
         * Return true if the browser is running on an iPad.
         *
         * @method isIPad
         */
        isIPad: detect(/ipad/i),

        /**
         * Return true if the browser is running on an iPhone.
         *
         * @method isIPhone
         */
        isIPhone: detect(/iphone/i),

        /**
         * Return true if the browser is running on an iPod touch.
         *
         * @method isIPod
         */
        isIPod: detect(/ipod/i),

        /**
         * Return the complete UserAgent string verbatim.
         *
         * @method whoami
         */
        whoami: function () {
            return userAgent;
        },
    };

    if (typeof define === 'function' && define.amd) {
        // AMD
        define([], function () {
            return UA;
        });
    } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = UA.attach;
        module.exports.UA = UA;
    } else {
        // browser global
        window.UA = UA;
    }

}(window, navigator));

/*
  Keypress version 2.1.4 (c) 2016 David Mauro.
  Licensed under the Apache License, Version 2.0
  http://www.apache.org/licenses/LICENSE-2.0
*/
(function(){var m,v,y,z,A,r,w,B,F,C,G,H,q,s,p,o,t,D,I,E={}.hasOwnProperty,j=[].indexOf||function(a){for(var c=0,b=this.length;c<b;c++)if(c in this&&this[c]===a)return c;return-1};r={is_unordered:!1,is_counting:!1,is_exclusive:!1,is_solitary:!1,prevent_default:!1,prevent_repeat:!1};D="meta alt option ctrl shift cmd".split(" ");o="ctrl";m={debug:!1};var x=function(a){var c,b;for(c in a)E.call(a,c)&&(b=a[c],!1!==b&&(this[c]=b));this.keys=this.keys||[];this.count=this.count||0};x.prototype.allows_key_repeat=
function(){return!this.prevent_repeat&&"function"===typeof this.on_keydown};x.prototype.reset=function(){this.count=0;return this.keyup_fired=null};var g=function(a,c){var b,d;"undefined"!==typeof jQuery&&null!==jQuery&&a instanceof jQuery&&(1!==a.length&&p("Warning: your jQuery selector should have exactly one object."),a=a[0]);this.should_force_event_defaults=this.should_suppress_event_defaults=!1;this.sequence_delay=800;this._registered_combos=[];this._keys_down=[];this._active_combos=[];this._sequence=
[];this._sequence_timer=null;this._prevent_capture=!1;this._defaults=c||{};for(b in r)E.call(r,b)&&(d=r[b],this._defaults[b]=this._defaults[b]||d);this.element=a||document.body;b=function(a,b,c){a.addEventListener?a.addEventListener(b,c):a.attachEvent&&a.attachEvent("on"+b,c);return c};var e=this;this.keydown_event=b(this.element,"keydown",function(a){a=a||window.event;e._receive_input(a,true);return e._bug_catcher(a)});var f=this;this.keyup_event=b(this.element,"keyup",function(a){a=a||window.event;
return f._receive_input(a,false)});var h=this;this.blur_event=b(window,"blur",function(){var a,b,c,d;d=h._keys_down;b=0;for(c=d.length;b<c;b++){a=d[b];h._key_up(a,{})}return h._keys_down=[]})};g.prototype.destroy=function(){var a;a=function(a,b,d){if(null!=a.removeEventListener)return a.removeEventListener(b,d);if(null!=a.removeEvent)return a.removeEvent("on"+b,d)};a(this.element,"keydown",this.keydown_event);a(this.element,"keyup",this.keyup_event);return a(window,"blur",this.blur_event)};g.prototype._bug_catcher=
function(a){var c,b;if("cmd"===o&&0<=j.call(this._keys_down,"cmd")&&"cmd"!==(c=z(null!=(b=a.keyCode)?b:a.key))&&"shift"!==c&&"alt"!==c&&"caps"!==c&&"tab"!==c)return this._receive_input(a,!1)};g.prototype._cmd_bug_check=function(a){return"cmd"===o&&0<=j.call(this._keys_down,"cmd")&&0>j.call(a,"cmd")?!1:!0};g.prototype._prevent_default=function(a,c){if((c||this.should_suppress_event_defaults)&&!this.should_force_event_defaults)if(a.preventDefault?a.preventDefault():a.returnValue=!1,a.stopPropagation)return a.stopPropagation()};
g.prototype._get_active_combos=function(a){var c,b;c=[];b=w(this._keys_down,function(b){return b!==a});b.push(a);this._match_combo_arrays(b,function(a){return function(b){if(a._cmd_bug_check(b.keys))return c.push(b)}}(this));this._fuzzy_match_combo_arrays(b,function(a){return function(b){if(!(0<=j.call(c,b))&&!b.is_solitary&&a._cmd_bug_check(b.keys))return c.push(b)}}(this));return c};g.prototype._get_potential_combos=function(a){var c,b,d,e,f;b=[];f=this._registered_combos;d=0;for(e=f.length;d<e;d++)c=
f[d],c.is_sequence||0<=j.call(c.keys,a)&&this._cmd_bug_check(c.keys)&&b.push(c);return b};g.prototype._add_to_active_combos=function(a){var c,b,d,e,f,h,i,g,n,k,l;h=!1;f=!0;d=!1;if(0<=j.call(this._active_combos,a))return!0;if(this._active_combos.length){e=i=0;for(k=this._active_combos.length;0<=k?i<k:i>k;e=0<=k?++i:--i)if((c=this._active_combos[e])&&c.is_exclusive&&a.is_exclusive){c=c.keys;if(!h){g=0;for(n=c.length;g<n;g++)if(b=c[g],h=!0,0>j.call(a.keys,b)){h=!1;break}}if(f&&!h){l=a.keys;g=0;for(n=
l.length;g<n;g++)if(b=l[g],f=!1,0>j.call(c,b)){f=!0;break}}h&&(d?(c=this._active_combos.splice(e,1)[0],null!=c&&c.reset()):(c=this._active_combos.splice(e,1,a)[0],null!=c&&c.reset(),d=!0),f=!1)}}f&&this._active_combos.unshift(a);return h||f};g.prototype._remove_from_active_combos=function(a){var c,b,d,e;b=d=0;for(e=this._active_combos.length;0<=e?d<e:d>e;b=0<=e?++d:--d)if(c=this._active_combos[b],c===a){a=this._active_combos.splice(b,1)[0];a.reset();break}};g.prototype._get_possible_sequences=function(){var a,
c,b,d,e,f,h,i,g,n,k,l;d=[];n=this._registered_combos;f=0;for(g=n.length;f<g;f++){a=n[f];c=h=1;for(k=this._sequence.length;1<=k?h<=k:h>=k;c=1<=k?++h:--h)if(e=this._sequence.slice(-c),a.is_sequence){if(0>j.call(a.keys,"shift")&&(e=w(e,function(a){return"shift"!==a}),!e.length))continue;c=i=0;for(l=e.length;0<=l?i<l:i>l;c=0<=l?++i:--i)if(a.keys[c]===e[c])b=!0;else{b=!1;break}b&&d.push(a)}}return d};g.prototype._add_key_to_sequence=function(a,c){var b,d,e,f;this._sequence.push(a);d=this._get_possible_sequences();
if(d.length){e=0;for(f=d.length;e<f;e++)b=d[e],this._prevent_default(c,b.prevent_default);this._sequence_timer&&clearTimeout(this._sequence_timer);-1<this.sequence_delay&&(this._sequence_timer=setTimeout(function(){return this._sequence=[]},this.sequence_delay))}else this._sequence=[]};g.prototype._get_sequence=function(a){var c,b,d,e,f,h,i,g,n,k,l,u;k=this._registered_combos;h=0;for(n=k.length;h<n;h++)if(c=k[h],c.is_sequence){b=i=1;for(l=this._sequence.length;1<=l?i<=l:i>=l;b=1<=l?++i:--i)if(f=w(this._sequence,
function(a){return 0<=j.call(c.keys,"shift")?!0:"shift"!==a}).slice(-b),c.keys.length===f.length){b=g=0;for(u=f.length;0<=u?g<u:g>u;b=0<=u?++g:--g)if(e=f[b],!(0>j.call(c.keys,"shift")&&"shift"===e)&&!("shift"===a&&0>j.call(c.keys,"shift")))if(c.keys[b]===e)d=!0;else{d=!1;break}}if(d)return c.is_exclusive&&(this._sequence=[]),c}return!1};g.prototype._receive_input=function(a,c){var b,d;if(this._prevent_capture)this._keys_down.length&&(this._keys_down=[]);else if(b=z(null!=(d=a.keyCode)?d:a.key),(c||
this._keys_down.length||!("alt"===b||b===o))&&b)return c?this._key_down(b,a):this._key_up(b,a)};g.prototype._fire=function(a,c,b,d){"function"===typeof c["on_"+a]&&this._prevent_default(b,!0!==c["on_"+a].call(c["this"],b,c.count,d));"release"===a&&(c.count=0);if("keyup"===a)return c.keyup_fired=!0};g.prototype._match_combo_arrays=function(a,c){var b,d,e,f;f=this._registered_combos;d=0;for(e=f.length;d<e;d++)b=f[d],(!b.is_unordered&&y(a,b.keys)||b.is_unordered&&v(a,b.keys))&&c(b)};g.prototype._fuzzy_match_combo_arrays=
function(a,c){var b,d,e,f;f=this._registered_combos;d=0;for(e=f.length;d<e;d++)b=f[d],(!b.is_unordered&&C(b.keys,a)||b.is_unordered&&F(b.keys,a))&&c(b)};g.prototype._keys_remain=function(a){var c,b,d,e;e=a.keys;b=0;for(d=e.length;b<d;b++)if(a=e[b],0<=j.call(this._keys_down,a)){c=!0;break}return c};g.prototype._key_down=function(a,c){var b,d,e,f,h;(b=A(a,c))&&(a=b);this._add_key_to_sequence(a,c);(b=this._get_sequence(a))&&this._fire("keydown",b,c);for(e in t)b=t[e],c[b]&&(e===a||0<=j.call(this._keys_down,
e)||this._keys_down.push(e));for(e in t)if(b=t[e],e!==a&&0<=j.call(this._keys_down,e)&&!c[b]&&!("cmd"===e&&"cmd"!==o)){b=d=0;for(f=this._keys_down.length;0<=f?d<f:d>f;b=0<=f?++d:--d)this._keys_down[b]===e&&this._keys_down.splice(b,1)}d=this._get_active_combos(a);e=this._get_potential_combos(a);f=0;for(h=d.length;f<h;f++)b=d[f],this._handle_combo_down(b,e,a,c);if(e.length){d=0;for(f=e.length;d<f;d++)b=e[d],this._prevent_default(c,b.prevent_default)}0>j.call(this._keys_down,a)&&this._keys_down.push(a)};
g.prototype._handle_combo_down=function(a,c,b,d){var e,f,h,g,m;if(0>j.call(a.keys,b))return!1;this._prevent_default(d,a&&a.prevent_default);e=!1;if(0<=j.call(this._keys_down,b)&&(e=!0,!a.allows_key_repeat()))return!1;h=this._add_to_active_combos(a,b);b=a.keyup_fired=!1;if(a.is_exclusive){g=0;for(m=c.length;g<m;g++)if(f=c[g],f.is_exclusive&&f.keys.length>a.keys.length){b=!0;break}}if(!b&&(a.is_counting&&"function"===typeof a.on_keydown&&(a.count+=1),h))return this._fire("keydown",a,d,e)};g.prototype._key_up=
function(a,c){var b,d,e,f,h,g;b=a;(e=A(a,c))&&(a=e);e=s[b];c.shiftKey?e&&0<=j.call(this._keys_down,e)||(a=b):b&&0<=j.call(this._keys_down,b)||(a=e);(f=this._get_sequence(a))&&this._fire("keyup",f,c);if(0>j.call(this._keys_down,a))return!1;f=h=0;for(g=this._keys_down.length;0<=g?h<g:h>g;f=0<=g?++h:--h)if((d=this._keys_down[f])===a||d===e||d===b){this._keys_down.splice(f,1);break}d=this._active_combos.length;e=[];g=this._active_combos;f=0;for(h=g.length;f<h;f++)b=g[f],0<=j.call(b.keys,a)&&e.push(b);
f=0;for(h=e.length;f<h;f++)b=e[f],this._handle_combo_up(b,c,a);if(1<d){h=this._active_combos;d=0;for(f=h.length;d<f;d++)b=h[d],void 0===b||0<=j.call(e,b)||this._keys_remain(b)||this._remove_from_active_combos(b)}};g.prototype._handle_combo_up=function(a,c,b){var d,e;this._prevent_default(c,a&&a.prevent_default);e=this._keys_remain(a);if(!a.keyup_fired&&(d=this._keys_down.slice(),d.push(b),!a.is_solitary||v(d,a.keys)))this._fire("keyup",a,c),a.is_counting&&("function"===typeof a.on_keyup&&"function"!==
typeof a.on_keydown)&&(a.count+=1);e||(this._fire("release",a,c),this._remove_from_active_combos(a))};g.prototype.simple_combo=function(a,c){return this.register_combo({keys:a,on_keydown:c})};g.prototype.counting_combo=function(a,c){return this.register_combo({keys:a,is_counting:!0,is_unordered:!1,on_keydown:c})};g.prototype.sequence_combo=function(a,c){return this.register_combo({keys:a,on_keydown:c,is_sequence:!0,is_exclusive:!0})};g.prototype.register_combo=function(a){var c,b,d;"string"===typeof a.keys&&
(a.keys=a.keys.split(" "));d=this._defaults;for(c in d)E.call(d,c)&&(b=d[c],void 0===a[c]&&(a[c]=b));a=new x(a);if(I(a))return this._registered_combos.push(a),a};g.prototype.register_many=function(a){var c,b,d,e;e=[];b=0;for(d=a.length;b<d;b++)c=a[b],e.push(this.register_combo(c));return e};g.prototype.unregister_combo=function(a){var c,b,d,e,f,g;if(!a)return!1;var i=this;b=function(a){var b,c,d,e;e=[];b=c=0;for(d=i._registered_combos.length;0<=d?c<d:c>d;b=0<=d?++c:--c)if(a===i._registered_combos[b]){i._registered_combos.splice(b,
1);break}else e.push(void 0);return e};if(a instanceof x)return b(a);"string"===typeof a&&(a=a.split(" "));f=this._registered_combos;g=[];d=0;for(e=f.length;d<e;d++)c=f[d],null!=c&&(c.is_unordered&&v(a,c.keys)||!c.is_unordered&&y(a,c.keys)?g.push(b(c)):g.push(void 0));return g};g.prototype.unregister_many=function(a){var c,b,d,e;e=[];b=0;for(d=a.length;b<d;b++)c=a[b],e.push(this.unregister_combo(c));return e};g.prototype.get_registered_combos=function(){return this._registered_combos};g.prototype.reset=
function(){return this._registered_combos=[]};g.prototype.listen=function(){return this._prevent_capture=!1};g.prototype.stop_listening=function(){return this._prevent_capture=!0};g.prototype.get_meta_key=function(){return o};m.Listener=g;z=function(a){return q[a]};w=function(a,c){var b;if(a.filter)return a.filter(c);var d,e,f;f=[];d=0;for(e=a.length;d<e;d++)b=a[d],c(b)&&f.push(b);return f};v=function(a,c){var b,d,e;if(a.length!==c.length)return!1;d=0;for(e=a.length;d<e;d++)if(b=a[d],!(0<=j.call(c,
b)))return!1;return!0};y=function(a,c){var b,d,e;if(a.length!==c.length)return!1;b=d=0;for(e=a.length;0<=e?d<e:d>e;b=0<=e?++d:--d)if(a[b]!==c[b])return!1;return!0};F=function(a,c){var b,d,e;d=0;for(e=a.length;d<e;d++)if(b=a[d],0>j.call(c,b))return!1;return!0};B=Array.prototype.indexOf||function(a,c){var b,d,e;b=d=0;for(e=a.length;0<=e?d<=e:d>=e;b=0<=e?++d:--d)if(a[b]===c)return b;return-1};C=function(a,c){var b,d,e,f;e=d=0;for(f=a.length;e<f;e++)if(b=a[e],b=B.call(c,b),b>=d)d=b;else return!1;return!0};
p=function(){if(m.debug)return console.log.apply(console,arguments)};G=function(a){var c,b,d;c=!1;for(d in q)if(b=q[d],a===b){c=!0;break}if(!c)for(d in s)if(b=s[d],a===b){c=!0;break}return c};I=function(a){var c,b,d,e,f,g,i;f=!0;a.keys.length||p("You're trying to bind a combo with no keys:",a);b=g=0;for(i=a.keys.length;0<=i?g<i:g>i;b=0<=i?++g:--g)d=a.keys[b],(c=H[d])&&(d=a.keys[b]=c),"meta"===d&&a.keys.splice(b,1,o),"cmd"===d&&p('Warning: use the "meta" key rather than "cmd" for Windows compatibility');
i=a.keys;c=0;for(g=i.length;c<g;c++)d=i[c],G(d)||(p('Do not recognize the key "'+d+'"'),f=!1);if(0<=j.call(a.keys,"meta")||0<=j.call(a.keys,"cmd")){c=a.keys.slice();g=0;for(i=D.length;g<i;g++)d=D[g],-1<(b=B.call(c,d))&&c.splice(b,1);1<c.length&&(p("META and CMD key combos cannot have more than 1 non-modifier keys",a,c),f=!1)}for(e in a)"undefined"===r[e]&&p("The property "+e+" is not a valid combo property. Your combo has still been registered.");return f};A=function(a,c){var b;if(!c.shiftKey)return!1;
b=s[a];return null!=b?b:!1};t={cmd:"metaKey",ctrl:"ctrlKey",shift:"shiftKey",alt:"altKey"};H={escape:"esc",control:"ctrl",command:"cmd","break":"pause",windows:"cmd",option:"alt",caps_lock:"caps",apostrophe:"'",semicolon:";",tilde:"~",accent:"`",scroll_lock:"scroll",num_lock:"num"};s={"/":"?",".":">",",":"<","'":'"',";":":","[":"{","]":"}","\\":"|","`":"~","=":"+","-":"_",1:"!",2:"@",3:"#",4:"$",5:"%",6:"^",7:"&",8:"*",9:"(","0":")"};q={"0":"\\",8:"backspace",9:"tab",12:"num",13:"enter",16:"shift",
17:"ctrl",18:"alt",19:"pause",20:"caps",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",44:"print",45:"insert",46:"delete",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",65:"a",66:"b",67:"c",68:"d",69:"e",70:"f",71:"g",72:"h",73:"i",74:"j",75:"k",76:"l",77:"m",78:"n",79:"o",80:"p",81:"q",82:"r",83:"s",84:"t",85:"u",86:"v",87:"w",88:"x",89:"y",90:"z",91:"cmd",92:"cmd",93:"cmd",96:"num_0",97:"num_1",98:"num_2",99:"num_3",
100:"num_4",101:"num_5",102:"num_6",103:"num_7",104:"num_8",105:"num_9",106:"num_multiply",107:"num_add",108:"num_enter",109:"num_subtract",110:"num_decimal",111:"num_divide",112:"f1",113:"f2",114:"f3",115:"f4",116:"f5",117:"f6",118:"f7",119:"f8",120:"f9",121:"f10",122:"f11",123:"f12",124:"print",144:"num",145:"scroll",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",223:"`",224:"cmd",225:"alt",57392:"ctrl",63289:"num",59:";",61:"=",173:"-"};m._keycode_dictionary=
q;m._is_array_in_array_sorted=C;-1!==navigator.userAgent.indexOf("Mac OS X")&&(o="cmd");-1!==navigator.userAgent.indexOf("Opera")&&(q["17"]="cmd");"function"===typeof define&&define.amd?define([],function(){return m}):"undefined"!==typeof exports&&null!==exports?exports.keypress=m:window.keypress=m}).call(this);

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.OBJLoader = ( function () {

	// o object_name | g group_name
	var object_pattern           = /^[og]\s*(.+)?/;
	// mtllib file_reference
	var material_library_pattern = /^mtllib /;
	// usemtl material_name
	var material_use_pattern     = /^usemtl /;

	function ParserState() {

		var state = {
			objects  : [],
			object   : {},

			vertices : [],
			normals  : [],
			uvs      : [],

			materialLibraries : [],

			startObject: function ( name, fromDeclaration ) {

				// If the current object (initial from reset) is not from a g/o declaration in the parsed
				// file. We need to use it for the first parsed g/o to keep things in sync.
				if ( this.object && this.object.fromDeclaration === false ) {

					this.object.name = name;
					this.object.fromDeclaration = ( fromDeclaration !== false );
					return;

				}

				var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

				if ( this.object && typeof this.object._finalize === 'function' ) {

					this.object._finalize( true );

				}

				this.object = {
					name : name || '',
					fromDeclaration : ( fromDeclaration !== false ),

					geometry : {
						vertices : [],
						normals  : [],
						uvs      : []
					},
					materials : [],
					smooth : true,

					startMaterial: function ( name, libraries ) {

						var previous = this._finalize( false );

						// New usemtl declaration overwrites an inherited material, except if faces were declared
						// after the material, then it must be preserved for proper MultiMaterial continuation.
						if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

							this.materials.splice( previous.index, 1 );

						}

						var material = {
							index      : this.materials.length,
							name       : name || '',
							mtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
							smooth     : ( previous !== undefined ? previous.smooth : this.smooth ),
							groupStart : ( previous !== undefined ? previous.groupEnd : 0 ),
							groupEnd   : -1,
							groupCount : -1,
							inherited  : false,

							clone: function ( index ) {
								var cloned = {
									index      : ( typeof index === 'number' ? index : this.index ),
									name       : this.name,
									mtllib     : this.mtllib,
									smooth     : this.smooth,
									groupStart : 0,
									groupEnd   : -1,
									groupCount : -1,
									inherited  : false
								};
								cloned.clone = this.clone.bind(cloned);
								return cloned;
							}
						};

						this.materials.push( material );

						return material;

					},

					currentMaterial: function () {

						if ( this.materials.length > 0 ) {
							return this.materials[ this.materials.length - 1 ];
						}

						return undefined;

					},

					_finalize: function ( end ) {

						var lastMultiMaterial = this.currentMaterial();
						if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

							lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
							lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
							lastMultiMaterial.inherited = false;

						}

						// Ignore objects tail materials if no face declarations followed them before a new o/g started.
						if ( end && this.materials.length > 1 ) {

							for ( var mi = this.materials.length - 1; mi >= 0; mi-- ) {
								if ( this.materials[ mi ].groupCount <= 0 ) {
									this.materials.splice( mi, 1 );
								}
							}

						}

						// Guarantee at least one empty material, this makes the creation later more straight forward.
						if ( end && this.materials.length === 0 ) {

							this.materials.push({
								name   : '',
								smooth : this.smooth
							});

						}

						return lastMultiMaterial;

					}
				};

				// Inherit previous objects material.
				// Spec tells us that a declared material must be set to all objects until a new material is declared.
				// If a usemtl declaration is encountered while this new object is being parsed, it will
				// overwrite the inherited material. Exception being that there was already face declarations
				// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

				if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {

					var declared = previousMaterial.clone( 0 );
					declared.inherited = true;
					this.object.materials.push( declared );

				}

				this.objects.push( this.object );

			},

			finalize: function () {

				if ( this.object && typeof this.object._finalize === 'function' ) {

					this.object._finalize( true );

				}

			},

			parseVertexIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

			},

			parseNormalIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

			},

			parseUVIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

			},

			addVertex: function ( a, b, c ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
				dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
				dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

			},

			addVertexLine: function ( a ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );

			},

			addNormal: function ( a, b, c ) {

				var src = this.normals;
				var dst = this.object.geometry.normals;

				dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
				dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
				dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );

			},

			addUV: function ( a, b, c ) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push( src[ a + 0 ], src[ a + 1 ] );
				dst.push( src[ b + 0 ], src[ b + 1 ] );
				dst.push( src[ c + 0 ], src[ c + 1 ] );

			},

			addUVLine: function ( a ) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push( src[ a + 0 ], src[ a + 1 ] );

			},

			addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {

				var vLen = this.vertices.length;

				var ia = this.parseVertexIndex( a, vLen );
				var ib = this.parseVertexIndex( b, vLen );
				var ic = this.parseVertexIndex( c, vLen );

				this.addVertex( ia, ib, ic );

				if ( ua !== undefined ) {

					var uvLen = this.uvs.length;

					ia = this.parseUVIndex( ua, uvLen );
					ib = this.parseUVIndex( ub, uvLen );
					ic = this.parseUVIndex( uc, uvLen );

					this.addUV( ia, ib, ic );

				}

				if ( na !== undefined ) {

					// Normals are many times the same. If so, skip function call and parseInt.
					var nLen = this.normals.length;
					ia = this.parseNormalIndex( na, nLen );

					ib = na === nb ? ia : this.parseNormalIndex( nb, nLen );
					ic = na === nc ? ia : this.parseNormalIndex( nc, nLen );

					this.addNormal( ia, ib, ic );

				}

			},

			addLineGeometry: function ( vertices, uvs ) {

				this.object.geometry.type = 'Line';

				var vLen = this.vertices.length;
				var uvLen = this.uvs.length;

				for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

					this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

				}

				for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

					this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

				}

			}

		};

		state.startObject( '', false );

		return state;

	}

	//

	function OBJLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

		this.materials = null;

	};

	OBJLoader.prototype = {

		constructor: OBJLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new THREE.FileLoader( scope.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( text ) );

			}, onProgress, onError );

		},

		setPath: function ( value ) {

			this.path = value;

		},

		setMaterials: function ( materials ) {

			this.materials = materials;

			return this;

		},

		parse: function ( text ) {

			console.time( 'OBJLoader' );

			var state = new ParserState();

			if ( text.indexOf( '\r\n' ) !== - 1 ) {

				// This is faster than String.split with regex that splits on both
				text = text.replace( /\r\n/g, '\n' );

			}

			if ( text.indexOf( '\\\n' ) !== - 1) {

				// join lines separated by a line continuation character (\)
				text = text.replace( /\\\n/g, '' );

			}

			var lines = text.split( '\n' );
			var line = '', lineFirstChar = '';
			var lineLength = 0;
			var result = [];

			// Faster to just trim left side of the line. Use if available.
			var trimLeft = ( typeof ''.trimLeft === 'function' );

			for ( var i = 0, l = lines.length; i < l; i ++ ) {

				line = lines[ i ];

				line = trimLeft ? line.trimLeft() : line.trim();

				lineLength = line.length;

				if ( lineLength === 0 ) continue;

				lineFirstChar = line.charAt( 0 );

				// @todo invoke passed in handler if any
				if ( lineFirstChar === '#' ) continue;

				if ( lineFirstChar === 'v' ) {

					var data = line.split( /\s+/ );

					switch ( data[ 0 ] ) {

						case 'v':
							state.vertices.push(
								parseFloat( data[ 1 ] ),
								parseFloat( data[ 2 ] ),
								parseFloat( data[ 3 ] )
							);
							break;
						case 'vn':
							state.normals.push(
								parseFloat( data[ 1 ] ),
								parseFloat( data[ 2 ] ),
								parseFloat( data[ 3 ] )
							);
							break;
						case 'vt':
							state.uvs.push(
								parseFloat( data[ 1 ] ),
								parseFloat( data[ 2 ] )
							);
							break;
					}

				} else if ( lineFirstChar === 'f' ) {

					var lineData = line.substr( 1 ).trim();
					var vertexData = lineData.split( /\s+/ );
					var faceVertices = [];

					// Parse the face vertex data into an easy to work with format

					for ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {

						var vertex = vertexData[ j ];

						if ( vertex.length > 0 ) {

							var vertexParts = vertex.split( '/' );
							faceVertices.push( vertexParts );

						}

					}

					// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

					var v1 = faceVertices[ 0 ];

					for ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {

						var v2 = faceVertices[ j ];
						var v3 = faceVertices[ j + 1 ];

						state.addFace(
							v1[ 0 ], v2[ 0 ], v3[ 0 ],
							v1[ 1 ], v2[ 1 ], v3[ 1 ],
							v1[ 2 ], v2[ 2 ], v3[ 2 ]
						);

					}

				} else if ( lineFirstChar === 'l' ) {

					var lineParts = line.substring( 1 ).trim().split( " " );
					var lineVertices = [], lineUVs = [];

					if ( line.indexOf( "/" ) === - 1 ) {

						lineVertices = lineParts;

					} else {

						for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {

							var parts = lineParts[ li ].split( "/" );

							if ( parts[ 0 ] !== "" ) lineVertices.push( parts[ 0 ] );
							if ( parts[ 1 ] !== "" ) lineUVs.push( parts[ 1 ] );

						}

					}
					state.addLineGeometry( lineVertices, lineUVs );

				} else if ( ( result = object_pattern.exec( line ) ) !== null ) {

					// o object_name
					// or
					// g group_name

					// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
					// var name = result[ 0 ].substr( 1 ).trim();
					var name = ( " " + result[ 0 ].substr( 1 ).trim() ).substr( 1 );

					state.startObject( name );

				} else if ( material_use_pattern.test( line ) ) {

					// material

					state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

				} else if ( material_library_pattern.test( line ) ) {

					// mtl file

					state.materialLibraries.push( line.substring( 7 ).trim() );

				} else if ( lineFirstChar === 's' ) {

					result = line.split( ' ' );

					// smooth shading

					// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
					// but does not define a usemtl for each face set.
					// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
					// This requires some care to not create extra material on each smooth value for "normal" obj files.
					// where explicit usemtl defines geometry groups.
					// Example asset: examples/models/obj/cerberus/Cerberus.obj

					/*
					 * http://paulbourke.net/dataformats/obj/
					 * or
					 * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */
					if ( result.length > 1 ) {

						var value = result[ 1 ].trim().toLowerCase();
						state.object.smooth = ( value !== '0' && value !== 'off' );

					} else {

						// ZBrush can produce "s" lines #11707
						state.object.smooth = true;

					}
					var material = state.object.currentMaterial();
					if ( material ) material.smooth = state.object.smooth;

				} else {

					// Handle null terminated files without exception
					if ( line === '\0' ) continue;

					throw new Error( "Unexpected line: '" + line  + "'" );

				}

			}

			state.finalize();

			var container = new THREE.Group();
			container.materialLibraries = [].concat( state.materialLibraries );

			for ( var i = 0, l = state.objects.length; i < l; i ++ ) {

				var object = state.objects[ i ];
				var geometry = object.geometry;
				var materials = object.materials;
				var isLine = ( geometry.type === 'Line' );

				// Skip o/g line declarations that did not follow with any faces
				if ( geometry.vertices.length === 0 ) continue;

				var buffergeometry = new THREE.BufferGeometry();

				buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );

				if ( geometry.normals.length > 0 ) {

					buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );

				} else {

					buffergeometry.computeVertexNormals();

				}

				if ( geometry.uvs.length > 0 ) {

					buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );

				}

				// Create materials

				var createdMaterials = [];

				for ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {

					var sourceMaterial = materials[ mi ];
					var material = undefined;

					if ( this.materials !== null ) {

						material = this.materials.create( sourceMaterial.name );

						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {

							var materialLine = new THREE.LineBasicMaterial();
							materialLine.copy( material );
							material = materialLine;

						}

					}

					if ( ! material ) {

						material = ( ! isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial() );
						material.name = sourceMaterial.name;

					}

					material.flatShading = sourceMaterial.smooth ? false : true;

					createdMaterials.push(material);

				}

				// Create mesh

				var mesh;

				if ( createdMaterials.length > 1 ) {

					for ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {

						var sourceMaterial = materials[ mi ];
						buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

					}

					mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials ) : new THREE.LineSegments( buffergeometry, createdMaterials ) );

				} else {

					mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] ) );
				}

				mesh.name = object.name;

				container.add( mesh );

			}

			console.timeEnd( 'OBJLoader' );

			return container;

		}

	};

	return OBJLoader;

} )();

/*
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 * @author mrdoob / http://mrdoob.com/
 * @author takahirox / https://github.com/takahirox/
 */

THREE.TGALoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TGALoader.prototype = {

	constructor: THREE.TGALoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new THREE.Texture();

		var loader = new THREE.FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			texture.image = scope.parse( buffer );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	parse: function ( buffer ) {

		// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js

		function tgaCheckHeader( header ) {

			switch ( header.image_type ) {

				// check indexed type

				case TGA_TYPE_INDEXED:
				case TGA_TYPE_RLE_INDEXED:
					if ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {

						console.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );

					}
					break;

				// check colormap type

				case TGA_TYPE_RGB:
				case TGA_TYPE_GREY:
				case TGA_TYPE_RLE_RGB:
				case TGA_TYPE_RLE_GREY:
					if ( header.colormap_type ) {

						console.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );

					}
					break;

				// What the need of a file without data ?

				case TGA_TYPE_NO_DATA:
					console.error( 'THREE.TGALoader: No data.' );

				// Invalid type ?

				default:
					console.error( 'THREE.TGALoader: Invalid type "%s".', header.image_type );

			}

			// check image width and height

			if ( header.width <= 0 || header.height <= 0 ) {

				console.error( 'THREE.TGALoader: Invalid image size.' );

			}

			// check image pixel size

			if ( header.pixel_size !== 8 && header.pixel_size !== 16 &&
				header.pixel_size !== 24 && header.pixel_size !== 32 ) {

				console.error( 'THREE.TGALoader: Invalid pixel size "%s".', header.pixel_size );

			}

		}

		// parse tga image buffer

		function tgaParse( use_rle, use_pal, header, offset, data ) {

			var pixel_data,
				pixel_size,
				pixel_total,
				palettes;

			pixel_size = header.pixel_size >> 3;
			pixel_total = header.width * header.height * pixel_size;

			 // read palettes

			 if ( use_pal ) {

				 palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );

			 }

			 // read RLE

			 if ( use_rle ) {

				 pixel_data = new Uint8Array( pixel_total );

				var c, count, i;
				var shift = 0;
				var pixels = new Uint8Array( pixel_size );

				while ( shift < pixel_total ) {

					c = data[ offset ++ ];
					count = ( c & 0x7f ) + 1;

					// RLE pixels

					if ( c & 0x80 ) {

						// bind pixel tmp array

						for ( i = 0; i < pixel_size; ++ i ) {

							pixels[ i ] = data[ offset ++ ];

						}

						// copy pixel array

						for ( i = 0; i < count; ++ i ) {

							pixel_data.set( pixels, shift + i * pixel_size );

						}

						shift += pixel_size * count;

					} else {

						// raw pixels

						count *= pixel_size;
						for ( i = 0; i < count; ++ i ) {

							pixel_data[ shift + i ] = data[ offset ++ ];

						}
						shift += count;

					}

				}

			 } else {

				// raw pixels

				pixel_data = data.subarray(
					 offset, offset += ( use_pal ? header.width * header.height : pixel_total )
				);

			 }

			 return {
				pixel_data: pixel_data,
				palettes: palettes
			 };

		}

		function tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {

			var colormap = palettes;
			var color, i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

					color = image[ i ];
					imageData[ ( x + width * y ) * 4 + 3 ] = 255;
					imageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];

				}

			}

			return imageData;

		}

		function tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var color, i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

					color = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?
					imageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;
					imageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;
					imageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;
					imageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;

				}

			}

			return imageData;

		}

		function tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 3 ) {

					imageData[ ( x + width * y ) * 4 + 3 ] = 255;
					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];

				}

			}

			return imageData;

		}

		function tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 4 ) {

					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];
					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];
					imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];

				}

			}

			return imageData;

		}

		function tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var color, i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i ++ ) {

					color = image[ i ];
					imageData[ ( x + width * y ) * 4 + 0 ] = color;
					imageData[ ( x + width * y ) * 4 + 1 ] = color;
					imageData[ ( x + width * y ) * 4 + 2 ] = color;
					imageData[ ( x + width * y ) * 4 + 3 ] = 255;

				}

			}

			return imageData;

		}

		function tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {

			var i = 0, x, y;
			var width = header.width;

			for ( y = y_start; y !== y_end; y += y_step ) {

				for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {

					imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];
					imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];

				}

			}

			return imageData;

		}

		function getTgaRGBA( data, width, height, image, palette ) {

			var x_start,
				y_start,
				x_step,
				y_step,
				x_end,
				y_end;

			switch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {

				default:
				case TGA_ORIGIN_UL:
					x_start = 0;
					x_step = 1;
					x_end = width;
					y_start = 0;
					y_step = 1;
					y_end = height;
					break;

				case TGA_ORIGIN_BL:
					x_start = 0;
					x_step = 1;
					x_end = width;
					y_start = height - 1;
					y_step = - 1;
					y_end = - 1;
					break;

				case TGA_ORIGIN_UR:
					x_start = width - 1;
					x_step = - 1;
					x_end = - 1;
					y_start = 0;
					y_step = 1;
					y_end = height;
					break;

				case TGA_ORIGIN_BR:
					x_start = width - 1;
					x_step = - 1;
					x_end = - 1;
					y_start = height - 1;
					y_step = - 1;
					y_end = - 1;
					break;

			}

			if ( use_grey ) {

				switch ( header.pixel_size ) {

					case 8:
						tgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 16:
						tgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					default:
						console.error( 'THREE.TGALoader: Format not supported.' );
						break;

				}

			} else {

				switch ( header.pixel_size ) {

					case 8:
						tgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );
						break;

					case 16:
						tgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 24:
						tgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					case 32:
						tgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );
						break;

					default:
						console.error( 'THREE.TGALoader: Format not supported.' );
						break;

				}

			}

			// Load image data according to specific method
			// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
			// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
			return data;

		}

		// TGA constants

		var TGA_TYPE_NO_DATA = 0,
			TGA_TYPE_INDEXED = 1,
			TGA_TYPE_RGB = 2,
			TGA_TYPE_GREY = 3,
			TGA_TYPE_RLE_INDEXED = 9,
			TGA_TYPE_RLE_RGB = 10,
			TGA_TYPE_RLE_GREY = 11,

			TGA_ORIGIN_MASK = 0x30,
			TGA_ORIGIN_SHIFT = 0x04,
			TGA_ORIGIN_BL = 0x00,
			TGA_ORIGIN_BR = 0x01,
			TGA_ORIGIN_UL = 0x02,
			TGA_ORIGIN_UR = 0x03;

		if ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );

		var content = new Uint8Array( buffer ),
			offset = 0,
			header = {
				id_length: content[ offset ++ ],
				colormap_type: content[ offset ++ ],
				image_type: content[ offset ++ ],
				colormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,
				colormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,
				colormap_size: content[ offset ++ ],
				origin: [
					content[ offset ++ ] | content[ offset ++ ] << 8,
					content[ offset ++ ] | content[ offset ++ ] << 8
				],
				width: content[ offset ++ ] | content[ offset ++ ] << 8,
				height: content[ offset ++ ] | content[ offset ++ ] << 8,
				pixel_size: content[ offset ++ ],
				flags: content[ offset ++ ]
			};

			// check tga if it is valid format

		tgaCheckHeader( header );

		if ( header.id_length + offset > buffer.length ) {

			console.error( 'THREE.TGALoader: No data.' );

		}

		// skip the needn't data

		offset += header.id_length;

		// get targa information about RLE compression and palette

		var use_rle = false,
			use_pal = false,
			use_grey = false;

		switch ( header.image_type ) {

			case TGA_TYPE_RLE_INDEXED:
				use_rle = true;
				use_pal = true;
				break;

			case TGA_TYPE_INDEXED:
				use_pal = true;
				break;

			case TGA_TYPE_RLE_RGB:
				use_rle = true;
				break;

			case TGA_TYPE_RGB:
				break;

			case TGA_TYPE_RLE_GREY:
				use_rle = true;
				use_grey = true;
				break;

			case TGA_TYPE_GREY:
				use_grey = true;
				break;

		}

		//

		var canvas = document.createElement( 'canvas' );
		canvas.width = header.width;
		canvas.height = header.height;

		var context = canvas.getContext( '2d' );
		var imageData = context.createImageData( header.width, header.height );

		var result = tgaParse( use_rle, use_pal, header, offset, content );
		var rgbaData = getTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );

		context.putImageData( imageData, 0, 0 );

		return canvas;

	}

};

/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */

THREE.MTLLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MTLLoader.prototype = {

	constructor: THREE.MTLLoader,

	/**
	 * Loads and parses a MTL asset from a URL.
	 *
	 * @param {String} url - URL to the MTL file.
	 * @param {Function} [onLoad] - Callback invoked with the loaded object.
	 * @param {Function} [onProgress] - Callback for download progress.
	 * @param {Function} [onError] - Callback for download errors.
	 *
	 * @see setPath setTexturePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setPath and/or setTexturePath explicitly prior to load.
	 */
	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.FileLoader( this.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( text ) );

		}, onProgress, onError );

	},

	/**
	 * Set base path for resolving references.
	 * If set this path will be prepended to each loaded and found reference.
	 *
	 * @see setTexturePath
	 * @param {String} path
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */
	setPath: function ( path ) {

		this.path = path;

	},

	/**
	 * Set base path for resolving texture references.
	 * If set this path will be prepended found texture reference.
	 * If not set and setPath is, it will be used as texture base path.
	 *
	 * @see setPath
	 * @param {String} path
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.setTexturePath( 'assets/textures/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */
	setTexturePath: function ( path ) {

		this.texturePath = path;

	},

	setBaseUrl: function ( path ) {

		console.warn( 'THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' );

		this.setTexturePath( path );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setMaterialOptions: function ( value ) {

		this.materialOptions = value;

	},

	/**
	 * Parses a MTL file.
	 *
	 * @param {String} text - Content of MTL file
	 * @return {THREE.MTLLoader.MaterialCreator}
	 *
	 * @see setPath setTexturePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setPath and/or setTexturePath explicitly prior to parse.
	 */
	parse: function ( text ) {

		var lines = text.split( '\n' );
		var info = {};
		var delimiter_pattern = /\s+/;
		var materialsInfo = {};

		for ( var i = 0; i < lines.length; i ++ ) {

			var line = lines[ i ];
			line = line.trim();

			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

				// Blank line or comment ignore
				continue;

			}

			var pos = line.indexOf( ' ' );

			var key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
			key = key.toLowerCase();

			var value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';
			value = value.trim();

			if ( key === 'newmtl' ) {

				// New material

				info = { name: value };
				materialsInfo[ value ] = info;

			} else if ( info ) {

				if ( key === 'ka' || key === 'kd' || key === 'ks' ) {

					var ss = value.split( delimiter_pattern, 3 );
					info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];

				} else {

					info[ key ] = value;

				}

			}

		}

		var materialCreator = new THREE.MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions );
		materialCreator.setCrossOrigin( this.crossOrigin );
		materialCreator.setManager( this.manager );
		materialCreator.setMaterials( materialsInfo );
		return materialCreator;

	}

};

/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

THREE.MTLLoader.MaterialCreator = function ( baseUrl, options ) {

	this.baseUrl = baseUrl || '';
	this.options = options;
	this.materialsInfo = {};
	this.materials = {};
	this.materialsArray = [];
	this.nameLookup = {};

	this.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;
	this.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;

};

THREE.MTLLoader.MaterialCreator.prototype = {

	constructor: THREE.MTLLoader.MaterialCreator,

	crossOrigin: 'Anonymous',

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setManager: function ( value ) {

		this.manager = value;

	},

	setMaterials: function ( materialsInfo ) {

		this.materialsInfo = this.convert( materialsInfo );
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};

	},

	convert: function ( materialsInfo ) {

		if ( ! this.options ) return materialsInfo;

		var converted = {};

		for ( var mn in materialsInfo ) {

			// Convert materials info into normalized form based on options

			var mat = materialsInfo[ mn ];

			var covmat = {};

			converted[ mn ] = covmat;

			for ( var prop in mat ) {

				var save = true;
				var value = mat[ prop ];
				var lprop = prop.toLowerCase();

				switch ( lprop ) {

					case 'kd':
					case 'ka':
					case 'ks':

						// Diffuse color (color under white light) using RGB values

						if ( this.options && this.options.normalizeRGB ) {

							value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

						}

						if ( this.options && this.options.ignoreZeroRGBs ) {

							if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {

								// ignore

								save = false;

							}

						}

						break;

					default:

						break;

				}

				if ( save ) {

					covmat[ lprop ] = value;

				}

			}

		}

		return converted;

	},

	preload: function () {

		for ( var mn in this.materialsInfo ) {

			this.create( mn );

		}

	},

	getIndex: function ( materialName ) {

		return this.nameLookup[ materialName ];

	},

	getAsArray: function () {

		var index = 0;

		for ( var mn in this.materialsInfo ) {

			this.materialsArray[ index ] = this.create( mn );
			this.nameLookup[ mn ] = index;
			index ++;

		}

		return this.materialsArray;

	},

	create: function ( materialName ) {

		if ( this.materials[ materialName ] === undefined ) {

			this.createMaterial_( materialName );

		}

		return this.materials[ materialName ];

	},

	createMaterial_: function ( materialName ) {

		// Create material

		var scope = this;
		var mat = this.materialsInfo[ materialName ];
		var params = {

			name: materialName,
			side: this.side

		};

		function resolveURL( baseUrl, url ) {

			if ( typeof url !== 'string' || url === '' )
				return '';

			// Absolute URL
			if ( /^https?:\/\//i.test( url ) ) return url;

			return baseUrl + url;

		}

		function setMapForType( mapType, value ) {

			if ( params[ mapType ] ) return; // Keep the first encountered texture

			var texParams = scope.getTextureParams( value, params );
			var map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );

			map.repeat.copy( texParams.scale );
			map.offset.copy( texParams.offset );

			map.wrapS = scope.wrap;
			map.wrapT = scope.wrap;

			params[ mapType ] = map;

		}

		for ( var prop in mat ) {

			var value = mat[ prop ];
			var n;

			if ( value === '' ) continue;

			switch ( prop.toLowerCase() ) {

				// Ns is material specular exponent

				case 'kd':

					// Diffuse color (color under white light) using RGB values

					params.color = new THREE.Color().fromArray( value );

					break;

				case 'ks':

					// Specular color (color when light is reflected from shiny surface) using RGB values
					params.specular = new THREE.Color().fromArray( value );

					break;

				case 'map_kd':

					// Diffuse texture map

					setMapForType( "map", value );

					break;

				case 'map_ks':

					// Specular map

					setMapForType( "specularMap", value );

					break;

				case 'norm':

					setMapForType( "normalMap", value );

					break;

				case 'map_bump':
				case 'bump':

					// Bump texture map

					setMapForType( "bumpMap", value );

					break;

				case 'ns':

					// The specular exponent (defines the focus of the specular highlight)
					// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

					params.shininess = parseFloat( value );

					break;

				case 'd':
					n = parseFloat( value );

					if ( n < 1 ) {

						params.opacity = n;
						params.transparent = true;

					}

					break;

				case 'tr':
					n = parseFloat( value );

					if ( n > 0 ) {

						params.opacity = 1 - n;
						params.transparent = true;

					}

					break;

				default:
					break;

			}

		}

		this.materials[ materialName ] = new THREE.MeshPhongMaterial( params );
		return this.materials[ materialName ];

	},

	getTextureParams: function ( value, matParams ) {

		var texParams = {

			scale: new THREE.Vector2( 1, 1 ),
			offset: new THREE.Vector2( 0, 0 )

		 };

		var items = value.split( /\s+/ );
		var pos;

		pos = items.indexOf( '-bm' );

		if ( pos >= 0 ) {

			matParams.bumpScale = parseFloat( items[ pos + 1 ] );
			items.splice( pos, 2 );

		}

		pos = items.indexOf( '-s' );

		if ( pos >= 0 ) {

			texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		pos = items.indexOf( '-o' );

		if ( pos >= 0 ) {

			texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		texParams.url = items.join( ' ' ).trim();
		return texParams;

	},

	loadTexture: function ( url, mapping, onLoad, onProgress, onError ) {

		var texture;
		var loader = THREE.Loader.Handlers.get( url );
		var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;

		if ( loader === null ) {

			loader = new THREE.TextureLoader( manager );

		}

		if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );
		texture = loader.load( url, onLoad, onProgress, onError );

		if ( mapping !== undefined ) texture.mapping = mapping;

		return texture;

	}

};

/*!
 * Socket.IO v2.3.0
 * (c) 2014-2019 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){function r(t,e){"object"==typeof t&&(e=t,t=void 0),e=e||{};var n,r=o(t),i=r.source,u=r.id,p=r.path,h=c[u]&&p in c[u].nsps,f=e.forceNew||e["force new connection"]||!1===e.multiplex||h;return f?(a("ignoring socket cache for %s",i),n=s(i,e)):(c[u]||(a("new io instance for %s",i),c[u]=s(i,e)),n=c[u]),r.query&&!e.query&&(e.query=r.query),n.socket(r.path,e)}var o=n(1),i=n(7),s=n(15),a=n(3)("socket.io-client");t.exports=e=r;var c=e.managers={};e.protocol=i.protocol,e.connect=r,e.Manager=n(15),e.Socket=n(39)},function(t,e,n){function r(t,e){var n=t;e=e||"undefined"!=typeof location&&location,null==t&&(t=e.protocol+"//"+e.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?e.protocol+t:e.host+t),/^(https?|wss?):\/\//.test(t)||(i("protocol-less url %s",t),t="undefined"!=typeof e?e.protocol+"//"+t:"https://"+t),i("parse %s",t),n=o(t)),n.port||(/^(http|ws)$/.test(n.protocol)?n.port="80":/^(http|ws)s$/.test(n.protocol)&&(n.port="443")),n.path=n.path||"/";var r=n.host.indexOf(":")!==-1,s=r?"["+n.host+"]":n.host;return n.id=n.protocol+"://"+s+":"+n.port,n.href=n.protocol+"://"+s+(e&&e.port===n.port?"":":"+n.port),n}var o=n(2),i=n(3)("socket.io-client:url");t.exports=r},function(t,e){var n=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,r=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=n.exec(t||""),a={},c=14;c--;)a[r[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e,n){(function(r){"use strict";function o(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function i(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),this.useColors){var n="color: "+this.color;e.splice(1,0,n,"color: inherit");var r=0,o=0;e[0].replace(/%[a-zA-Z%]/g,function(t){"%%"!==t&&(r++,"%c"===t&&(o=r))}),e.splice(o,0,n)}}function s(){var t;return"object"===("undefined"==typeof console?"undefined":p(console))&&console.log&&(t=console).log.apply(t,arguments)}function a(t){try{t?e.storage.setItem("debug",t):e.storage.removeItem("debug")}catch(n){}}function c(){var t=void 0;try{t=e.storage.getItem("debug")}catch(n){}return!t&&"undefined"!=typeof r&&"env"in r&&(t=r.env.DEBUG),t}function u(){try{return localStorage}catch(t){}}var p="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage=u(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.exports=n(5)(e);var h=t.exports.formatters;h.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}).call(e,n(4))},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function o(t){if(p===setTimeout)return setTimeout(t,0);if((p===n||!p)&&setTimeout)return p=setTimeout,setTimeout(t,0);try{return p(t,0)}catch(e){try{return p.call(null,t,0)}catch(e){return p.call(this,t,0)}}}function i(t){if(h===clearTimeout)return clearTimeout(t);if((h===r||!h)&&clearTimeout)return h=clearTimeout,clearTimeout(t);try{return h(t)}catch(e){try{return h.call(null,t)}catch(e){return h.call(this,t)}}}function s(){y&&l&&(y=!1,l.length?d=l.concat(d):m=-1,d.length&&a())}function a(){if(!y){var t=o(s);y=!0;for(var e=d.length;e;){for(l=d,d=[];++m<e;)l&&l[m].run();m=-1,e=d.length}l=null,y=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function u(){}var p,h,f=t.exports={};!function(){try{p="function"==typeof setTimeout?setTimeout:n}catch(t){p=n}try{h="function"==typeof clearTimeout?clearTimeout:r}catch(t){h=r}}();var l,d=[],y=!1,m=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];d.push(new c(t,e)),1!==d.length||y||o(a)},c.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=u,f.addListener=u,f.once=u,f.off=u,f.removeListener=u,f.removeAllListeners=u,f.emit=u,f.prependListener=u,f.prependOnceListener=u,f.listeners=function(t){return[]},f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},function(t,e,n){"use strict";function r(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function o(t){function e(t){for(var e=0,n=0;n<t.length;n++)e=(e<<5)-e+t.charCodeAt(n),e|=0;return o.colors[Math.abs(e)%o.colors.length]}function o(t){function n(){for(var t=arguments.length,e=Array(t),i=0;i<t;i++)e[i]=arguments[i];if(n.enabled){var s=n,a=Number(new Date),c=a-(r||a);s.diff=c,s.prev=r,s.curr=a,r=a,e[0]=o.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");var u=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,function(t,n){if("%%"===t)return t;u++;var r=o.formatters[n];if("function"==typeof r){var i=e[u];t=r.call(s,i),e.splice(u,1),u--}return t}),o.formatArgs.call(s,e);var p=s.log||o.log;p.apply(s,e)}}var r=void 0;return n.namespace=t,n.enabled=o.enabled(t),n.useColors=o.useColors(),n.color=e(t),n.destroy=i,n.extend=s,"function"==typeof o.init&&o.init(n),o.instances.push(n),n}function i(){var t=o.instances.indexOf(this);return t!==-1&&(o.instances.splice(t,1),!0)}function s(t,e){var n=o(this.namespace+("undefined"==typeof e?":":e)+t);return n.log=this.log,n}function a(t){o.save(t),o.names=[],o.skips=[];var e=void 0,n=("string"==typeof t?t:"").split(/[\s,]+/),r=n.length;for(e=0;e<r;e++)n[e]&&(t=n[e].replace(/\*/g,".*?"),"-"===t[0]?o.skips.push(new RegExp("^"+t.substr(1)+"$")):o.names.push(new RegExp("^"+t+"$")));for(e=0;e<o.instances.length;e++){var i=o.instances[e];i.enabled=o.enabled(i.namespace)}}function c(){var t=[].concat(r(o.names.map(p)),r(o.skips.map(p).map(function(t){return"-"+t}))).join(",");return o.enable(""),t}function u(t){if("*"===t[t.length-1])return!0;var e=void 0,n=void 0;for(e=0,n=o.skips.length;e<n;e++)if(o.skips[e].test(t))return!1;for(e=0,n=o.names.length;e<n;e++)if(o.names[e].test(t))return!0;return!1}function p(t){return t.toString().substring(2,t.toString().length-2).replace(/\.\*\?$/,"*")}function h(t){return t instanceof Error?t.stack||t.message:t}return o.debug=o,o["default"]=o,o.coerce=h,o.disable=c,o.enable=a,o.enabled=u,o.humanize=n(6),Object.keys(t).forEach(function(e){o[e]=t[e]}),o.instances=[],o.names=[],o.skips=[],o.formatters={},o.selectColor=e,o.enable(o.load()),o}t.exports=o},function(t,e){function n(t){if(t=String(t),!(t.length>100)){var e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return n*h;case"weeks":case"week":case"w":return n*p;case"days":case"day":case"d":return n*u;case"hours":case"hour":case"hrs":case"hr":case"h":return n*c;case"minutes":case"minute":case"mins":case"min":case"m":return n*a;case"seconds":case"second":case"secs":case"sec":case"s":return n*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}}}function r(t){var e=Math.abs(t);return e>=u?Math.round(t/u)+"d":e>=c?Math.round(t/c)+"h":e>=a?Math.round(t/a)+"m":e>=s?Math.round(t/s)+"s":t+"ms"}function o(t){var e=Math.abs(t);return e>=u?i(t,e,u,"day"):e>=c?i(t,e,c,"hour"):e>=a?i(t,e,a,"minute"):e>=s?i(t,e,s,"second"):t+" ms"}function i(t,e,n,r){var o=e>=1.5*n;return Math.round(t/n)+" "+r+(o?"s":"")}var s=1e3,a=60*s,c=60*a,u=24*c,p=7*u,h=365.25*u;t.exports=function(t,e){e=e||{};var i=typeof t;if("string"===i&&t.length>0)return n(t);if("number"===i&&isFinite(t))return e["long"]?o(t):r(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,n){function r(){}function o(t){var n=""+t.type;if(e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(n+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(n+=t.nsp+","),null!=t.id&&(n+=t.id),null!=t.data){var r=i(t.data);if(r===!1)return g;n+=r}return f("encoded %j as %s",t,n),n}function i(t){try{return JSON.stringify(t)}catch(e){return!1}}function s(t,e){function n(t){var n=d.deconstructPacket(t),r=o(n.packet),i=n.buffers;i.unshift(r),e(i)}d.removeBlobs(t,n)}function a(){this.reconstructor=null}function c(t){var n=0,r={type:Number(t.charAt(0))};if(null==e.types[r.type])return h("unknown packet type "+r.type);if(e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type){for(var o="";"-"!==t.charAt(++n)&&(o+=t.charAt(n),n!=t.length););if(o!=Number(o)||"-"!==t.charAt(n))throw new Error("Illegal attachments");r.attachments=Number(o)}if("/"===t.charAt(n+1))for(r.nsp="";++n;){var i=t.charAt(n);if(","===i)break;if(r.nsp+=i,n===t.length)break}else r.nsp="/";var s=t.charAt(n+1);if(""!==s&&Number(s)==s){for(r.id="";++n;){var i=t.charAt(n);if(null==i||Number(i)!=i){--n;break}if(r.id+=t.charAt(n),n===t.length)break}r.id=Number(r.id)}if(t.charAt(++n)){var a=u(t.substr(n)),c=a!==!1&&(r.type===e.ERROR||y(a));if(!c)return h("invalid payload");r.data=a}return f("decoded %s as %j",t,r),r}function u(t){try{return JSON.parse(t)}catch(e){return!1}}function p(t){this.reconPack=t,this.buffers=[]}function h(t){return{type:e.ERROR,data:"parser error: "+t}}var f=n(8)("socket.io-parser"),l=n(11),d=n(12),y=n(13),m=n(14);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=r,e.Decoder=a;var g=e.ERROR+'"encode error"';r.prototype.encode=function(t,n){if(f("encoding packet %j",t),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)s(t,n);else{var r=o(t);n([r])}},l(a.prototype),a.prototype.add=function(t){var n;if("string"==typeof t)n=c(t),e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type?(this.reconstructor=new p(n),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",n)):this.emit("decoded",n);else{if(!m(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");n=this.reconstructor.takeBinaryData(t),n&&(this.reconstructor=null,this.emit("decoded",n))}},a.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},p.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=d.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,n){(function(r){"use strict";function o(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function i(t){var n=this.useColors;if(t[0]=(n?"%c":"")+this.namespace+(n?" %c":" ")+t[0]+(n?"%c ":" ")+"+"+e.humanize(this.diff),n){var r="color: "+this.color;t.splice(1,0,r,"color: inherit");var o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,function(t){"%%"!==t&&(o++,"%c"===t&&(i=o))}),t.splice(i,0,r)}}function s(){return"object"===("undefined"==typeof console?"undefined":p(console))&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function a(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(n){}}function c(){var t;try{t=e.storage.debug}catch(n){}return!t&&"undefined"!=typeof r&&"env"in r&&(t=r.env.DEBUG),t}function u(){try{return window.localStorage}catch(t){}}var p="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};e=t.exports=n(9),e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage="undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage?chrome.storage.local:u(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},e.enable(c())}).call(e,n(4))},function(t,e,n){"use strict";function r(t){var n,r=0;for(n in t)r=(r<<5)-r+t.charCodeAt(n),r|=0;return e.colors[Math.abs(r)%e.colors.length]}function o(t){function n(){if(n.enabled){var t=n,r=+new Date,i=r-(o||r);t.diff=i,t.prev=o,t.curr=r,o=r;for(var s=new Array(arguments.length),a=0;a<s.length;a++)s[a]=arguments[a];s[0]=e.coerce(s[0]),"string"!=typeof s[0]&&s.unshift("%O");var c=0;s[0]=s[0].replace(/%([a-zA-Z%])/g,function(n,r){if("%%"===n)return n;c++;var o=e.formatters[r];if("function"==typeof o){var i=s[c];n=o.call(t,i),s.splice(c,1),c--}return n}),e.formatArgs.call(t,s);var u=n.log||e.log||console.log.bind(console);u.apply(t,s)}}var o;return n.namespace=t,n.enabled=e.enabled(t),n.useColors=e.useColors(),n.color=r(t),n.destroy=i,"function"==typeof e.init&&e.init(n),e.instances.push(n),n}function i(){var t=e.instances.indexOf(this);return t!==-1&&(e.instances.splice(t,1),!0)}function s(t){e.save(t),e.names=[],e.skips=[];var n,r=("string"==typeof t?t:"").split(/[\s,]+/),o=r.length;for(n=0;n<o;n++)r[n]&&(t=r[n].replace(/\*/g,".*?"),"-"===t[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")));for(n=0;n<e.instances.length;n++){var i=e.instances[n];i.enabled=e.enabled(i.namespace)}}function a(){e.enable("")}function c(t){if("*"===t[t.length-1])return!0;var n,r;for(n=0,r=e.skips.length;n<r;n++)if(e.skips[n].test(t))return!1;for(n=0,r=e.names.length;n<r;n++)if(e.names[n].test(t))return!0;return!1}function u(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o.debug=o["default"]=o,e.coerce=u,e.disable=a,e.enable=s,e.enabled=c,e.humanize=n(10),e.instances=[],e.names=[],e.skips=[],e.formatters={}},function(t,e){function n(t){if(t=String(t),!(t.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return n*p;case"days":case"day":case"d":return n*u;case"hours":case"hour":case"hrs":case"hr":case"h":return n*c;case"minutes":case"minute":case"mins":case"min":case"m":return n*a;case"seconds":case"second":case"secs":case"sec":case"s":return n*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}}}function r(t){return t>=u?Math.round(t/u)+"d":t>=c?Math.round(t/c)+"h":t>=a?Math.round(t/a)+"m":t>=s?Math.round(t/s)+"s":t+"ms"}function o(t){return i(t,u,"day")||i(t,c,"hour")||i(t,a,"minute")||i(t,s,"second")||t+" ms"}function i(t,e,n){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+n:Math.ceil(t/e)+" "+n+"s"}var s=1e3,a=60*s,c=60*a,u=24*c,p=365.25*u;t.exports=function(t,e){e=e||{};var i=typeof t;if("string"===i&&t.length>0)return n(t);if("number"===i&&isNaN(t)===!1)return e["long"]?o(t):r(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,n){function r(t){if(t)return o(t)}function o(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},r.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var r,o=0;o<n.length;o++)if(r=n[o],r===e||r.fn===e){n.splice(o,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),n=this._callbacks["$"+t];if(n){n=n.slice(0);for(var r=0,o=n.length;r<o;++r)n[r].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,n){function r(t,e){if(!t)return t;if(s(t)){var n={_placeholder:!0,num:e.length};return e.push(t),n}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=r(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=r(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var n=0;n<t.length;n++)t[n]=o(t[n],e);else if("object"==typeof t)for(var r in t)t[r]=o(t[r],e);return t}var i=n(13),s=n(14),a=Object.prototype.toString,c="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===a.call(Blob),u="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===a.call(File);e.deconstructPacket=function(t){var e=[],n=t.data,o=t;return o.data=r(n,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function n(t,a,p){if(!t)return t;if(c&&t instanceof Blob||u&&t instanceof File){r++;var h=new FileReader;h.onload=function(){p?p[a]=this.result:o=this.result,--r||e(o)},h.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)n(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)n(t[l],l,t)}var r=0,o=t;n(o),r||e(o)}},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e){function n(t){return r&&Buffer.isBuffer(t)||o&&(t instanceof ArrayBuffer||i(t))}t.exports=n;var r="function"==typeof Buffer&&"function"==typeof Buffer.isBuffer,o="function"==typeof ArrayBuffer,i=function(t){return"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t.buffer instanceof ArrayBuffer}},function(t,e,n){function r(t,e){if(!(this instanceof r))return new r(t,e);t&&"object"==typeof t&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new f({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var n=e.parser||a;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o=n(16),i=n(39),s=n(11),a=n(7),c=n(41),u=n(42),p=n(3)("socket.io-client:manager"),h=n(38),f=n(43),l=Object.prototype.hasOwnProperty;t.exports=r,r.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)l.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},r.prototype.updateSocketIds=function(){for(var t in this.nsps)l.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},r.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},s(r.prototype),r.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},r.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},r.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},r.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},r.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},r.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},r.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},r.prototype.open=r.prototype.connect=function(t,e){if(p("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;p("opening %s",this.uri),this.engine=o(this.uri,this.opts);var n=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var i=c(n,"open",function(){r.onopen(),t&&t()}),s=c(n,"error",function(e){if(p("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",e),t){var n=new Error("Connection error");n.data=e,t(n)}else r.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout;p("connect attempt will timeout after %d",a);var u=setTimeout(function(){p("connect attempt timed out after %d",a),i.destroy(),n.close(),n.emit("error","timeout"),r.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(u)}})}return this.subs.push(i),this.subs.push(s),this},r.prototype.onopen=function(){p("open"),this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(c(t,"data",u(this,"ondata"))),this.subs.push(c(t,"ping",u(this,"onping"))),this.subs.push(c(t,"pong",u(this,"onpong"))),this.subs.push(c(t,"error",u(this,"onerror"))),this.subs.push(c(t,"close",u(this,"onclose"))),this.subs.push(c(this.decoder,"decoded",u(this,"ondecoded")))},r.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},r.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},r.prototype.ondata=function(t){this.decoder.add(t)},r.prototype.ondecoded=function(t){this.emit("packet",t)},r.prototype.onerror=function(t){p("error",t),this.emitAll("error",t)},r.prototype.socket=function(t,e){function n(){~h(o.connecting,r)||o.connecting.push(r)}var r=this.nsps[t];if(!r){r=new i(this,t,e),this.nsps[t]=r;var o=this;r.on("connecting",n),r.on("connect",function(){r.id=o.generateId(t)}),this.autoConnect&&n()}return r},r.prototype.destroy=function(t){var e=h(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},r.prototype.packet=function(t){p("writing packet %j",t);var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(n){for(var r=0;r<n.length;r++)e.engine.write(n[r],t.options);e.encoding=!1,e.processPacketQueue()}))},r.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},r.prototype.cleanup=function(){p("cleanup");for(var t=this.subs.length,e=0;e<t;e++){var n=this.subs.shift();n.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},r.prototype.close=r.prototype.disconnect=function(){p("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},r.prototype.onclose=function(t){p("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},r.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)p("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();p("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var n=setTimeout(function(){t.skipReconnect||(p("attempting reconnect"),t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(p("reconnect attempt error"),t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):(p("reconnect success"),t.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(n)}})}},r.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,n){t.exports=n(17),t.exports.parser=n(24)},function(t,e,n){function r(t,e){return this instanceof r?(e=e||{},t&&"object"==typeof t&&(e=t,t=null),t?(t=p(t),e.hostname=t.host,e.secure="https"===t.protocol||"wss"===t.protocol,e.port=t.port,t.query&&(e.query=t.query)):e.host&&(e.hostname=p(e.host).host),this.secure=null!=e.secure?e.secure:"undefined"!=typeof location&&"https:"===location.protocol,e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=e.port||("undefined"!=typeof location&&location.port?location.port:this.secure?443:80),this.query=e.query||{},"string"==typeof this.query&&(this.query=h.decode(this.query)),this.upgrade=!1!==e.upgrade,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=!1!==e.jsonp,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.withCredentials=!1!==e.withCredentials,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=!1!==e.perMessageDeflate&&(e.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||null,this.key=e.key||null,this.passphrase=e.passphrase||null,this.cert=e.cert||null,this.ca=e.ca||null,this.ciphers=e.ciphers||null,this.rejectUnauthorized=void 0===e.rejectUnauthorized||e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),("undefined"==typeof self||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,void this.open()):new r(t,e)}function o(t){var e={};for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}var i=n(18),s=n(11),a=n(3)("engine.io-client:socket"),c=n(38),u=n(24),p=n(2),h=n(32);t.exports=r,r.priorWebsocketSuccess=!1,s(r.prototype),r.protocol=u.protocol,r.Socket=r,r.Transport=n(23),r.transports=n(18),r.parser=n(24),r.prototype.createTransport=function(t){a('creating transport "%s"',t);var e=o(this.query);e.EIO=u.protocol,e.transport=t;var n=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var r=new i[t]({query:e,socket:this,agent:n.agent||this.agent,hostname:n.hostname||this.hostname,port:n.port||this.port,secure:n.secure||this.secure,path:n.path||this.path,forceJSONP:n.forceJSONP||this.forceJSONP,jsonp:n.jsonp||this.jsonp,forceBase64:n.forceBase64||this.forceBase64,enablesXDR:n.enablesXDR||this.enablesXDR,withCredentials:n.withCredentials||this.withCredentials,timestampRequests:n.timestampRequests||this.timestampRequests,timestampParam:n.timestampParam||this.timestampParam,policyPort:n.policyPort||this.policyPort,pfx:n.pfx||this.pfx,key:n.key||this.key,passphrase:n.passphrase||this.passphrase,cert:n.cert||this.cert,ca:n.ca||this.ca,ciphers:n.ciphers||this.ciphers,rejectUnauthorized:n.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:n.perMessageDeflate||this.perMessageDeflate,extraHeaders:n.extraHeaders||this.extraHeaders,forceNode:n.forceNode||this.forceNode,localAddress:n.localAddress||this.localAddress,requestTimeout:n.requestTimeout||this.requestTimeout,protocols:n.protocols||void 0,isReactNative:this.isReactNative});return r},r.prototype.open=function(){var t;if(this.rememberUpgrade&&r.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{
if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(n){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},r.prototype.setTransport=function(t){a("setting transport %s",t.name);var e=this;this.transport&&(a("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},r.prototype.probe=function(t){function e(){if(f.onlyBinaryUpgrades){var e=!this.supportsBinary&&f.transport.supportsBinary;h=h||e}h||(a('probe transport "%s" opened',t),p.send([{type:"ping",data:"probe"}]),p.once("packet",function(e){if(!h)if("pong"===e.type&&"probe"===e.data){if(a('probe transport "%s" pong',t),f.upgrading=!0,f.emit("upgrading",p),!p)return;r.priorWebsocketSuccess="websocket"===p.name,a('pausing current transport "%s"',f.transport.name),f.transport.pause(function(){h||"closed"!==f.readyState&&(a("changing transport and sending upgrade packet"),u(),f.setTransport(p),p.send([{type:"upgrade"}]),f.emit("upgrade",p),p=null,f.upgrading=!1,f.flush())})}else{a('probe transport "%s" failed',t);var n=new Error("probe error");n.transport=p.name,f.emit("upgradeError",n)}}))}function n(){h||(h=!0,u(),p.close(),p=null)}function o(e){var r=new Error("probe error: "+e);r.transport=p.name,n(),a('probe transport "%s" failed because of error: %s',t,e),f.emit("upgradeError",r)}function i(){o("transport closed")}function s(){o("socket closed")}function c(t){p&&t.name!==p.name&&(a('"%s" works - aborting "%s"',t.name,p.name),n())}function u(){p.removeListener("open",e),p.removeListener("error",o),p.removeListener("close",i),f.removeListener("close",s),f.removeListener("upgrading",c)}a('probing transport "%s"',t);var p=this.createTransport(t,{probe:1}),h=!1,f=this;r.priorWebsocketSuccess=!1,p.once("open",e),p.once("error",o),p.once("close",i),this.once("close",s),this.once("upgrading",c),p.open()},r.prototype.onOpen=function(){if(a("socket open"),this.readyState="open",r.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause){a("starting upgrade probes");for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},r.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(a('socket receive: type "%s", data "%s"',t.type,t.data),this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}else a('packet received with socket readyState "%s"',this.readyState)},r.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},r.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},r.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){a("writing ping packet - expecting pong within %sms",t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},r.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},r.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},r.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(a("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},r.prototype.write=r.prototype.send=function(t,e,n){return this.sendPacket("message",t,e,n),this},r.prototype.sendPacket=function(t,e,n,r){if("function"==typeof e&&(r=e,e=void 0),"function"==typeof n&&(r=n,n=null),"closing"!==this.readyState&&"closed"!==this.readyState){n=n||{},n.compress=!1!==n.compress;var o={type:t,data:e,options:n};this.emit("packetCreate",o),this.writeBuffer.push(o),r&&this.once("flush",r),this.flush()}},r.prototype.close=function(){function t(){r.onClose("forced close"),a("socket closing - telling transport to close"),r.transport.close()}function e(){r.removeListener("upgrade",e),r.removeListener("upgradeError",e),t()}function n(){r.once("upgrade",e),r.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var r=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?n():t()}):this.upgrading?n():t()}return this},r.prototype.onError=function(t){a("socket error %j",t),r.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},r.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){a('socket close with reason: "%s"',t);var n=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),n.writeBuffer=[],n.prevBufferLen=0}},r.prototype.filterUpgrades=function(t){for(var e=[],n=0,r=t.length;n<r;n++)~c(this.transports,t[n])&&e.push(t[n]);return e}},function(t,e,n){function r(t){var e,n=!1,r=!1,a=!1!==t.jsonp;if("undefined"!=typeof location){var c="https:"===location.protocol,u=location.port;u||(u=c?443:80),n=t.hostname!==location.hostname||u!==t.port,r=t.secure!==c}if(t.xdomain=n,t.xscheme=r,e=new o(t),"open"in e&&!t.forceJSONP)return new i(t);if(!a)throw new Error("JSONP disabled");return new s(t)}var o=n(19),i=n(21),s=n(35),a=n(36);e.polling=r,e.websocket=a},function(t,e,n){var r=n(20);t.exports=function(t){var e=t.xdomain,n=t.xscheme,o=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!e||r))return new XMLHttpRequest}catch(i){}try{if("undefined"!=typeof XDomainRequest&&!n&&o)return new XDomainRequest}catch(i){}if(!e)try{return new(self[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(i){}}},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(n){t.exports=!1}},function(t,e,n){function r(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,"undefined"!=typeof location){var e="https:"===location.protocol,n=location.port;n||(n=e?443:80),this.xd="undefined"!=typeof location&&t.hostname!==location.hostname||n!==t.port,this.xs=t.secure!==e}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.withCredentials=t.withCredentials,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=n(19),c=n(22),u=n(11),p=n(33),h=n(3)("engine.io-client:polling-xhr");if(t.exports=o,t.exports.Request=i,p(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.withCredentials=this.withCredentials,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var n="string"!=typeof t&&void 0!==t,r=this.request({method:"POST",data:t,isBinary:n}),o=this;r.on("success",e),r.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=r},o.prototype.doPoll=function(){h("xhr poll");var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},u(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new a(t),n=this;try{h("xhr open %s: %s",this.method,this.uri),e.open(this.method,this.uri,this.async);try{if(this.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(var r in this.extraHeaders)this.extraHeaders.hasOwnProperty(r)&&e.setRequestHeader(r,this.extraHeaders[r])}}catch(o){}if("POST"===this.method)try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(o){}try{e.setRequestHeader("Accept","*/*")}catch(o){}"withCredentials"in e&&(e.withCredentials=this.withCredentials),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){n.onLoad()},e.onerror=function(){n.onError(e.responseText)}):e.onreadystatechange=function(){if(2===e.readyState)try{var t=e.getResponseHeader("Content-Type");(n.supportsBinary&&"application/octet-stream"===t||"application/octet-stream; charset=UTF-8"===t)&&(e.responseType="arraybuffer")}catch(r){}4===e.readyState&&(200===e.status||1223===e.status?n.onLoad():setTimeout(function(){n.onError("number"==typeof e.status?e.status:0)},0))},h("xhr data %s",this.data),e.send(this.data)}catch(o){return void setTimeout(function(){n.onError(o)},0)}"undefined"!=typeof document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=r:this.xhr.onreadystatechange=r,t)try{this.xhr.abort()}catch(e){}"undefined"!=typeof document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(n){}t="application/octet-stream"===e||"application/octet-stream; charset=UTF-8"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(n){this.onError(n)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",s);else if("function"==typeof addEventListener){var f="onpagehide"in self?"pagehide":"unload";addEventListener(f,s,!1)}},function(t,e,n){function r(t){var e=t&&t.forceBase64;p&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=n(23),i=n(32),s=n(24),a=n(33),c=n(34),u=n(3)("engine.io-client:polling");t.exports=r;var p=function(){var t=n(19),e=new t({xdomain:!1});return null!=e.responseType}();a(r,o),r.prototype.name="polling",r.prototype.doOpen=function(){this.poll()},r.prototype.pause=function(t){function e(){u("paused"),n.readyState="paused",t()}var n=this;if(this.readyState="pausing",this.polling||!this.writable){var r=0;this.polling&&(u("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){u("pre-pause polling complete"),--r||e()})),this.writable||(u("we are currently writing - waiting to pause"),r++,this.once("drain",function(){u("pre-pause writing complete"),--r||e()}))}else e()},r.prototype.poll=function(){u("polling"),this.polling=!0,this.doPoll(),this.emit("poll")},r.prototype.onData=function(t){var e=this;u("polling got data %s",t);var n=function(t,n,r){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,n),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState?this.poll():u('ignoring poll - transport state "%s"',this.readyState))},r.prototype.doClose=function(){function t(){u("writing close packet"),e.write([{type:"close"}])}var e=this;"open"===this.readyState?(u("transport open - closing"),t()):(u("transport not open - deferring close"),this.once("open",t))},r.prototype.write=function(t){var e=this;this.writable=!1;var n=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,n)})},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",n="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(n=":"+this.port),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t}},function(t,e,n){function r(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.withCredentials=t.withCredentials,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.isReactNative=t.isReactNative,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=n(24),i=n(11);t.exports=r,i(r.prototype),r.prototype.onError=function(t,e){var n=new Error(t);return n.type="TransportError",n.description=e,this.emit("error",n),this},r.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},r.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},r.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},r.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},r.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},r.prototype.onPacket=function(t){this.emit("packet",t)},r.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,n){function r(t,n){var r="b"+e.packets[t.type]+t.data.data;return n(r)}function o(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return r(s.buffer)}function i(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=new FileReader;return o.onload=function(){e.encodePacket({type:t.type,data:o.result},n,!0,r)},o.readAsArrayBuffer(t.data)}function s(t,n,r){if(!n)return e.encodeBase64Packet(t,r);if(g)return i(t,n,r);var o=new Uint8Array(1);o[0]=v[t.type];var s=new w([o.buffer,t.data]);return r(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(e){return!1}return t}function c(t,e,n){for(var r=new Array(t.length),o=l(t.length,n),i=function(t,n,o){e(n,function(e,n){r[t]=n,o(e,r)})},s=0;s<t.length;s++)i(s,t[s],o)}var u,p=n(25),h=n(26),f=n(27),l=n(28),d=n(29);"undefined"!=typeof ArrayBuffer&&(u=n(30));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=p(v),C={type:"error",data:"parser error"},w=n(31);e.encodePacket=function(t,e,n,i){"function"==typeof e&&(i=e,e=!1),"function"==typeof n&&(i=n,n=null);var a=void 0===t.data?void 0:t.data.buffer||t.data;if("undefined"!=typeof ArrayBuffer&&a instanceof ArrayBuffer)return o(t,e,i);if("undefined"!=typeof w&&a instanceof w)return s(t,e,i);if(a&&a.base64)return r(t,i);var c=v[t.type];return void 0!==t.data&&(c+=n?d.encode(String(t.data),{strict:!1}):String(t.data)),i(""+c)},e.encodeBase64Packet=function(t,n){var r="b"+e.packets[t.type];if("undefined"!=typeof w&&t.data instanceof w){var o=new FileReader;return o.onload=function(){var t=o.result.split(",")[1];n(r+t)},o.readAsDataURL(t.data)}var i;try{i=String.fromCharCode.apply(null,new Uint8Array(t.data))}catch(s){for(var a=new Uint8Array(t.data),c=new Array(a.length),u=0;u<a.length;u++)c[u]=a[u];i=String.fromCharCode.apply(null,c)}return r+=btoa(i),n(r)},e.decodePacket=function(t,n,r){if(void 0===t)return C;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),n);if(r&&(t=a(t),t===!1))return C;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:C}var i=new Uint8Array(t),o=i[0],s=f(t,1);return w&&"blob"===n&&(s=new w([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var n=b[t.charAt(0)];if(!u)return{type:n,data:{base64:!0,data:t.substr(1)}};var r=u.decode(t.substr(1));return"blob"===e&&w&&(r=new w([r])),{type:n,data:r}},e.encodePayload=function(t,n,r){function o(t){return t.length+":"+t}function i(t,r){e.encodePacket(t,!!s&&n,!1,function(t){r(null,o(t))})}"function"==typeof n&&(r=n,n=null);var s=h(t);return n&&s?w&&!g?e.encodePayloadAsBlob(t,r):e.encodePayloadAsArrayBuffer(t,r):t.length?void c(t,i,function(t,e){return r(e.join(""))}):r("0:")},e.decodePayload=function(t,n,r){if("string"!=typeof t)return e.decodePayloadAsBinary(t,n,r);"function"==typeof n&&(r=n,n=null);var o;if(""===t)return r(C,0,1);for(var i,s,a="",c=0,u=t.length;c<u;c++){var p=t.charAt(c);if(":"===p){if(""===a||a!=(i=Number(a)))return r(C,0,1);if(s=t.substr(c+1,i),a!=s.length)return r(C,0,1);if(s.length){if(o=e.decodePacket(s,n,!1),C.type===o.type&&C.data===o.data)return r(C,0,1);var h=r(o,c+i,u);if(!1===h)return}c+=i,a=""}else a+=p}return""!==a?r(C,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){return n(null,t)})}return t.length?void c(t,r,function(t,e){var r=e.reduce(function(t,e){var n;return n="string"==typeof e?e.length:e.byteLength,t+n.toString().length+n+2},0),o=new Uint8Array(r),i=0;return e.forEach(function(t){var e="string"==typeof t,n=t;if(e){for(var r=new Uint8Array(t.length),s=0;s<t.length;s++)r[s]=t.charCodeAt(s);n=r.buffer}e?o[i++]=0:o[i++]=1;for(var a=n.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var r=new Uint8Array(n),s=0;s<r.length;s++)o[i++]=r[s]}),n(o.buffer)}):n(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var r=new Uint8Array(t.length),o=0;o<t.length;o++)r[o]=t.charCodeAt(o);t=r.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,w){var c=new w([e.buffer,a.buffer,t]);n(null,c)}})}c(t,r,function(t,e){return n(new w(e))})},e.decodePayloadAsBinary=function(t,n,r){"function"==typeof n&&(r=n,n=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",u=1;255!==s[u];u++){if(c.length>310)return r(C,0,1);c+=s[u]}o=f(o,2+c.length),c=parseInt(c);var p=f(o,0,c);if(a)try{p=String.fromCharCode.apply(null,new Uint8Array(p))}catch(h){var l=new Uint8Array(p);p="";for(var u=0;u<l.length;u++)p+=String.fromCharCode(l[u])}i.push(p),o=f(o,c)}var d=i.length;i.forEach(function(t,o){r(e.decodePacket(t,n,!0),o,d)})}},function(t,e){t.exports=Object.keys||function(t){var e=[],n=Object.prototype.hasOwnProperty;for(var r in t)n.call(t,r)&&e.push(r);return e}},function(t,e,n){function r(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var e=0,n=t.length;e<n;e++)if(r(t[e]))return!0;return!1}if("function"==typeof Buffer&&Buffer.isBuffer&&Buffer.isBuffer(t)||"function"==typeof ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return r(t.toJSON(),!0);for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&r(t[i]))return!0;return!1}var o=n(13),i=Object.prototype.toString,s="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===i.call(Blob),a="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===i.call(File);t.exports=r},function(t,e){t.exports=function(t,e,n){var r=t.byteLength;if(e=e||0,n=n||r,t.slice)return t.slice(e,n);if(e<0&&(e+=r),n<0&&(n+=r),n>r&&(n=r),e>=r||e>=n||0===r)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(n-e),s=e,a=0;s<n;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function n(t,e,n){function o(t,r){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=n):0!==o.count||i||e(null,r)}var i=!1;return n=n||r,o.count=t,0===t?e():o}function r(){}t.exports=n},function(t,e){function n(t){for(var e,n,r=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(n=t.charCodeAt(o++),56320==(64512&n)?r.push(((1023&e)<<10)+(1023&n)+65536):(r.push(e),o--)):r.push(e);return r}function r(t){for(var e,n=t.length,r=-1,o="";++r<n;)e=t[r],e>65535&&(e-=65536,o+=d(e>>>10&1023|55296),e=56320|1023&e),o+=d(e);return o}function o(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function i(t,e){return d(t>>e&63|128)}function s(t,e){if(0==(4294967168&t))return d(t);var n="";return 0==(4294965248&t)?n=d(t>>6&31|192):0==(4294901760&t)?(o(t,e)||(t=65533),n=d(t>>12&15|224),n+=i(t,6)):0==(4292870144&t)&&(n=d(t>>18&7|240),n+=i(t,12),n+=i(t,6)),n+=d(63&t|128)}function a(t,e){e=e||{};for(var r,o=!1!==e.strict,i=n(t),a=i.length,c=-1,u="";++c<a;)r=i[c],u+=s(r,o);return u}function c(){if(l>=f)throw Error("Invalid byte index");var t=255&h[l];if(l++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function u(t){var e,n,r,i,s;if(l>f)throw Error("Invalid byte index");if(l==f)return!1;if(e=255&h[l],l++,0==(128&e))return e;if(192==(224&e)){if(n=c(),s=(31&e)<<6|n,s>=128)return s;throw Error("Invalid continuation byte")}if(224==(240&e)){if(n=c(),r=c(),s=(15&e)<<12|n<<6|r,s>=2048)return o(s,t)?s:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(n=c(),r=c(),i=c(),s=(7&e)<<18|n<<12|r<<6|i,s>=65536&&s<=1114111))return s;throw Error("Invalid UTF-8 detected")}function p(t,e){e=e||{};var o=!1!==e.strict;h=n(t),f=h.length,l=0;for(var i,s=[];(i=u(o))!==!1;)s.push(i);return r(s)}/*! https://mths.be/utf8js v2.1.2 by @mathias */
var h,f,l,d=String.fromCharCode;t.exports={version:"2.1.2",encode:a,decode:p}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),r=0;r<t.length;r++)n[t.charCodeAt(r)]=r;e.encode=function(e){var n,r=new Uint8Array(e),o=r.length,i="";for(n=0;n<o;n+=3)i+=t[r[n]>>2],i+=t[(3&r[n])<<4|r[n+1]>>4],i+=t[(15&r[n+1])<<2|r[n+2]>>6],i+=t[63&r[n+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,r,o,i,s,a=.75*t.length,c=t.length,u=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var p=new ArrayBuffer(a),h=new Uint8Array(p);for(e=0;e<c;e+=4)r=n[t.charCodeAt(e)],o=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],s=n[t.charCodeAt(e+3)],h[u++]=r<<2|o>>4,h[u++]=(15&o)<<4|i>>2,h[u++]=(3&i)<<6|63&s;return p}}()},function(t,e){function n(t){return t.map(function(t){if(t.buffer instanceof ArrayBuffer){var e=t.buffer;if(t.byteLength!==e.byteLength){var n=new Uint8Array(t.byteLength);n.set(new Uint8Array(e,t.byteOffset,t.byteLength)),e=n.buffer}return e}return t})}function r(t,e){e=e||{};var r=new i;return n(t).forEach(function(t){r.append(t)}),e.type?r.getBlob(e.type):r.getBlob()}function o(t,e){return new Blob(n(t),e||{})}var i="undefined"!=typeof i?i:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder&&MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(e){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(e){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;"undefined"!=typeof Blob&&(r.prototype=Blob.prototype,o.prototype=Blob.prototype),t.exports=function(){return s?a?Blob:o:c?r:void 0}()},function(t,e){e.encode=function(t){var e="";for(var n in t)t.hasOwnProperty(n)&&(e.length&&(e+="&"),e+=encodeURIComponent(n)+"="+encodeURIComponent(t[n]));return e},e.decode=function(t){for(var e={},n=t.split("&"),r=0,o=n.length;r<o;r++){var i=n[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}},function(t,e){"use strict";function n(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function r(t){var e=0;for(p=0;p<t.length;p++)e=e*a+c[t.charAt(p)];return e}function o(){var t=n(+new Date);return t!==i?(u=0,i=t):t+"."+n(u++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},u=0,p=0;p<a;p++)c[s[p]]=p;o.encode=n,o.decode=r,t.exports=o},function(t,e,n){(function(e){function r(){}function o(){return"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof e?e:{}}function i(t){if(s.call(this,t),this.query=this.query||{},!c){var e=o();c=e.___eio=e.___eio||[]}this.index=c.length;var n=this;c.push(function(t){n.onData(t)}),this.query.j=this.index,"function"==typeof addEventListener&&addEventListener("beforeunload",function(){n.script&&(n.script.onerror=r)},!1)}var s=n(22),a=n(33);t.exports=i;var c,u=/\n/g,p=/\\n/g;a(i,s),i.prototype.supportsBinary=!1,i.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),s.prototype.doClose.call(this)},i.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var n=document.getElementsByTagName("script")[0];n?n.parentNode.insertBefore(e,n):(document.head||document.body).appendChild(e),this.script=e;var r="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},i.prototype.doWrite=function(t,e){function n(){r(),e()}function r(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var e='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(e)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),c=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=c,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),r(),t=t.replace(p,"\\\n"),this.area.value=t.replace(u,"\\n");try{this.form.submit()}catch(h){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&n()}:this.iframe.onload=n}}).call(e,function(){return this}())},function(t,e,n){function r(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=o&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(l=i),s.call(this,t)}var o,i,s=n(23),a=n(24),c=n(32),u=n(33),p=n(34),h=n(3)("engine.io-client:websocket");if("undefined"!=typeof WebSocket?o=WebSocket:"undefined"!=typeof self&&(o=self.WebSocket||self.MozWebSocket),"undefined"==typeof window)try{i=n(37)}catch(f){}var l=o||i;t.exports=r,u(r,s),r.prototype.name="websocket",r.prototype.supportsBinary=!0,r.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,n={agent:this.agent,perMessageDeflate:this.perMessageDeflate};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(n.headers=this.extraHeaders),this.localAddress&&(n.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new l(t,e):new l(t):new l(t,e,n)}catch(r){return this.emit("error",r)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},r.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},r.prototype.write=function(t){function e(){n.emit("flush"),setTimeout(function(){n.writable=!0,n.emit("drain")},0)}var n=this;this.writable=!1;for(var r=t.length,o=0,i=r;o<i;o++)!function(t){a.encodePacket(t,n.supportsBinary,function(o){if(!n.usingBrowserWebSocket){var i={};if(t.options&&(i.compress=t.options.compress),n.perMessageDeflate){var s="string"==typeof o?Buffer.byteLength(o):o.length;s<n.perMessageDeflate.threshold&&(i.compress=!1)}}try{n.usingBrowserWebSocket?n.ws.send(o):n.ws.send(o,i)}catch(a){h("websocket closed before onclose event")}--r||e()})}(t[o])},r.prototype.onClose=function(){s.prototype.onClose.call(this)},r.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",n="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(n=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=p()),this.supportsBinary||(t.b64=1),t=c.encode(t),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t},r.prototype.check=function(){return!(!l||"__initialize"in l&&this.name===r.prototype.name)}},function(t,e){},function(t,e){var n=[].indexOf;t.exports=function(t,e){if(n)return t.indexOf(e);for(var r=0;r<t.length;++r)if(t[r]===e)return r;return-1}},function(t,e,n){function r(t,e,n){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},n&&n.query&&(this.query=n.query),this.io.autoConnect&&this.open()}var o=n(7),i=n(11),s=n(40),a=n(41),c=n(42),u=n(3)("socket.io-client:socket"),p=n(32),h=n(26);t.exports=e=r;var f={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},l=i.prototype.emit;i(r.prototype),r.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[a(t,"open",c(this,"onopen")),a(t,"packet",c(this,"onpacket")),a(t,"close",c(this,"onclose"))]}},r.prototype.open=r.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},r.prototype.send=function(){var t=s(arguments);return t.unshift("message"),this.emit.apply(this,t),this},r.prototype.emit=function(t){if(f.hasOwnProperty(t))return l.apply(this,arguments),this;var e=s(arguments),n={type:(void 0!==this.flags.binary?this.flags.binary:h(e))?o.BINARY_EVENT:o.EVENT,data:e};return n.options={},n.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(u("emitting packet with ack id %d",this.ids),this.acks[this.ids]=e.pop(),n.id=this.ids++),this.connected?this.packet(n):this.sendBuffer.push(n),this.flags={},this},r.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},r.prototype.onopen=function(){if(u("transport is open - connecting"),"/"!==this.nsp)if(this.query){var t="object"==typeof this.query?p.encode(this.query):this.query;u("sending connect packet with query %s",t),this.packet({type:o.CONNECT,query:t})}else this.packet({type:o.CONNECT})},r.prototype.onclose=function(t){u("close (%s)",t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},r.prototype.onpacket=function(t){var e=t.nsp===this.nsp,n=t.type===o.ERROR&&"/"===t.nsp;if(e||n)switch(t.type){case o.CONNECT:this.onconnect();break;case o.EVENT:this.onevent(t);break;case o.BINARY_EVENT:this.onevent(t);break;case o.ACK:this.onack(t);break;case o.BINARY_ACK:this.onack(t);break;case o.DISCONNECT:this.ondisconnect();break;case o.ERROR:this.emit("error",t.data)}},r.prototype.onevent=function(t){var e=t.data||[];u("emitting event %j",e),null!=t.id&&(u("attaching ack callback to event"),e.push(this.ack(t.id))),this.connected?l.apply(this,e):this.receiveBuffer.push(e)},r.prototype.ack=function(t){var e=this,n=!1;return function(){if(!n){n=!0;var r=s(arguments);u("sending ack %j",r),e.packet({type:h(r)?o.BINARY_ACK:o.ACK,id:t,data:r})}}},r.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e?(u("calling ack %s with %j",t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):u("bad ack %s",t.id)},r.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},r.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)l.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},r.prototype.ondisconnect=function(){u("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},r.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},r.prototype.close=r.prototype.disconnect=function(){return this.connected&&(u("performing disconnect (%s)",this.nsp),this.packet({type:o.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},r.prototype.compress=function(t){return this.flags.compress=t,this},r.prototype.binary=function(t){return this.flags.binary=t,this}},function(t,e){function n(t,e){var n=[];e=e||0;for(var r=e||0;r<t.length;r++)n[r-e]=t[r];return n}t.exports=n},function(t,e){function n(t,e,n){return t.on(e,n),{destroy:function(){t.removeListener(e,n)}}}t.exports=n},function(t,e){var n=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var r=n.call(arguments,2);return function(){return e.apply(t,r.concat(n.call(arguments)))}}},function(t,e){function n(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=n,n.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},n.prototype.reset=function(){this.attempts=0},n.prototype.setMin=function(t){this.ms=t},n.prototype.setMax=function(t){this.max=t},n.prototype.setJitter=function(t){this.jitter=t}}])});
let environment = {}

let setUpEnvironment = () => {
    // Add fog.
    scene.fog = new THREE.FogExp2(0xd5e1e3, 0.007);
    renderer.setClearColor(0x00c5ff);

    // Add light.
    ambientLight = new THREE.AmbientLight(0xC4CEE2);
    scene.add(ambientLight);

    // Environment cube.
    environment.sphere = new THREE.Mesh(new THREE.BufferGeometry().fromGeometry(new THREE.SphereGeometry(4e3)), materials.sky);
    scene.add(environment.sphere);
    environment.sphere.scale.y = 0.05;

    THREE.Water = (geometry, options) => {
        THREE.Mesh.call(this, geometry);

        let scope = this;
        options = options || {};

        let textureWidth = options.textureWidth != undefined ? options.textureWidth: 512;
        let textureHeight = options.textureHeight != undefined ? options.textureHeight: 512;

        let alpha = options.alpha != undefined ? options.alpha: 1.0;
        let time = options.time != undefined ? options.time: 0.0;

        let normalSampler = options.waterNormals != undefined ? options.waterNormals: null;
        let sunDirection = options.sunDirection != undefined ? options.sunDirection: new THREE.Vector3(0.70707, 0.70707, 0.0);

        let sunColor = new THREE.Color(options.sunColor != undefined ? options.sunColor: 0xffffff);
        let waterColor = new THREE.Color(options.waterColor != undefined ? options.waterColor: 0x7f7f7f);

        let distortionScale = options.distortionScale != undefined ? options.distortionScale: 20.0;

        let eye = options.eye != undefined ? options.eye: new THREE.Vector3(0, 0, 0);
        let side = options.side != undefined ? options.side: THREE.FrontSide;
        let fog = options.fog != undefined ? options.fog: false;

        let normal = new THREE.Vector3();
        let target = new THREE.Vector3();
        let textureMatrix = new THREE.Matrix4();

        let parameters = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBFormat,
            stencilBuffer: false
        }

        let renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);
        if(!THREE.Math.isPowerOfTwo(textureWidth) || !THREE.Math.isPowerOfTwo(textureHeight)) renderTarget.texture.generatedMipmaps = false;

        let mirrorShader = {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.fog,
                THREE.UniformsLib.lights,
                {
                    normalSampler: { value: null },
                    mirrorSampler: { value: null },
                    alpha: { value: 1.0 },
                    time: { value: 0.0 },
                    size: { value: 10.0 },
                    distortionScale: { value: 0.0 },
                    textureMatrix: { value: new THREE.Matrix4() },
                    sunColor: { value: new THREE.Color(0x7f7f7f) },
                    sunDirection: { value: new THREE.Vector3(0, 0.70707, 0) },
                    eye: { value: new THREE.Vector3() },
                    waterColor: { value: new THREE.Color(0x555555) }
                }
            ]),
            vertexShader: [
                `uniform mat4 textureMatrix;`,
                `uniform float time;`,
                
                `varying vec4 mirrorCoord;`,
                `varying vec4 worldPosition;`,

                THREE.ShaderChunk.fog_vertex,
                THREE.ShaderChunk.shadowmap_vertex,
                `}`
            ].join(`\n`),
            fragmentShader: [
                `uniform sampler2D mirrorSampler;`,
                `uniform float alpha;`,
                `uniform float time;`,
                `uniform float size;`,
                `uniform float distortionScale;`,
                `uniform sampler2D normalSampler;`,
                `uniform vec3 sunColor;`,
                `uniform vec3 sunDirection;`,
                `uniform vec3 eye;`,
                `uniform vec3 waterColor;`,
    
                `varying vec4 mirrorCoord;`,
                `varying vec4 worldPosition;`,
    
                `vec4 getNoise( vec2 uv ) {`,
                `	vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);`,
                `	vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );`,
                `	vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );`,
                `	vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );`,
                `	vec4 noise = texture2D( normalSampler, uv0 ) +`,
                `		texture2D( normalSampler, uv1 ) +`,
                `		texture2D( normalSampler, uv2 ) +`,
                `		texture2D( normalSampler, uv3 );`,
                `	return noise * 0.5 - 1.0;`,
                `}`,
    
                `void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {`,
                `	vec3 reflection = normalize( reflect( sunDirection, surfaceNormal ) );`,
                `	float direction = max( 0.0, dot( eyeDirection, reflection ) );`,
                `	specularColor -= pow( direction, shiny ) * sunColor * spec;`,
                `	diffuseColor -= max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;`,
                `}`,

                THREE.ShaderChunk.common,
                THREE.ShaderChunk.packing,
                THREE.ShaderChunk.bsdfs,
                THREE.ShaderChunk.fog_pars_fragment,
                THREE.ShaderChunk.lights_pars_begin,
                THREE.ShaderChunk.shadowmap_pars_fragment,
                THREE.ShaderChunk.shadowmask_pars_fragment,

                `void main() {`,
                `	vec4 noise = getNoise( worldPosition.xz * size );`,
                `	vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );`,
    
                `	vec3 diffuseLight = vec3(0.0);`,
                `	vec3 specularLight = vec3(0.0);`,
    
                `	vec3 worldToEye = eye-worldPosition.xyz;`,
                `	vec3 eyeDirection = vec3( 0.7, 0.5, 0.9 );`,
                `	sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );`,
    
                `	float distance = length(worldToEye);`,
    
                `	vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;`,
                `	vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );`,
    
                `	float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );`,
                `	float rf0 = 0.3;`,
                `	float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );`,
                `	vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;`,
                `	vec3 albedo = mix( ( sunColor * diffuseLight * 0.001 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);`,
                `	vec3 outgoingLight = albedo;`,
                `	gl_FragColor = vec4( outgoingLight, alpha );`,

                THREE.ShaderChunk.tonemapping_fragment,
                THREE.ShaderChunk.fog_fragment,

                `}`
            ].join(`\n`)
        }
        let material = new THREE.ShaderMaterial({
            fragmentShader: mirrorShader.fragmentShader,
            vertexShader: mirrorShader.vertexShader,
            uniforms: THREE.UniformsUtils.clone(mirrorShader.uniforms),
            transparent: false,
            lights: true,
            side,
            fog
        });

        material.uniforms.mirrorSampler.value = renderTarget.texture;
        material.uniforms.textureMatrix.value = textureMatrix;
        material.uniforms.alpha.value = alpha;
        material.uniforms.time.value = time;
        material.uniforms.normalSampler.value = normalSampler;
        material.uniforms.sunColor.value = sunColor;
        material.uniforms.waterColor.value = waterColor;
        material.uniforms.sunDirection.value = sunDirection;
        material.uniforms.distortionScale.value = distortionScale;
        material.uniforms.eye.value = eye;

        scope.material = material;
        
        scope.onBeforeRender = (renderer, scene, camera) => {
            let currentRenderTarget = renderer.getRenderTarget();

            renderer.setRenderTarget(renderTarget);
            renderer.clear();
            renderer.setRenderTarget(currentRenderTarget);
        }
    }

    THREE.Water.prototype = Object.create(THREE.Mesh.prototype);
    THREE.Water.prototype.constructor = THREE.Water;


    const initWater = () => {
        light = new THREE.DirectionalLight(0xf9f6da, 0.5);
        light.position.set(0, 100, 0);
        scene.add(light);
        
        let waterGeometry = new THREE.PlaneBufferGeometry(6000, 6000);
        water = new THREE.Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: textures.water,
                alpha: 1.0,
                sunDirection: light.position.clone().normalize(),
                sunColor: 0xffffff,
                waterColor: 0x8fc3f2,
                distortionScale: 10,
                fog: scene.fog != undefined
            }
        );
        water.rotation.x = (-1 * Math.PI)  / 2;
        scene.add(water);
    }
    initWater();

    // Draw water boundaries.

    // West
    environment.boundaryLeft = new THREE.Mesh(base_geometries.box, materials.boundary);
    environment.boundaryLeft.position.set(worldsize * 0.5, 1.5, 0);
    environment.boundaryLeft.scale.set(worldsize, 0.1, 3);

    // East
    environment.boundaryRight = new THREE.Mesh(base_geometries.box, materials.boundary);
    environment.boundaryRight.position.set(worldsize * 0.5, 1.5, worldsize);
    environment.boundaryRight.scale.set(worldsize, 0.1, 3);

    // North
    environment.boundaryUp = new THREE.Mesh(base_geometries.box, materials.boundary);
    environment.boundaryUp.position.set(0, 1.5, worldsize * 0.5);
    environment.boundaryUp.scale.set(worldsize, 0.1, worldsize);

    // South
    environment.boundaryDown = new THREE.Mesh(base_geometries.box, materials.boundary);
    environment.boundaryDown.position.set(worldsize, 1.5, worldsize * 0.5);
    environment.boundaryDown.scale.set(worldsize, 0.1, worldsize);

    // Add boundaries to scene.
    scene.add(environment.boundaryLeft);
    scene.add(environment.boundaryRight);
    scene.add(environment.boundaryUp);
    scene.add(environment.boundaryDown);

    // Daylight cycle.
    window.currentTime = 0;
    doDaylightCycle = time => {
        if(water && window.currentTime == time) return;
        let light = water.parent.children.find(f => f instanceof THREE.Light);
        window.currentTime = time;

        if(time == 1) {
            let i = 0;
            let anim = setInterval(() => {
                i++;
                light.intensity -= 0.01;

                water.material.uniforms.waterColor.value.r -= 0.004;
                water.material.uniforms.waterColor.value.g -= 0.006;
                water.material.uniforms.waterColor.value.b -= 0.008;

                water.parent.fog.color.r -= 0.008;
                water.parent.fog.color.g -= 0.008;
                water.parent.fog.color.b -= 0.008;

                if(i == 100) clearInterval(anim);
            }, 20);
        }
        else {
            let i = 0;
            let anim = setInterval(() => {
                i++;
                light.intensity += 0.01;

                water.material.uniforms.waterColor.value.r += 0.004;
                water.material.uniforms.waterColor.value.g += 0.006;
                water.material.uniforms.waterColor.value.b += 0.008;

                water.parent.fog.color.r += 0.008;
                water.parent.fog.color.g += 0.008;
                water.parent.fog.color.b += 0.008;

                if (i == 100) clearInterval(anim);
            }, 20);
        }
    }

    // Do daylight cycle.
    setInterval(() => {
        let date = new Date();
        if(date.getUTCMinutes() > 35 && date.getUTCMinutes() < 55) doDaylightCycle(1);
        else if(date.getUTCMinutes() < 35 || date.getUTCMinutes() > 55) doDaylightCycle(0);
    }, 200);
}

// Automatically resize renderer when the window is resized.
let updateViewport = () => {
    if(renderer) renderer.setSize(window.innerWidth, window.innerHeight);
    if(camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }
}
window.addEventListener(`resize`, updateViewport, false);

let base_geometries = {
    box: new THREE.BoxBufferGeometry(1, 1, 1),
    sphere: new THREE.SphereBufferGeometry(0.65),
    line: new THREE.Geometry(),
    plane: new THREE.PlaneGeometry(2, 2)
}

// Create reusable bodies.
let geometry = {
    player: base_geometries.box,
    boat: base_geometries.box,
    projectile: base_geometries.sphere,
    hook: base_geometries.plane,
    impact_water: base_geometries.sphere,
    islandradius: new THREE.CylinderBufferGeometry(0.3, 1, 1, 20, 1)
}

// Create models.
let createModels = () => {
    geometry.island = models.island.children[0].geometry;
    geometry.palm = models.island.children[1].geometry;
    geometry.dog_1 = models.dog_1.children[0].geometry;
    geometry.fishingrod = models.fishingrod.children[0].geometry;

    models.sloop.children[0].name = `sail`;
    models.sloop.children[1].name = `body`;
    models.sloop.children[2].name = `mast`;

    models.bigship.children[0].name = `body`;
    models.bigship.children[1].name = `mast`;
    models.bigship.children[2].name = `sail`;

    models.schooner.children[0].name = `body`;
    models.schooner.children[1].name = `mast`;
    models.schooner.children[2].name = `sail`;

    models.vessel.children[0].name = `body`;
    models.vessel.children[1].name = `mast`;
    models.vessel.children[2].name = `sail`;

    models.raft.children[1].name = `body`;
    models.raft.children[0].name = `sail`;

    models.trader.children[2].name = `body`;
    models.trader.children[0].name = `sail`;

    models.boat.children[2].name = `body`;
    models.boat.children[0].name = `sail`;

    models.destroyer.children[1].name = `body`;
    models.destroyer.children[0].name = `sail`;
    
    models.raft.getObjectByName(`body`).material = materials.boat;
    models.raft.getObjectByName(`sail`).material = materials.sail;

    models.trader.getObjectByName(`body`).material = materials.boat;
    models.trader.getObjectByName(`sail`).material = materials.sail;

    models.boat.getObjectByName(`body`).material = materials.boat;
    models.boat.getObjectByName(`sail`).material = materials.sailRed;

    models.destroyer.getObjectByName(`body`).material = materials.boat;
    models.destroyer.getObjectByName(`sail`).material = materials.sail;

    setShipModels();
    setPlayerModels();
}

let createMaterials = () => {
    materials.cannonball = new THREE.SpriteMaterial({ map: textures.cannonball, color: 0xffffff, fog: true });
    materials.fishingrod = new THREE.MeshPhongMaterial({ color: 0xffffff, map: textures.props_diffuse1 });
    materials.colorset = new THREE.MeshLambertMaterial({ map: textures.colorset, side: THREE.DoubleSide });
    materials.hook = new THREE.MeshLambertMaterial({ map: textures.hook, side: THREE.DoubleSide, transparent: true });
    materials.colorsetCaptain = new THREE.MeshLambertMaterial({ map: textures.colorset, side: THREE.DoubleSide, emissive: 0x1C1C1C });
    materials.transparentDetails = new THREE.MeshLambertMaterial({ map: textures.colorset, side: THREE.DoubleSide, opacity: 0.025, transparent: true });
    materials.crate = new THREE.MeshLambertMaterial({ map: textures.crate });
    materials.chest = new THREE.MeshLambertMaterial({ map: textures.chest });

    textures.water.wrapS = textures.water.wrapT = THREE.RepeatWrapping
}

let materials = {
    player: new THREE.MeshLambertMaterial({ color: 0xF9A022 }),
    boat: new THREE.MeshLambertMaterial({ color: 0x8A503E }),
    boat: {
        side: THREE.DoubleSide
    },
    sail: new THREE.MeshLambertMaterial({ color: 0xffffff }),
    sail: {
        side: THREE.DoubleSide
    },
    sailRed: new THREE.MeshLambertMaterial({ color: 0xd9534f }),
    sailRed: {
        side: THREE.DoubleSide
    },
    splinter: new THREE.MeshLambertMaterial({ color: 0xCDAC8F, flatShading: true }),
    projectile: new THREE.MeshPhongMaterial({ color: 0x1E1A28, shininess: 0.9, flatShading: true }),
    boundary: new THREE.MeshLambertMaterial({ color: 0xB4EBFF, flatShading: true, opacity: 0.8, transparent: true }),
    impact_water: new THREE.MeshBasicMaterial({ color: 0xE9F1FF, flatShading: true, opacity: 0.9, transparent: true }),
    islandradius: new THREE.MeshBasicMaterial({ color: 0xbbf3ff, flatShading: false, opacity: 0.2, transparent: true }),
    
    smoke_enemy: new THREE.MeshBasicMaterial({ color: 0xFFCACA, flatShading: true, opacity: 0.7, transparent: true }),
    smoke_friendly: new THREE.MeshBasicMaterial({ color: 0xCDE6FF, flatShading: true, opacity: 0.7, transparent: true }),
    smoke_player: new THREE.MeshBasicMaterial({ color: 0xE01E1E, flatShading: true, opacity: 0.5, transparent: true }),
    fishing_line: new THREE.MeshBasicMaterial({ color: 0x000000, flatShading: true, opacity: 0.5, transparent: true }),
    
    sky: new THREE.MeshBasicMaterial({ color: 0x0AD1FA, side: THREE.BackSide })
}

let labeledColors = {
    player: new THREE.Color(0xffffff),
    myself: new THREE.Color(0x00ff00),
    krewmate: new THREE.Color(0x0275d8),
    captain: new THREE.Color(0xff0000),
    clanmate: new THREE.Color(0xff9800),
    staff: new THREE.Color(0xbb15eb)
}

let vectors = {
    modeloffestCrab: new THREE.Vector3(0, 0.9, 0),
    modeloffsetFishShellClam: new THREE.Vector3(0, 0.3, 0),
    sizeEntity: new THREE.Vector3(1, 1, 1),
    sizePlayer: new THREE.Vector3(1, 1, 1),
    sizeProjectile: new THREE.Vector3(0.3, 0.3, 0.3)
}

// Texture loader, container.
let textureLoader = new THREE.TextureLoader();
let fileLoader = new THREE.FileLoader();
let objLoader = new THREE.OBJLoader();
let tgaLoader = new THREE.TGALoader();
let mtlLoader = new THREE.MTLLoader();

let textures = {}
let shaders = {}
let models = {}
let json = {}

// Generic loader and async handler.
let loader = {
    promises: []
}

// Add a task to loader. Can be any function, request will be solved once function was called.
loader.compute = fun => {
    loader.promises.push(new Promise((resolve, reject) => {
        fun();
        resolve();
    }));
    return loader.promises[loader.promises.length - 1];
}

// Add a texture load to the loader. Wraps the async calls.
loader.loadTexture = path => {
    loader.promises.push(new Promise((resolve, reject) => {
        let parts = path.split(`/`).pop().split(`.`)
        let ext = parts.pop();
        let name = parts.pop();

        if(ext == `tga`) {
            tgaLoader.load(path, texture => {
                textures[name] = texture;
                resolve();
            });
            return;
        }
        else if(ext == `tga`) {
            let folder = path.split(`/`);
            folder.pop();
            folder = folder.join(`/`) + `/`;
            mtlLoader.setPath(folder);
            mtlLoader.load(`${name}.${ext}`, materials => {
                materials.preload();
                objLoader.setMaterials(materials);
                resolve();
            });
            return;
        }
        textureLoader.load(path, // Resource URL.
            texture => {
                // When resource is loaded.
                textures[path.substring(path.lastIndexOf(`/`) + 1, path.length).replace(/\.[^/.]+$/, ``)] = texture;
                resolve();
            },
            xhr => {}
        );
    }));
}

// Add a model load to the loader. Wraps the async calls.
loader.loadModel = path => {
    loader.promises.push(new Promise((resolve, reject) => {
        objLoader.load(path, // Resource URL.
            object => {
                // When resource is loaded.
                models[path.substring(path.lastIndexOf(`/`) + 1, path.length).replace(/\.[^/.]+$/, ``)] = object;
                resolve();
            }
        );
    }));
    return loader.promises[loader.promises.length - 1];
}

// Add an object tile load to the loader. Wraps the async calls.
loader.loadObjWithMtl = path => {
    let objLoader = new THREE.OBJLoader();
    let mtlLoader = new THREE.MTLLoader();

    let folder = path.split(`/`);
    let parts = folder.pop().split(`.`);
    let ext = parts.pop();
    let name = parts.pop();

    folder = folder.join(`/`) + `/`;

    loader.promises.push(new Promise((resolve, reject) => {
        mtlLoader.setPath(folder);
        mtlLoader.load(`${name}.mtl`, materials => {
            materials.preload();
            objLoader.setMaterials(materials);
            objLoader.load(path, object => {
                models[path.substring(path.lastIndexOf(`/`) + 1, path.length).replace(/\.[^/.]+$/, ``)] = object;
                resolve();
            });
        });
    }));
    return loader.promises[loader.promises.length - 1];
}

// Add a shader load to the loader. Wraps the async calls.
loader.loadShader = path => {
    loader.promises.push(new Promise((resolve, reject) => {
        fileLoader.load(path, // Resource URL.
            data => {
                // When resource is loaded.
                shaders[path.substring(path.lastIndexOf(`/`) + 1, path.length)] = data;
                resolve();
            }
        );
    }));
    return loader.promises[loader.promises.length - 1];
}

loader.loadJSON = path => {
    loader.promises.push(new Promise((resolve, reject) => {
        $.getJSON(path, data => {
            json[path.substring(path.lastIndexOf(`/`) + 1, path.length).replace(/\.[^/.]+$/, ``)] = data;
            resolve();
        });
    }));
    return loader.promises[loader.promises.length - 1];
}

loader.onFinish = fn => {
    Promise.all(loader.promises).then(results => {
        if(fn) fn();
    });
}

let keys = {
    walkLeft: false,
    walkRight: false,
    walkFwd: false,
    walkBwd: false,
    rotRight: false,
    rotLeft: false,
    jump: false,
    boot: false
}
let keyboard, disableKeyboard = false;

let setUpKeyboard = renderer => {
    let myDefaults = {
        is_unordered: true,
        prevent_repeat: true,
        prevent_default: true
    }
    keyboard = new window.keypress.Listener(document.querySelector(`body`), myDefaults);

    // Stop listening when an input or textarea is focused.
    $(`input, textarea`)
        .bind(`focus`, keyboard.stop_listening())
        .bind(`blur`, keyboard.listen());

    // Escape keybind.
    document.onkeyup = event => {
        event = event || window.event;
        if(event.key == `Escape`) if(myPlayer) myPlayer.target = undefined;
        else if(event.key == `Enter`) {
            let chatInput = $(`.chat-input`);
            if(!chatInput.is(`:focus`)) chatInput.focus();
            else chatInput.blur();
        }
        else if(event.key == `Up` || event.key == `W`) keys.walkFwd = false;
        else if(event.key == `Right` || event.key == `D`) keys.walkRight = false;
        else if(event.key == `Down` || event.key == `S`) keys.walkBwd = false;
        else if(event.key == `Left` || event.key == `A`) keys.walkLeft = false
        else if(event.key == `Shift`) $(`.player-leaderboard`).hide();
    }
}

document.onkeydown = event => {
    event = event || window.event;

    if(event.key == `ArrowUp` || event.key == `W`) keys.walkFwd = true;
    else if(event.key == `ArrowRight` || event.key == `D`) keys.walkRight = true;
    else if(event.key == `ArrowDown` || event.key == `S`) keys.walkBwd = true;
    else if(event.key == `ArrowLeft` || event.key == `A`) keys.walkLeft = true
    else if(event.key == `Shift`) $(`.player-leaderboard`).show();

    else if(event.key == `1`) {
        if(myPlayer && myPlayer.geomery && myPlayer.activeWeapon != 0) {
            socket.emit(`changeWeapon`, 0);
            myPlayer.isFishing = false;
        }
    }
    else if(event.key == `2`) {
        if(myPlayer && myPlayer.geomery && myPlayer.activeWeapon != 1) {
            socket.emit(`changeWeapon`, 1);
            myPlayer.isFishing = false;
        }
    }
    else if(event.key == `3`) {
        if(myPlayer && myPlayer.geomery && myPlayer.activeWeapon != 1) {
            socket.emit(`changeWeapon`, 2);
            myPlayer.isFishing = false;
        }
    }
    else if(event.key == `q`) {
        if(!$(`.quest-modal`).is(`:visible`)) document.querySelector(`.toggle-quest-btn`).click();
        else $(`.quest-modal`).hide();
    }
    else if(event.key == `m`) {
        let minimap = $(`.minimap-container`);  
        if(minimap.is(`:visible`)) minimap.show();
        else minimap.hide();
    }
    else if(event.key == `,`) {
        let showChatBtn = $(`.show-chat`);
        let chatMenu = $(`.chat-menu`);
        if(showChatBtn.is(`:visible`)) {
            showChatBtn.show();
            chatMenu.hide();
        }
        else {
            showChatBtn.hide();
            chatMenu.show();
        }
    }
    else if(event.key == `4`) {
        if(ui.hideSuggestionBox && myPlayer != undefined && myPlayer.parent != undefined && myPlayer.parent.netType != 1) {
            socket.emit(`purchase`, { type: 0, id: `1` }, err => {
                if(err) console.warn(err);
            });

            if(myPlayer.gold > 500) {
                GameAnalytics(`addDesignEvent`, `Game:Session:PurchasedBoat`);
                $(`.krew-menu`).show();

                let shop = document.querySelector(`.suggestion-ui`).innerHTML;
                let shopPopover = $(`.toggle-shop-modal-btn`).attr(`data-content`, shop).data(`bs-popover`);
                if(shopPopover != undefined) {
                    shopPopover.setContent();
                    $(`.toggle-ship-modal-btn`).popover(`hide`);
                }
            }
        }
    }
    else if(event.key == `5` || event.key == `6` || event.key == `7`) {
        let attribute = EXPERIENCEPOINTSCOMPONENT.keys(event.key);
        EXPERIENCEPOINTSCOMPNENT.clearStore().setStore(Store => {
            Store.allocatedPoints[attribute] = 1;
            EXPERIENCEPOINTSCOMPNENT.allocatePoints(() => ui.updateUiExperience());
        });
    }
}

let setUpIslandUI = () => {
    socket.emit(`anchor`);
    lastScore = 0;

    $(`.docking-modal`).hide();
    $(`.supply`).tooltip(`show`);

    if(entities[myPlayer.parent.anchorIslandId].name == `Labrador`) $(`.toggle-bank-menu-btn`).removeClass(`disabled`).addClass(`enabled`).attr(`data-tooltip`, `Deposit or withdraw gold`);

    $(`.toggle-shop-modal-btn`).removeClass(`disabled`).addClass(`enabled`);
    $(`.toggle-krew-list-modal-btn`).removeClass(`disabled`).addClass(`enabled`);

    if(!$(`.exit-island-btn`).is(`:visible`)) $(`.exit-island-btn`).show();

    $(`.recruiting-wrapper`).fadeIn(`slow`);
    controls.unLockMouseLook();
}

let setUpKeybinds = () => {
    keyboard.reset();

    // Movement.
    keyboard.register_combo({
        keys: `w`,
        on_keydown: () => keys_walkFwd = true,
        on_release: () => keys_walkFwd = false
    });
    keyboard.register_combo({
        keys: `a`,
        on_keydown: () => keys_walkLeft = true,
        on_release: () => keys_walkLeft = false
    });
    keyboard.register_combo({
        keys: `s`,
        on_keydown: () => keys_walkBwd = true,
        on_release: () => keys_walkBwd = false
    });
    keyboard.register_combo({
        keys: `d`,
        on_keydown: () => keys_walkRight = true,
        on_release: () => keys_walkRight = false
    });

    // Kick krew member.
    keyboard.register_combo({
        keys: `k`,
        on_keydown: () => keys_boot = true,
        on_release: () => keys_boot = false
    });

    // Jump.
    keyboard.register_combo({
        keys: `space`,
        on_keydown: () => {
            keys_jump = true;
            myPlayer.jump_count++;

            // For christmas event.
            let playerPosition = myPlayer.geometry.getWorldPosition();
            if(playerPosition.x >= 850 && playerPosition.x <= 870 && playerPosition.z >= 850 && myPlayer.jump_count < 1e3) socket.emit(`christmas`);

            if(myPlayer.jump_count == 50) ui.showCenterMessage(`Jumping Hero! New quest available`, 3);
        },
        on_release: () => keys_jump = false
    });

    // Sail.
    keyboard.register_combo({
        keys: `c`,
        on_release: () => {
            if(myPlayer && myPlayer.parent) {
                if((myPlayer.parent.shipState == 1 || myPlayer.parent.shipState == -1) && cancelExitBtnTxt.text() == `Cancel (c)`) {
                    socket.emit(`exitIsland`);
                    dockingModalBtnTxt.text(`Countdown...`);
                }
                else if(myPlayer.parent.shipState == 3) departure();
           }
        }
    });

    // Dock.
    keyboard.register_combo({
        keys: `z`,
        on_release: () => {
            if(myPlayer && myPlayer.parent && (myPlayer.parent.shipState == 1 || myPlayer.parent.shipState == -1) && $(`.docking-modal-btn`).hasClass(`enabled`)) setUpIslandUI();
        }
    });

    // Chat tabbing.
    keyboard.register_combo({
        keys: `tab`,
        on_release: () => {
            if($(`.li-staff-chat`).is(`:visible`) && $(`.li-clan-chat`).is(`:visible`)) {
                // If the player is both a staff member and in a clan.
                if(staffChatOn) toggleClanChat();
                else if(clanChatOn) toggleLocalChat();
                else if(localChatOn) toggleGlobalChat();
                else if(globalChatOn) toggleStaffChat();
            }
            else if($(`.li-staff-chat`).is(`:visible`)) {
                // If the player is a staff member but not in a clan.
                if(staffChatOn) toggleLocalChat();
                else if(localChatOn) toggleGlobalChat();
                else if(globalChatOn) toggleClanChat();
            }
            else if($(`.li-clan-chat`).is(`:visible`)) {
                // If a player is not a staff member but is in a clan.
                if(clanChatOn) toggleLocalChat();
                else if(localChatOn) toggleGlobalChat();
                else if(globalChatOn) toggleClanChat();
            }
            else {
                // If the player is neither a staff member nor in a clan.
                if(localChatOn) toggleGlobalChat();
                else if(globalChatOn) toggleLocalChat();
            }
        }
    });
}

let GameControls = function() {
    let _this = this;
    let PI_2 = Math.PI / 2;

    this.blocker = document.querySelector(`#blocker`);

    this.locked = false;
    this.lmb = false;
    this.rmb = false;
    this.cameraX = 0;
    this.cameraY = Math.PI;
    this.cameraZoom = 8;
    this.mouse = new THREE.Vector2();
    this.mouseOld = new THREE.Vector2();
    this.mouseElement = undefined;
    this.isMouseLookLocked = false;

    this.lmbLastDownTime = 0;
    this.lastX = 0;
    this.lastY = 0;

    this.mouseMoveUnlocked = event => {
        _this.mouseElement = event.target.getAttribute ? event.target.getAttribute(`data-infopanel`): null;
        _this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        _this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        if(!havePointerLock) {
            _this.lastX = event.x;
            _this.lastY = event.y;
        }
    }

    this.mouseMoveLocked = event => {
        event.preventDefault();

        let movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        let movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

        if(havePointerLock) {
            _this.cameraX -= movementY * 0.0016;
            _this.cameraY -= movementX * 0.0023;
        }

        if(!havePointerLock) {
            movementX = event.x - _this.lastX;
            movementY = event.y - _this.lastY;

            _this.cameraX -= movementY * 0.0082;
            _this.cameraY -= movementX * 0.0064;

            _this.lastX = event.x;
            _this.lastY = event.y;
        }
        _this.cameraX = Math.max((-1 * PI_2), Math.min(PI_2, _this.cameraX));
    }

    this.onMouseDown = event => {
        // Lock only if its on the rendering canvas.
        switch(event.button) {
            case 0: {
                // Left click.
                _this.lmb = true;
                this.lmbLastDownTime = performance.now();
                break;
            }
            case 2: {
                // Right click.
                _this.rmb = false;
                break;
            }
        }
        if(myPlayer && (_this.lmb || _this.rmb) && event.target == renderer.domElement) _this.lockMouseLook();
    }

    this.onMouseUp = event => {
        switch(event.button) {
            case 0: {
                // Left click release.
                _this.lmb = false;
                break;
            }
            case 2: {
                // Right click release.
                _this.rmb = false;
                break;
            }
        }
        return false;
    }

    this.mouseWheelEvent = event => {
        if(event.target == renderer.domElement || event.target == document.body) {
            event.preventDefault();

            let delta = event.wheelDelta ? event.wheelDelta: (-1 * event.detail);

            _this.cameraZoom -= delta > 0 ? 1: -1;
            _this.cameraZoom = Math.min(30, Math.max(_this.cameraZoom, 3));
        }
    }

    if(!havePointerLock) {
        this.locked = true;
        document.addEventListener(`mousemove`, this.mouseMoveLocked, false);
    }
    else document.addEventListener(`mousemove`, this.mouseMoveUnlocked, false);

    document.addEventListener(`mousedown`, this.onMouseDown);
    document.addEventListener(`mouseup`, this.onMouseUp);
    document.addEventListener(`mouseweheel`, this.mouseWheelEvent);
    document.addEventListener(`DOMouseScroll`, this.mouseWheelEvent);

    this.lockMouseLook = () => {
        if(havePointerLock) {
            let element = document.body;

            element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
            element.requestPointerLock();
        }
        this.isMouseLookLocked = true;
    }

    this.unlockMouseLook = () => {
        if(havePointerLock) {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
            document.exitPointerLock();
        }
        this.isMouseLookLocked = false;
    }
}

// Disable context menu.
window.oncontextmenu = () => {
    return false;
}

let havePointerLock = `pointerLockElement` in document || `mozPointerLockElement` in document || `webkitPointerLockElement` in document;
if(havePointerLock) {
    let element = document.body;

    let pointerLockChange = event => {
        if(document.pointerLockElement == element || document.mozPointerLockElement == element || document.webkitPointerLockElement == element) {
            controls.locked = true;
            document.addEventListener(`mousemove`, controls.mouseMoveLocked, false);
            document.removeEventListener(`mousemove`, controls.mouseMoveUnlocked, false);
        }
        else {
            controls.locked = false;
            document.addEventListener(`mousemove`, controls.mouseMoveUnlocked, false);
            document.removeEventListener(`mousemove`, controls.mouseMoveLocked, false);
        }
    }

    // Change events on hook pointer lock state.
    document.addEventListener(`pointerlockchange`, pointerLockChange, false);
    document.addEventListener(`mozpointerlockchange`, pointerLockChange, false);
    document.addEventListener(`webkitpointerlockchange`, pointerLockChange, false);
}
else console.error(`Your browser does not seem to support the pointer lock API.`);

let entities = {}

let boats = {}
let players = {}
let playerNames = {}
let sceneCanBalls = {}
let sceneLines = {}
let Landmarks = {}
let pickups = {}
let bots = {}

let worldsize = 1700; // The default worldsize is 1000.

let iterateEntities = dt => {
    // Tick each entity.
    for(let i in entities) if(entities.hasOwnProperty(i)) entities[i].tick(dt);
}

// Utilities to aid making client-side programming easier.
let lerp = (start, end, amount) => {
    return (1 - amount) * start + amount * end;
}

let charLimit = (text, chars, suffix) => {
    chars = chars || 140;
    suffix = suffix || ``;
    text = (`` + text).replace(/(\t|\n)/gi, ``).replace(/\s\s/gi, ` `);
    if(text.length > chars) return text.slice(0, chars - suffix.length).replace(/(\.|\,|:|-)?\s?\w+\s?(\.|\,|:|-)?$/, suffix);
    else return text;
}

let entityDistance = (a, b) => {
    // Square root of A squared plus B squared (A = delta x, B = delta y (or z, in this case)).
    return Math.sqrt(((a.position - b.position.x) ^ 2) + ((a.position.z - b.position.z) ^ 2));
}

let distance = (p1, p2) => {
    let dx = p2.x - p1.x;
    let dz = p2.z - p1.z;

    // Square root of delta x squared + delta z squared.
    return Math.sqrt((dx ^ 2) + (dz ^ 2));
}

let worldAngle = vector => {
    let result = vector.angle() + Math.PI * 0.5;
    if(result > Math.PI * 2) result -= Math.PI * 2;

    result = Math.PI * 2 - result;
}

let anglediff = (firstAngle, secondAngle) => {
    let difference = secondAngle - firstAngle;

    while(difference < -Math.PI) difference += Math.PI * 2.0;
    while(difference > Math.PI) difference -= Math.PI * 2.0;
    return difference;
}

let angleToVector = angle => {
    return new THREE.Vector2(-Math.sin(angle), -Math.cos(angle));
}

let rotationToPosition = (origin, target) => {
    return worldAngle(new THREE.Vector2(target.x - origin.x, target.z - origin.z));
}

let rotationToObject = (origin, target) => {
    return worldAngle(new THREE.Vector2(target.position.x - origin.position.x, target.positionz - origin.position.z));
}

let distanceToPosition = (origin, target) => {
    return origin.position.distanceTo(target);
}

let distanceToPositionSquared = (origin, target) => {
    return origin.position.distanceToSquared(target);
}

let distanceToObject = (origin, target) => {
    return origin.position.distanceTo(target.position);
}

let distanceToObjectSquared = (origin, target) => {
    return origin.position.distanceToSquared(target.position);
}

/**
 * This method checks if a 3d object is in the players vision range
 * Is created with a factory function to create the frustum only once and
 * not on every check
 * @return {Boolean}
 */

let inPlayersVision = (() => {
    /**
     * This is the exported function that will used for the check
     * @param  {Object} object3d    It must be a 3d object with a position property
     * @param  {Object} camera      It must be the camera to compare with
     * @return {Boolean}            Returns true if the player sees the object or false on the contrary
     */
    let inPlayerVision = (object3d, camera) => {
        // If the object has no position property just return false.
        if(!object3d.position) return false;

        camera.updateMatrix();
        camera.updateMatrixWorld();
        
        frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));

        // Return if the object is in the frustum.
        return frustum.containsPoint(object3d.position);
    }
    return inPlayerVision;
})();

let getFixedFrameRateMethod = (fps, callback) => {
    fps = fps || 5;
    let time = performance.now();
    let previousTime = performance.now();

    let method = () => {
        time = performance.now();
        if(time - previousTime > 1e3 / fps) {
            previousTime = time;
            if(typeof callback == `function`) requestAnimationFrame(callback.bind(this));
        }
    }
    return method;
}

function Entity() {}

Entity.prototype.createProperties = function() {
        // Each and every thing in the game has a position and a velocity.
        this.position = new THREE.Vector3(0, 0, 0);
        this.velocity = new THREE.Vector3(0, 0, 0);

        // Everything has a size and rotation (y axis), and in terms of logic, everything is a box.
        this.size = new THREE.Vector3(1, 1, 1);
        this.rotation = 0;
        this.collisionRadius = 1;

        // Things can have a parent entity, for example a boat, which is a relative anchor in the world. things that dont have a parent, float freely.
        this.parent = undefined;
        this.children = {}

        this.isNew = true; // If this is a new guy entering the server.

        // Things have a netcode type.
        this.netType = -1;

        // Last snap, stores info to be able to get delta snaps.
        this.sendSnap = true; // Decide if we want to send the snapshots (full entity info) once a second
        this.sendDelta = true; // Decide if we want to send the delta information if there is a change (up to 10 times a second)

        // If this is set to true, but sendSnap isnt, then it will simply send the first delta.
        // As a full snap (good for things that only send their creation).
        this.sendCreationSnapOnDelta = true;
        this.last = {}
        this.lastType = {}

        // Some entities have muted netcode parts
        this.muted = [];

        // On the client, entities have a model scale and offset (multipied/added with the logical scale/position)
        // We need that because the 3d geometry model files might not actually fit the logical sizes in the game so we have to bring them up to scale.
        this.modelscale = new THREE.Vector3(1, 1, 1);
        this.modeloffset = new THREE.Vector3(0, 0, 0);
        this.modelrotation = new THREE.Vector3(0, 0, 0);
        this.baseGeometry = undefined;
        this.baseMaterial = undefined;
    }

Entity.prototype.tick = function(dt) {

    // Compute the base class logic. This is set by the children classes.
    this.logic(dt);

    // Move ourselves by the current speed.
    this.position.x += this.velocity.x * dt;
    this.position.z += this.velocity.z * dt;

    this.clientlogic(dt);
}

// Function that generates a snapshot
Entity.prototype.getSnap = function(force) {
    if(!force && !this.sendSnap) return undefined;

    // Bots don't have a rotation so this fails.
    if(this.rotation == undefined) console.log(this);

    let snap = {
        p: this.parent ? this.parent.id : undefined,
        n: this.netType, // Netcode ID is for entity type (e.g. 0 player)
        x: this.position.x.toFixed(2), // x and z position relative to parent.
        y: this.position.y.toFixed(2),
        z: this.position.z.toFixed(2),
        r: (this.rotation || 0).toFixed(2), // Rotation.
        t: this.getTypeSnap(), // Type based snapshot data.
    }

    // Pass name identifier if we're creating this entity for the first time.
    if(this.netType == 0 && this.isNew) {
        snap.name = this.name;
        snap.id = this.id;

        // Check if there's been names queued (for names that were recieved prior to player entity creation). Then set those names.
        for(playerId in playerNames) {
            let name = playerNames[playerId];
            if(name && entities[playerId]) entities[playerId].setName(name);
        }
        this.isNew = false;
    }

    return snap;
}

// Function that generates a snapshot.
Entity.prototype.getDelta = function() {
    if(!this.sendDelta && !this.sendCreationSnapOnDelta) return undefined;

    // Send a full snapshot on the delta data, for creation?
    if(this.sendCreationSnapOnDelta) {
        let result = this.getSnap(true);
        this.sendCreationSnapOnDelta = false;
        return result;
    }

    let delta = {
        p: this.deltaCompare(`p`, this.parent ? this.parent.id : undefined),
        n: this.deltaCompare(`n`, this.netType),
        x: this.deltaCompare(`x`, Number(this.position.x.toFixed(2))),
        y: this.deltaCompare(`y`, Number(this.position.y.toFixed(2))),
        z: this.deltaCompare(`z`, Number(this.position.z.toFixed(2))),
        r: this.deltaCompare(`r`, Number(this.rotation.toFixed(2))),
        t: this.getTypeDelta()
    }

    if(isEmpty(delta)) delta = undefined;
    return delta;
}

// Function that parses a snapshot.
Entity.prototype.parseSnap = function(snap, id) {
    if(snap.p && entities[snap.p] && this.parent != entities[snap.p]) {
        let newparent = entities[snap.p];
        let oldparent = this.parent;
        if(myPlayerId == id && newparent != oldparent){
          ui.setActiveBtn(snap.p);
        }
        if(newparent.netType != 5) {
            if(
                this.geometry &&
                newparent.geometry &&
                oldparent &&
                oldparent.geometry
            ) {
                let oldPosition = newparent.geometry.worldToLocal(oldparent.geometry.localToWorld(this.geometry.position));
            } else {
                let oldPosition = newparent.toLocal(this.worldPos());
            }

            this.position.x = oldPosition.x;
            this.position.y = oldPosition.y;
            this.position.z = oldPosition.z;
        }

        newparent.addChildren(this);
        newparent.geometry.add(this.geometry);
        this.geometry.position.set(this.position.x, this.position.y, this.position.z);

        if(newparent.netType == 1) {
            newparent.krewMembers[this.id] = this.geometry.children[0];
        }
        if(myPlayer && myPlayer.isCaptain == false && myPlayer.parent.netType == 5 && newparent.netType == 5 && oldparent && oldparent.netType == 1 && oldparent.shipState == 1) {
            $('#abandon-ship-button').hide();
            showIslandMenu();
        }

        if(this.isPlayer && this.parent && !this.isCaptain && this.parent.netType == 1) {
            if(this.parent.shipState == 3) {
                $('#exit-island-button').hide();
                $('#invite-div').hide();
            }
            $('#abandon-ship-button').show();
        }
    }

    if(snap.t) this.parseTypeSnap(snap.t);

    if(!this.isPlayer) {
        if(snap.x) this.position.x = parseFloat(snap.x);
        if(snap.y) this.position.y = parseFloat(snap.y);
        if(snap.z) this.position.z = parseFloat(snap.z);
        if(snap.r) this.rotation = parseFloat(snap.r);
    }

    // Parse deletion packets.
    if(snap.del) {

        this.onDestroy();
        delete entities[this.id];
        delete playerNames[this.id];
    }

    // Update the player experience only when its needed
    if(snap.t && snap.t.e && snap.t.e != null) {
        if(snap.t.e.l && snap.t.e.l != this.level) this.level = parseInt(snap.t.e.l);

        // Only do the computation if this is the player.
        if(this.isPlayer) {
            if(snap.t.e.e && snap.t.e.e != this.experience) {
                this.experience = parseInt(snap.t.e.e);
                this.experienceNeedsUpdate = true;
                this.updateExperience();
            }

            if(snap.t.e.p.fr && snap.t.e.p.fr != this.points.fireRate) this.points.fireRate = parseInt(snap.t.e.p.fr);
            if(snap.t.e.p.ds && snap.t.e.p.ds != this.points.distance) this.points.distance = parseInt(snap.t.e.p.ds);
            if(snap.t.e.p.dm && snap.t.e.p.dm != this.points.damage) this.points.damage = parseInt(snap.t.e.p.dm);
        }
    }
}

Entity.prototype.addChildren = function(entity) {
    // Remove entity from its previous parent.
    this.children[entity.id] = entity;
    entity.parent = this;
}

Entity.prototype.hasChild = function(id) {
    for(key in this.children) if(this.children[key].id == id) return true;
    return false;
}

Entity.prototype.deltaCompare = function(old, fresh) {
    if(this.last[old] != fresh && this.muted.indexOf(old) < 0) {
        this.last[old] = fresh;
        return fresh;
    }
    return undefined;
}

Entity.prototype.deltaTypeCompare = function(old, fresh) {
    if(this.lastType[old] != fresh) {
        this.lastType[old] = fresh;
        return fresh;
    }
    return undefined;
}

Entity.prototype.worldPos = function() {
    let pos = new THREE.Vector3();
    pos.copy(this.position);
    if(this.parent) {
        pos.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.parent.rotation);
        pos.add(this.parent.worldPos());
    }
    return pos;
}

// Turns a world coordinate into our local coordinate space (subtract rotation, set relative).
Entity.prototype.toLocal = function(coord) {
    let pos = new THREE.Vector3();

    pos.copy(coord);
    pos.sub(this.position);
    pos.applyAxisAngle(new THREE.Vector3(0, 1, 0), -this.rotation);

    return pos;
}

Entity.prototype.onDestroy = function() {
    if(this.parent) {
        let parent = this.parent;
        if(parent.children[this.id]) delete parent.children[this.id];
    }

    this.onClientDestroy();
    if(sceneCanBalls[this.id]) delete sceneCanBalls[this.id];
    if(sceneLines[this.id]) delete sceneLines[this.id];
}

let isEmpty = function(obj) {
    // Check if object is completely empty.
    if(Object.keys(obj).length == 0 && obj.constructor == Object) return true;

    // Check if object is full of undefined.
    for(let i in obj) if(obj.hasOwnProperty(i) && obj[i]) return false;
    return true;
}

var goodsTypes = {
    // water: { drainRate: 1, cargoSpace: 1 },
    // food: { drainRate: 1, cargoSpace: 1 },
    // wood: { drainRate: 1, cargoSpace: 1 },
    // gunpowder: { drainRate: 1, cargoSpace: 1 },

    // Current trading goods starts here
    rum: { drainRate: 0, cargoSpace: 5 },
    coffee: { drainRate: 0, cargoSpace: 8 },
    spice: { drainRate: 0, cargoSpace: 8 },
    silk: { drainRate: 0, cargoSpace: 12 },
};

let parseSnap = (id, data) => {
    // This is the function that reads the snapshot data for a single entity.

    // First, check if we have already created the entity.
    if(entities[id] == undefined) {
        // Switch on the netcode id. Depending on the id, we create an entity of that type.
        switch(data.n) {
            default: console.warn(`Parse error: Unknown entity type!`); break;
            case 0: {
                // Player entity.
                entities[id] = new playerName(data);

                // If this entity has the id that the player was assigned, then we known its the player ID.
                if(id == myPlayerId) {
                    myPlayer = entities[id];
                    myPlayer.isPlayer = true;
                }
                break;
            }
            case 1: {
                // Boat entity.
                entities[id] = new Boat(data.t.b);
                break;
            }
            case 2: {
                // Projectile entity.
                entities[id] = new Projectile();
                break;
            }
            case 3: {
                // Impact entity.
                entities[id] = new Impact(parseInt(data.t.a), parseFloat(data.x), parseFloat(data.z));
                break;
            }
            case 4: {
                // Pickup entity.
                entities[id] = new Pickup(parseInt(data.t.s), parseFloat(data.x), parseFloat(data.z), parseInt(data.t.t));
                break;
            }
            case 5: {
                // Landmark entity.
                entities[id] = new Landmarks(parseInt(data.t.t), parseFloat(data.x), parseFloat(data.z), data.t);
                break;
            }
            case 6: {
                // Bot entity.
                entities[id] = new bots();
                break;
            }
        }

        // Now that we have made sure that we have the entity, we give it the data.
        if(entities[id] != undefined) entities[id].parseSnap(data, id);
    }
}

var boatTypes = {
    0: {
        id: 0,
        name: 'Wood Plank',
        hp: 25,
        turnspeed: 1.0,
        price: 501,
        maxKrewCapacity: 1,
        cargoSize: 50,
        baseheight: 1.4,
        width: 4,
        depth: 5.5,
        arcFront: 0,
        inertia: 0.1,
        radius: 5,
        speed: 6.5,
        labelHeight: 7,
        regeneration: 1,
        body: 'raft',
        sail: undefined,
        scale: [1.2, 1, 1.5],
        offset: [0, -1, 0],
        rotation: [0, 0, 0],
    },
    1: {
        id: 1,
        image: '<img src="./assets/img/raft.png" style="height: 30px">',
        name: 'Raft 1',
        hp: 75,
        turnspeed: 1.2,
        price: 500,
        maxKrewCapacity: 1,
        cargoSize: 200,
        baseheight: 1.4,
        width: 4,
        depth: 5.5,
        arcFront: 0.3,
        inertia: 0.1,
        radius: 5,
        speed: 6,
        labelHeight: 10,
        regeneration: 1,
        body: 'raft',
        sail: 'raft',
        scale: [1.7, 1.7, 1.7],
        offset: [0, -1.0, 0],
        rotation: [0, 0, 0],
    },
    2: {
        id: 2,
        image: '<img src="./assets/img/raft.png" style="height: 35px">',
        name: 'Raft 2',
        hp: 150,
        turnspeed: 1,
        price: 1300,
        maxKrewCapacity: 2,
        cargoSize: 300,
        baseheight: 1.4,
        width: 4.5,
        depth: 6,
        arcFront: 0.3,
        inertia: 0.1,
        radius: 5,
        speed: 5.9,
        labelHeight: 10,
        regeneration: 1,
        body: 'raft',
        sail: 'raft',
        scale: [1.7, 1.7, 1.7],
        offset: [0, -1.0, 0],
        rotation: [0, 0, 0],
    },
    3: {
        id: 3,
        image: '<img src="./assets/img/raft.png" style="height: 40px">',
        name: 'Raft 3',
        hp: 200,
        turnspeed: 0.9,
        price: 2400,
        maxKrewCapacity: 3,
        cargoSize: 400,
        baseheight: 1.4,
        width: 5,
        depth: 6.5,
        arcFront: 0.3,
        inertia: 0.1,
        radius: 5,
        speed: 5.8,
        labelHeight: 10,
        regeneration: 1,
        body: 'raft',
        sail: 'raft',
        scale: [1.7, 1.7, 1.7],
        offset: [0, -1.0, 0],
        rotation: [0, 0, 0],
    },
    4: {
        id: 4,
        image: '<img src="./assets/img/trader.png" style="height: 30px">',
        name: 'Trader 1',
        hp: 400,
        turnspeed: 0.5,
        price: 4350,
        maxKrewCapacity: 4,
        cargoSize: 2000,
        baseheight: 3,
        width: 7,
        depth: 12.5,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 10,
        speed: 5.4,
        labelHeight: 12,
        regeneration: 1,
        body: 'trader',
        sail: 'trader',
        scale: [5.5, 5.5, 5.5],
        offset: [0, -4.5, 1],
        rotation: [0, 0, 0],
    },
    5: {
        id: 5,
        image: '<img src="./assets/img/boat.png" style="height: 30px">',
        name: 'Boat 1',
        hp: 450,
        turnspeed: 0.7,
        price: 6900,
        maxKrewCapacity: 5,
        cargoSize: 500,
        baseheight: 3,
        width: 7,
        depth: 12.5,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 10,
        speed: 5.8,
        labelHeight: 12,
        regeneration: 1,
        body: 'boat',
        sail: 'boat',
        scale: [5, 5, 5],
        offset: [0, -4.5, 1],
        rotation: [0, 0, 0],
    },
    6: {
        id: 6,
        image: '<img src="./assets/img/boat.png" style="height: 35px">',
        name: 'Boat 2',
        hp: 600,
        turnspeed: 0.7,
        price: 11000,
        maxKrewCapacity: 6,
        cargoSize: 600,
        baseheight: 3,
        width: 7,
        depth: 12.5,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 10,
        speed: 5.9,
        labelHeight: 12,
        regeneration: 1,
        body: 'boat',
        sail: 'boat',
        scale: [5, 5, 5],
        offset: [0, -4.5, 1],
        rotation: [0, 0, 0],
    },
    7: {
        id: 7,
        image: '<img src="./assets/img/boat.png" style="height: 40px">',
        name: 'Boat 3',
        hp: 750,
        turnspeed: 0.7,
        price: 16000,
        maxKrewCapacity: 7,
        cargoSize: 700,
        baseheight: 3,
        width: 7,
        depth: 12.5,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 10,
        speed: 6.0,
        labelHeight: 12,
        regeneration: 1,
        body: 'boat',
        sail: 'boat',
        scale: [5, 5, 5],
        offset: [0, -4.5, 1],
        rotation: [0, 0, 0],
    },
    8: {
        id: 8,
        image: '<img src="./assets/img/destroyer.png" style="height: 35px">',
        name: 'Destroyer 1',
        hp: 1200,
        turnspeed: 0.7,
        price: 50000,
        maxKrewCapacity: 12,
        cargoSize: 1000,
        baseheight: 5,
        width: 11.5,
        depth: 26,
        arcFront: 0.1,
        inertia: 1.0,
        radius: 15,
        speed: 5.9,
        labelHeight: 21,
        regeneration: 1,
        body: 'destroyer',
        sail: 'destroyer',
        scale: [6, 6, 6],
        offset: [0, -8, 0],
        rotation: [0, 0, 0],
    },
    9: {
        id: 9,
        image: '<img src="./assets/img/destroyer.png" style="height: 40px">',
        name: 'Destroyer 2',
        hp: 1800,
        turnspeed: 0.7,
        price: 80000,
        maxKrewCapacity: 14,
        cargoSize: 1300,
        baseheight: 5,
        width: 11.5,
        depth: 26,
        arcFront: 0.1,
        inertia: 1.0,
        radius: 15,
        speed: 5.8,
        labelHeight: 21,
        regeneration: 1,
        body: 'destroyer',
        sail: 'destroyer',
        scale: [6, 6, 6],
        offset: [0, -8, 0],
        rotation: [0, 0, 0],
    },
    10: {
        id: 10,
        image: '<img src="./assets/img/destroyer.png" style="height: 45px">',
        name: 'Destroyer 3',
        hp: 2600,
        turnspeed: 0.7,
        price: 130000,
        maxKrewCapacity: 16,
        cargoSize: 1600,
        baseheight: 5,
        width: 11.5,
        depth: 26,
        arcFront: 0.1,
        inertia: 1.0,
        radius: 15,
        speed: 5.7,
        labelHeight: 21,
        regeneration: 1,
        body: 'destroyer',
        sail: 'destroyer',
        scale: [6, 6, 6],
        offset: [0, -8, 0],
        rotation: [0, 0, 0],
    },

    11: {
        id: 11,
        image: '<img src="./assets/img/baby_fancy.png" style="height: 35px">',
        name: 'Baby Fancy',
        hp: 300,
        turnspeed: 1,
        price: 8000,
        maxKrewCapacity: 3,
        cargoSize: 300,
        baseheight: 1.4,
        width: 4,
        depth: 6.5,
        arcFront: 0.3,
        inertia: 0.1,
        radius: 8,
        speed: 5.9,
        labelHeight: 10,
        regeneration: 0.5,
        body: 'sloop',
        sail: 'sloop',
        mast: 'sloop',
        scale: [0.15, 0.18, 0.12],
        offset: [0, 5.5, 0],
        rotation: [0, 0, 0],
        availableAt: ['Spain', 'Brazil'],
    },
    12: {
        id: 12,
        image: '<img src="./assets/img/royal_fortune.png" style="height: 35px">',
        name: 'Royal Fortune',
        hp: 1000,
        turnspeed: 0.5,
        price: 70000,
        maxKrewCapacity: 15,
        cargoSize: 1200,
        baseheight: 4,
        width: 10,
        depth: 26,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 15,
        speed: 6,
        labelHeight: 12,
        regeneration: 1,
        body: 'schooner',
        sail: 'schooner',
        mast: 'schooner',
        scale: [0.15, 0.15, 0.15],
        offset: [2, 11.6, 3],
        rotation: [0, Math.PI / 2, 0],
        availableAt: ['Labrador', 'Spain'],
    },
    13: {
        id: 13,
        image: '<img src="./assets/img/calm_spirit.png" style="height: 35px">',
        name: 'Calm Spirit',
        hp: 1800,
        turnspeed: 0.7,
        price: 120000,
        maxKrewCapacity: 18,
        cargoSize: 2000,
        baseheight: 4,
        width: 10,
        depth: 30,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 16,
        speed: 5.9,
        labelHeight: 12,
        regeneration: 1,
        body: 'vessel',
        sail: 'vessel',
        mast: 'vessel',
        scale: [0.1, 0.1, 0.1],
        offset: [1, 10, 5],
        rotation: [0, Math.PI / 2, 0],
        availableAt: ['Spain', 'Guinea'],
    },
    14: {
        id: 14,
        image: '<img src="./assets/img/QBJ.png" style="height: 45px">',
        name: "Queen Barb's Justice",
        hp: 3000,
        turnspeed: 0.7,
        price: 200000,
        maxKrewCapacity: 20,
        cargoSize: 3000,
        baseheight: 5,
        width: 8,
        depth: 38,
        arcFront: 0.1,
        inertia: 1.0,
        radius: 20,
        speed: 5.9,
        labelHeight: 21,
        regeneration: 1,
        body: 'bigship',
        sail: 'bigship',
        mast: 'bigship',
        scale: [0.1, 0.1, 0.1],
        offset: [1, 13.4, 1],
        rotation: [0, Math.PI / 2, 0],
        availableAt: ['Spain'],
    },

    15: {
        id: 15,
        image: '<img src="./assets/img/trader.png" style="height: 35px">',
        name: 'Trader 2',
        hp: 500,
        turnspeed: 0.5,
        price: 11000,
        maxKrewCapacity: 6,
        cargoSize: 4000,
        baseheight: 3,
        width: 7,
        depth: 12.5,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 10,
        speed: 5.5,
        labelHeight: 12,
        regeneration: 1,
        body: 'trader',
        sail: 'trader',
        scale: [5.5, 5.5, 5.5],
        offset: [0, -4.5, 1],
        rotation: [0, 0, 0],
        availableAt: ['Jamaica'],
    },
    16: {
        id: 16,
        image: '<img src="./assets/img/trader.png" style="height: 40px">',
        name: 'Trader 3',
        hp: 750,
        turnspeed: 0.5,
        price: 30000,
        maxKrewCapacity: 6,
        cargoSize: 6000,
        baseheight: 3,
        width: 7,
        depth: 12.5,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 10,
        speed: 5.5,
        labelHeight: 12,
        regeneration: 1,
        body: 'trader',
        sail: 'trader',
        scale: [5.5, 5.5, 5.5],
        offset: [0, -4.5, 1],
        rotation: [0, 0, 0],
        availableAt: ['Jamaica'],
    },
    17: {
        id: 17,
        image: '<img src="./assets/img/baby_fancy.png" style="height: 40px">',
        name: 'Baby Fancy 2',
        hp: 500,
        turnspeed: 1,
        price: 40000,
        maxKrewCapacity: 3,
        cargoSize: 400,
        baseheight: 1.4,
        width: 4.5,
        depth: 7,
        arcFront: 0.3,
        inertia: 0.1,
        radius: 8,
        speed: 5.8,
        labelHeight: 10,
        regeneration: 0.5,
        body: 'sloop',
        sail: 'sloop',
        mast: 'sloop',
        scale: [0.15, 0.18, 0.12],
        offset: [0, 5.5, 0],
        rotation: [0, 0, 0],
        availableAt: ['Jamaica'],
    },
    18: {
        id: 18,
        image: '<img src="./assets/img/royal_fortune.png" style="height: 40px">',
        name: 'Royal Fortune 2',
        hp: 1300,
        turnspeed: 0.6,
        price: 110000,
        maxKrewCapacity: 18,
        cargoSize: 1400,
        baseheight: 4,
        width: 10,
        depth: 26,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 15,
        speed: 5.9,
        labelHeight: 12,
        regeneration: 1,
        body: 'schooner',
        sail: 'schooner',
        mast: 'schooner',
        scale: [0.15, 0.15, 0.15],
        offset: [2, 11.6, 3],
        rotation: [0, Math.PI / 2, 0],
        availableAt: ['Jamaica'],
    },
    19: {
        id: 19,
        image: '<img src="./assets/img/calm_spirit.png" style="height: 45px">',
        name: 'Calm Spirit 2',
        hp: 2200,
        turnspeed: 0.7,
        price: 170000,
        maxKrewCapacity: 20,
        cargoSize: 2600,
        baseheight: 4,
        width: 10,
        depth: 30,
        arcFront: 0.3,
        inertia: 0.5,
        radius: 16,
        speed: 5.8,
        labelHeight: 12,
        regeneration: 1,
        body: 'vessel',
        sail: 'vessel',
        mast: 'vessel',
        scale: [0.1, 0.1, 0.1],
        offset: [1, 10, 5],
        rotation: [0, Math.PI / 2, 0],
        availableAt: ['Jamaica'],
    },
    20: {
        id: 20,
        image: '<img src="./assets/img/QBJ.png" style="height: 50px">',
        name: "Queen Barb's Justice 2",
        hp: 4000,
        turnspeed: 0.7,
        price: 350000,
        maxKrewCapacity: 25,
        cargoSize: 4000,
        baseheight: 5,
        width: 8,
        depth: 38,
        arcFront: 0.1,
        inertia: 1.0,
        radius: 20,
        speed: 5.8,
        labelHeight: 21,
        regeneration: 1,
        body: 'bigship',
        sail: 'bigship',
        mast: 'bigship',
        scale: [0.1, 0.1, 0.1],
        offset: [1, 13.4, 1],
        rotation: [0, Math.PI / 2, 0],
        availableAt: ['Jamaica'],
    },
};

// PLayers are entities, check core_entity.js for the base class
Boat.prototype = new Entity();
Boat.prototype.constructor = Boat;

function Boat(captainId, krewName, spawnBool) {
    var captainsName = '';
    var spawnIslandId = undefined;

    if (entities[captainId] !== undefined) {
        captainsName = entities[captainId].name;
        if (entities[captainId].parent !== undefined) {
            spawnIslandId = entities[captainId].parent.netType === 5 ?
                entities[captainId].parent.id :
                entities[captainId].parent.anchorIslandId;
        }
    }

    this.createProperties();

    // parse the ship values
    this.supply = 0;

    this.setShipClass(1); // start off with cheapest boat

    this.hpRegTimer = 0;
    this.hpRegInterval = 1;

    this.arcFront = 0.0;

    // info that is not sent via delta
    this.muted = ['x', 'z', 'y'];

    //krew members
    this.krewMembers = {};

    this.krewCount = 0; // Keep track of boat's krew count to update krew list window

    //this.totalWorth = 0; // Keep track of boat's total worth to update krew list window

    this.recruiting = false; // If the ship has been docked for more than 5 minutes, then it's not recruiting
    this.isLocked = false; // By default krew is not locked
    this.departureTime = 5;
    this.lastMoved;

    // netcode type
    this.netType = 1;

    // Boats can either steer left or right. 0 = no steering
    this.steering = 0;

    // boats states, 0 = sailing/ 1 = docking..,etc
    this.shipState = {
        starting: -1,
        sailing: 0,
        docking: 1,
        finishedDocking: 2,
        anchored: 3,
        departing: 4,
    };

    this.shipState = -1;
    this.overall_kills = 0; //Number of ships the whole crew has sunk
    this.overall_cargo = 0; //Amount of cargo (worth gold) traded by the whole crew

    this.sentDockingMsg = false;

    // this.anchorIsland = undefined;
    this.anchorIslandId = spawnIslandId;

    // a timer that counts down once your hp is below zero - you are sinking
    this.sinktimer = 0;

    // boats have a captain, but we only reference it by ID (better for netcode)
    // If there is no captain, the id is: ""
    if (captainId && entities[captainId]) {
        this.captainId = captainId;
        this.clan = entities[captainId].clan; 
    } else {
        this.captainId = "";
        this.clan = "";
    }

    // Boats have a crew name, by default it's the captains name or the passed krew name,
    // this is setted on the update function, so initially is set to undefined
    captainsName = typeof captainsName === 'string' ? captainsName : '';
    this.crewName = typeof krewName === 'string'
        ? krewName
        : (
            captainsName + "'" +
            (captainsName.charAt(captainsName.length - 1) === 's' ? '' : 's') +
            ' krew'
        );

    // on death, we drop things. this is a security value so it only happens once
    this.hasDoneDeathDrops = false;

    // set up geometry for client
    this.rottimer = Math.random() * 5;

    // value that makes the ship lean towards one side
    this.leanvalue = 0;

    this.setName(this.crewName);
}

Boat.prototype.updateProps = function () {

    var krewCount = 0;
    for (var id in this.children) {
        if (
            entities[id] === undefined ||
            entities[id].parent === undefined ||
            entities[id].parent.id !== this.id
        ) {
            delete this.children[id];
            continue;
        }

        var child = this.children[id];
        if (child && child.netType === 0) {
            krewCount += 1;
        }
    }

    this.krewCount = krewCount;
    if (this.krewCount === 0) removeEntity(this);
};

Boat.prototype.setName = function (crewName) {
    var clan = '';
    if (this.clan !== undefined && this.clan !== '') {
        clan = '['+this.clan+'] ';
    }
    if (this.geometry !== undefined) {
        if (this.label === undefined) {
            // Set the crews name
            this.label = new THREE.TextSprite({
                textSize: 4,
                redrawInterval: CONFIG.Labels.redrawInterval,
                texture: {
                    text: clan + crewName,
                    fontFamily: CONFIG.Labels.fontFamily,
                },
                material: {
                    color: 0xc5a37c,
                    fog: false,
                },
            });
            this.label.name = 'label';
            this.label.position.set(0, boatTypes[this.shipclassId].labelHeight, 0);

            for (var l = this.geometry.children.length; l--;) {
                if (
                    this.geometry.children[l].isTextSprite &&
                    this.geometry.children[l].name === 'label'
                ) {
                    this.geometry.remove(this.geometry.children[l]);
                }
            }
            this.geometry.add(this.label);
        }
        this.label.material.map.text = clan + crewName;
        this.label.visible = myPlayer &&
            myPlayer.parent &&
            this.id !== myPlayer.parent.id &&
            this[CONFIG.Labels.boats.useMethod];
    }
    this.crewName = crewName;
};

Boat.prototype.logic = function (dt) {

    // world boundaries
    var boundaryCollision = false;
    if (this.position.x > worldsize) {
        this.position.x = worldsize;
        boundaryCollision = true;
    }

    if (this.position.z > worldsize) {
        this.position.z = worldsize;
        boundaryCollision = true;
    }

    if (this.position.x < 0) {
        this.position.x = 0;
        boundaryCollision = true;
    }

    if (this.position.z < 0) {
        this.position.z = 0;
        boundaryCollision = true;
    }

    var kaptain = entities[this.captainId];

    // the boat movement is simple. it always moves forward, and rotates if the captain is steering
    if (kaptain !== undefined && this.crewName !== undefined) {
        this.speed = boatTypes[this.shipclassId].speed + parseFloat(kaptain.movementSpeedBonus / 100);
    }

    var moveVector = new THREE.Vector3(0, 0, (this.speed));

    // if boat is not anchored or not in docking state, we will move
    if (this.shipState == 0) {

        // if the steering button is pressed, the rotation changes slowly
        (kaptain !== undefined) ?
            this.rotation += this.steering * dt * 0.4 * (this.turnspeed + parseFloat(0.05 * kaptain.movementSpeedBonus / 100)) :
            this.rotation += this.steering * dt * 0.4 * this.turnspeed;

        // we rotate the movement vector depending on the current rotation
        moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation);

    } else {
        moveVector.set(0, 0, 0);
    }

    // set the velocity to be the move vector
    this.velocity = moveVector;

    // client side, calculate the ship leaning
    this.leanvalue += (this.steering * 4 - this.leanvalue) * dt;
    this.rottimer += dt;

    if (myPlayer && myPlayer.parent && this.sail) {
        this.sail.material.visible = this.id === myPlayer.parent.id ? false : true;
    }

    if (myPlayer && myPlayer.parent && this.mast) {
        this.mast.material.visible = this.id === myPlayer.parent.id ? false : true;
    }

    if (this.body &&
        (
            this.shipState === 3 ||
            this.shipState === -1 ||
            this.shipState === 4
        )
    ) {
        this.rottimer = 0;
        this.leanvalue = 0;
        if (this.body.material.opacity >= 0.5) {
            this.body.material.opacity -= 0.0075;
        }

        if (this.sail && this.sail.material.opacity >= 0.5) {
            this.sail.material.opacity -= 0.0075;
        }

        if (this.mast && this.mast.material.opacity >= 0.5) {
            this.mast.material.opacity -= 0.0075;
        }
    } else {
        this.body.material.opacity = 1;
        if (this.sail) {
            this.sail.material.opacity = 0.9;
        }

        if (this.mast) {
            this.mast.material.opacity = 0.9;
        }
    }

    this.geometry.rotation.x = Math.sin(this.rottimer * 0.5 + 3) * Math.sin(this.rottimer) * 0.05;
    this.geometry.rotation.z = Math.sin(this.rottimer * 1.0) * 0.05 - this.leanvalue * 0.08;

    //push away from islands
    /*
    for (e in entities)
    {
        if(entities[e] != this && entities[e].netType == 5)
        {
            var dist = entityDistance(this, entities[e]) - (entities[e].collisionRadius + this.collisionRadius );

            if(dist < 10)
            {
                var local = this.toLocal(entities[e].position);
                //var power = entities[e].inertia/this.inertia;
                   // either add it to rotation, or to the steering
                this.rotation += -((local.x > 0 ? (10-local.x) : (10+local.x) )*(10-dist)*(local.z+10))*dt*0.0005;
            }
        }
    }*/

    // if our hp is low (we died)
    if (this.hp <= 0) {

        // on client, disconnect the camera from the player
        if (myPlayer && myPlayer.parent == this) {
            ui.playAudioFile(false,'sink-crash');
            THREE.SceneUtils.detach(camera, camera.parent, scene);
            $('#shopping-modal').hide();
            $('#show-shopping-modal-button').hide();
        }

        // increase the sink timer, make ship sink
        this.sinktimer += dt;

        if (this.sinktimer > 4.0) {
            // ships down, lets remove it from game

            removeEntity(this);
        }
    }

    // calculate the krew members' salary based on their score
    // first, find total amount of all krew members' scores combined

    // if (this.captain)
    // {
    //     var totalScore = 0;
    //     for (id in this.children)
    //     {
    //         var krewMember = this.children[id];
    //         totalScore += krewMember.score;
    //     }

    //     var totalSalary = 0;
    //     var captainsCut = 0;
    //     if (totalScore > 0)
    //     {
    //         // then, determine the salary
    //         for (id in this.children)
    //         {

    //             var krewMember = this.children[id];
    //             var salary = (krewMember.score / totalScore) * (this.supply * .7)
    //             if (this.captainId == id)
    //             {
    //                 captainsCut = salary;
    //             }

    //             krewMember.salary = salary;
    //             totalSalary += salary;
    //         }
    //     }

    //     this.captain.salary = captainsCut + this.supply - totalSalary;
    // }

};

Boat.prototype.clientlogic = function () {

    // on client, always make the y position the height above the water (depends on how much hp the ship has)
    this.position.y = this.getHeightAboveWater();

    // rotate through water
    var geometryPosition = new THREE.Vector3(
        this.position.x,
        this.position.y,
        this.position.z
    );

    this.geometry.position.lerp(geometryPosition, 0.8);

    this.geometry.rotation.y = lerp(
        this.geometry.rotation.y,
        this.rotation,
        0.5
    );
};

Boat.prototype.setShipClass = function (classId) {
    this.shipclassId = classId;

    var currentShipClass = boatTypes[classId];

    this.maxHp = currentShipClass.hp;
    this.hp = this.maxHp;
    this.turnspeed = currentShipClass.turnspeed;
    this.maxKrewCapacity = currentShipClass.maxKrewCapacity;
    this.size.set(currentShipClass.width, currentShipClass.height, currentShipClass.depth);
    this.arcFront = currentShipClass.arcFront;
    this.inertia = currentShipClass.inertia;
    this.collisionRadius = currentShipClass.radius;
    this.speed = currentShipClass.speed;
    this.shipState = 2;

    //console.log("changing boat model");
    this.changeBoatModel(this.shipclassId);
    if (myPlayer != undefined) {
        if (this == myPlayer.parent) {
            ui.showCenterMessage('Ship upgraded to ' + boatTypes[this.shipclassId].name, 3);
            ui.updateStore($('.btn-shopping-modal.active'));
        }
    }
};

Boat.prototype.getKrewOnBoard = function () {
    for (var i in this.children) {
        if (this.children[i].parent && this.children[i].parent.id === this.id) {
            this.geometry.add(this.children[i].geometry);
            this.children[i].position.x = 0;
            this.children[i].position.y = 0;
            this.children[i].position.z = 0;
        }

        if (this.children[i].parent === undefined || this.children[i].parent.id !== this.id) {
            delete this.children[i];
        }
    }
};

// function that generates boat specific snapshot data
Boat.prototype.getTypeSnap = function () {
    return {
        h: this.hp,
        s: this.steering,
        c: this.shipclassId,
        u: this.supply,
        b: this.captainId,
        t: this.shipState,
        a: this.anchorIslandId,
        k: this.krewCount,
        e: this.speed,
        r: this.recruiting,
        l: this.isLocked,
        d: this.departureTime,
    };
};

// function that generates boat specific delta data
Boat.prototype.getTypeDelta = function () {
    var delta = {
        h: this.deltaTypeCompare('h', this.hp),
        s: this.deltaTypeCompare('s', this.steering.toFixed(4)),
        c: this.deltaTypeCompare('c', this.shipclassId),
        u: this.deltaTypeCompare('u', this.supply),
        b: this.deltaTypeCompare('b', this.captainId),
        t: this.deltaTypeCompare('t', this.shipState),
        a: this.deltaTypeCompare('a', this.anchorIslandId),
        k: this.deltaTypeCompare('k', this.krewCount),
        e: this.deltaTypeCompare('e', this.speed),
        r: this.deltaTypeCompare('r', this.recruiting),
        l: this.deltaTypeCompare('l', this.isLocked),
        d: this.deltaTypeCompare('d', this.departureTime),
    };

    if (isEmpty(delta)) {
        delta = undefined;
    }

    return delta;
};

// function that parses a snapshot
Boat.prototype.parseTypeSnap = function (snap) {
    if (snap.h !== undefined && snap.h != this.hp) {
        this.hp = parseInt(snap.h);
    }

    if (snap.s !== undefined) {
        this.steering = parseFloat(snap.s);
    }

    //if (snap.d !== undefined) this.isDocking = snap.d;

    // update supply
    if (snap.u !== undefined) {
        var newSupply = parseInt(snap.u);
        if (myPlayer && this == myPlayer.parent && newSupply != this.supply) {
            var suppliesEarned = newSupply - this.supply;
            if (suppliesEarned > 1) {
                ui.showCenterMessage('+ ' + suppliesEarned + ' supplies', 2);
            }
        }

        this.supply = newSupply;
    }

    // if class has changed, change model
    if ((snap.c !== undefined && snap.c != this.shipclassId) || this.body == undefined) {
        this.setShipClass(snap.c);
    }

    // if anchorIsland changed
    if (snap.a !== undefined && snap.a != this.anchorIslandId) {
        this.anchorIslandId = snap.a;
    }

    // if krew count changed
    if (snap.k !== undefined && snap.k != this.krewCount) {
        this.krewCount = snap.k;
    }

    // if captain has changed
    if (snap.b !== undefined && this.captainId != snap.b) {
        this.captainId = snap.b;
    }

    // if speed has changed
    if (snap.e !== undefined && this.speed != snap.e) {
        this.speed = parseInt(snap.e);
    }

    // if recruiting has changed
    if (snap.r !== undefined && this.recruiting != snap.r) {
        this.recruiting = parseBool(snap.r);
    }

    // if krew lock has changed
    if (snap.l !== undefined && this.isLocked != snap.r) {
        this.isLocked = parseBool(snap.l);
    }

    // if departure time has changed
    if (snap.d !== undefined && this.departureTime != snap.d) {
        this.departureTime = parseInt(snap.d);
    }

    // If the ship's state has changed, send a snap and change its transparency if it docked
    if (snap.t !== undefined && this.shipState != snap.t) {
        this.shipState = parseInt(snap.t);
        if (this.shipState === 0) {
            this.getKrewOnBoard();
        }
        /*var dockDecision = this.shipState == 3 || this.shipState == -1 || this.shipState == 4? 1 : 0;
        this.docking(dockDecision)*/
    }
};

// function that parses a snapshot
Boat.prototype.onDestroy = function () {

    this.children = {};

    // makre sure to also call the entity ondestroy
    Entity.prototype.onDestroy.call(this);

    if (boats[this.id]) {
        delete boats[this.id];
    }
};

Boat.prototype.getHeightAboveWater = function () {
    return boatTypes[this.shipclassId].baseheight * (0.2 + 0.8 * (this.hp / this.maxHp)) - this.sinktimer; // this.hp*0.01 - 1 - this.sinktimer;
};

Boat.prototype.enterIsland = function (islandId) {
    // we only want to change the ship state to docking once.
    if (this.shipState === 0) {
        this.shipState = 1;
    }

    this.anchorIslandId = islandId;

    // pay everyone salary
    // for (id in this.children)
    // {
    //     var krewMember = this.children[id]
    //     krewMember.gold += krewMember.salary;
    //     this.children[id].salary = 0;
    //     this.children[id].score = 0;
    // }

    // this.supply = 0;
};

Boat.prototype.exitIsland = function () {

    this.shipState = 0;
    this.recruiting = false;
    this.departureTime = 5;

    if (this.anchorIslandId) {
        //set rotation away from island
        this.rotation = rotationToObject(this, entities[this.anchorIslandId]);

        // make a tiny jump so we dont instantly anchor again
        var outward = angleToVector(this.rotation);
        this.position.x = entities[this.anchorIslandId].position.x - outward.x * (entities[this.anchorIslandId].dockRadius + 5);
        this.position.z = entities[this.anchorIslandId].position.z - outward.y * (entities[this.anchorIslandId].dockRadius + 5); // <- careful. y value!
    }

    this.anchorIslandId = undefined;
};

// when ship is abandoning its mothership!
Boat.prototype.exitMotherShip = function (mothership) {

    //set rotation away from mothership
    this.rotation = rotationToObject(this, mothership);

    // make a tiny jump away from mothership
    var outward = angleToVector(this.rotation);
    this.position.x = mothership.position.x - outward.x * (mothership.collisionRadius + 5);
    this.position.z = mothership.position.z - outward.y * (mothership.collisionRadius + 5); // <- careful. y value!

};

Item.prototype.constructor = Item;

function Item() {}
Item.prototype.logic = dt => {}

Player.prototype = new Entity();
Player.prototype.constructor = Player;

function Player(data) {
    this.name = data ? (data.name || ``): ``;

    this.createProperties();

    // Stand on top of the boat.
    this.position.y = 0.0;

    // Netcode type.
    this.netType = 0;

    // Size fo a palyer.
    this.size = vectors.sizePlayer;

    // Players can walk forward and sideward.
    this.walkForward = 0;
    this.walkSideward = 0;

    // Players can use whatever they are holding.
    this.use = false;
    this.useid = 0;
    this.cooldown = 0;

    // Players have a pitch value (The angle at which they look into the sky).
    this.pitch = 0;
    this.score = 50;
    this.salary = 0;

    this.ovreall_cargo = 0;
    this.last_island = ``;
    this.gold = (data.startingItems || {}).gold || 0;

    this.islandBoundary = {
        x: 0,
        z: 0
    }

    this.shipsSank = 0;
    this.shotsFired = 0;
    this.shotsHit = 0;

    this.sentDockingMsg = false;

    // Keep track of player state.
    this.state = {
        alive: 0,
        dead: 1,
        respawning: 2
    }
    this.state = 0;

    this.activeWeapon = {
        nothing: -1,
        cannon: 0,
        fishingRod: 1,
        spyglass: 2
    }

    this.activeWeapon = 0;
    this.justLogged = true;
    this.isFishing = false;

    this.checkedItemsList = false;
    this.rateItemsFound = [];

    // Rotation speed for fishing rod.
    this.rodRotationSpeed = Math.random() * 0.25 + 0.25;

    // Players keep track of whether they are captain or not.
    this.isCaptain = false;
    this.oldCaptainState = false;

    // Anti-chat measures.
    this.sentMessages = [];
    this.lastMessageSentAt = undefined;
    this.isSpammer = false;
    this.lastMoved = new Date();

    this.jumping = 0;
    this.jump_count = 0;

    this.fly = 0;
    this.waterWalk = 0;

    this.itemId;

    this.ownsCannon = true;
    this.ownsFishingRod = true;

    this.attackSpeedBonus = 0;
    this.attackDamageBonus = 0;
    this.attackDistanceBonus = 0;
    this.movementSpeedBonus = 0;
    this.armorBonus = 0;

    // Leveling system.
    this.level = 0;
    this.experience = 0;
    this.experienceBase = 100;
    this.experienceMaxLevel = 50;
    this.experienceNeedsUpdate = true;

    // Bank and casino.
    this.bank = {
      deposit: 0,
    }
    this.casino = {}

    this.clan = data.t.cl == `` ? undefined : data.t.cl;
    this.clanLeader = data.t.cll;
    this.clanOwner = data.t.clo;
    this.clanRequest = data.t.cr;
    this.isLoggedIn = data.t.l;

   // Build an object with the levels from 0 to max level for future references
    this.experienceNeededForLevels = (entity => {
        let levels = { 0: { amount: 0, total: 0 }, 1: { amount: entity.experienceBase, total: entity.experienceBase } };

        for (let i = 1; i < entity.experienceMaxLevel + 1; i++) {
            levels[i + 1] = {};
            levels[i + 1].amount = Math.ceil(levels[i].amount * 1.07);
            levels[i + 1].total = levels[i + 1].amount + levels[i].total;
        }
        return levels;
    })(this);

    this.points = {
        fireRate: 0,
        distance: 0,
        damage: 0,
    };
    let _this = this;
    this.pointsFormula = {
        getFireRate: () => {
            return (_this.points.fireRate >= 50 ? 50 : _this.points.fireRate) * 1.2;
        },
        getDistance: () => {
            return (_this.points.distance >= 50 ? 50 : _this.points.distance) / 2;
        },
        getDamage: () => {
            return (_this.points.damage >= 50 ? 50 : _this.points.damage) / 2;
        },
        getExperience: damage => {
            return parseInt(damage * 2.4);
        }
    }

    // set up references to geometry and material
    this.jump = 0.0;
    this.jumpVel = 0.0;

    //Let the current players know about this player
    if(!playerNames[data.id]) playerNames[data.id] = this.name;

    this.notificationsHeap = {}

    //Create the label for this player when it is created
    this.setName(this.name);
    this.crossHair();
}

Player.prototype.notifications = () => {
    for(let i in this.notificationsHeap) {
        if(this.notificationsHeap[i].isNew) {
            this.notificationsHeap[i].sprite = new THREE.TextSprite({
                textSize: this.notificationsHeap[i].type == 1 ? 0.6: 0.9,
                redrawInterval: 10,
                texture: {
                    text: this.notificationsHeap[i].text,
                    fontFamily: CONFIG.Labels.fontFamily
                },
                material: {
                    color: this.notificationsHeap[i] == 1 ? 0xffd700: 0x62ff00,
                    fog: false,
                    opacity: 0.0
                }
            });
            this.notificationsHeap[i].sprite.position.set(3, 1, 0);
            this.geometry.add(this.notificationsHeap[i].sprite);
            this.notificationsHeap[i].isNew = false;
        }
        else {
            this.notificationsHeap[i].sprite.position.y += 0.05;

            if(this.notificationsHeap[i].sprite.position.y > 6) {
                this.geometry.remove(this.notificationsHeap[i].sprite);
                delete this.notificationsHeap;
            }
            else if(this.notificationsHeap[i].sprite.position.y < 3) this.notificationsHeap[i].sprite.material.opacity += 0.025;
        }
    }
}

Player.prototype.updateExperience = function(damage) {
    let experience = this.experience;
    let level = 0;

    if(typeof damage == `number`) experience += this.pointsFormula.getExperience(damage);
    if(experience > this.experienceNeededForLevels[this.experienceMaxLevel].total) experience = this.experienceNeededForLevels[this.experienceMaxLevel].total;

    for(let i in this.experienceNeededForLevels) {
        if(experience < this.experienceNeededForLevels) break;
        level = i;
    }
    level = parseInt(level);

    this.level = leve;
    this.experience = experience;

    if(ui && this.experienceNeedsUpdate) {
        ui.updateUiExperience();
        this.experienceNeedsUpdate = false;
    }
}

Player.prototype.rotationOffset = -0.45;

Player.prototype.logic = dt => {
    // Check if we are the captain of our ship.
    this.oldCaptainState = this.isCaptain;
    this.isCaptain = this.parent && this.id == this.parent.captainId;

    // The player movement logic is depending on whether the walkSidward / walkForward buttons are pressed.
    let moveVector = new THREE.Vector3(0, 1, 0);
    moveVector.z = -this.walkForward;
    moveVector.x = this.walkSideward;

    if(moveVector.lengthSq() > 0) moveVector.normalize();

    // Rotate movevector along y rotation of cube.
    moveVector.applyAixsAngle(new THREE.Vector3(0, 1, 0), this.rotation);
    this.velocity = moveVector;

    this.velocity.x *= 3;
    this.velocity.z *= 3;

    // Collisions (movement restrictinow hen on boat and not anchored / docked yet).
    if(this.parent) {
        if(this.parent.netType == 5 || this.parent.shipState == 3 || this.parent.shipState == -1) {
            this.velocity.x *= 20;
            this.velocity.z *= 20;
        }


        if(this.parent.netType !== 5 && this.parent.shipState !== 3 && this.parent.shipState !== 2 && this.parent.shipState !== -1 && this.parent.shipState !== 4) {
            if(this.position.x > this.parent.size.x / 2) { 
                this.position.x = this.parent.size.x / 2;
                if(this.isPlayer) ui.playAudioFile(false, `turning`);
            }

            if(this.position.z > this.parent.size.z / 2) { 
                this.position.z = this.parent.size.z / 2;
                if(this.isPlayer) ui.playAudioFile(false,'turning');
            }

            if(this.position.x < -this.parent.size.x / 2) { 
                this.position.x = -this.parent.size.x / 2;
                if(this.isPlayer) ui.playAudioFile(false,'turning');
            }

            if(this.position.z < -this.parent.size.z / 2) { 
                this.position.z = -this.parent.size.z / 2;
                if(this.isPlayer) ui.playAudioFile(false,'turning');
            }

            // Oval boat shape collision.
            if(this.parent.arcFront > 0 && this.position.z > 0) {
                let bound = this.parent.size.x / 2 - this.position.z * this.parent.arcFront; //this.parent.size.z/2 -
                if(this.position.x > 0) if(this.position.x > bound) this.position.x = bound;
                else if(this.position.x < -bound) this.position.x = -bound;
            }
        }
    }

    // Use active item (i.e. cannonball fire).
    if(this.cooldown > 0) this.cooldown -= dt;

    if(this.use == true && this.cooldown <= 0) {
        let attackSpeedBonus = parseFLoat((this.attackSpeedBonus + this.pointsFormula.getFireRate()) / 100);
        this.cooldown = this.activeWeapon == 1 ? 2: (1.5 - attackSpeedBonus).toFixed(2);

        if(this.activeWeapon == 0 && this.isPlayer && this.parent && this.parent.shipState != 3 && this.parent.shipState != 4) ui.playAudioFile(false, `cannon`);
        else if(this.isPlayer && this.activeWeapon == 1) ui.playAUdioFile(false, `cast-rod`);
    }
    if(!this.isPlayer) this.geometry.rotation.x = this.pitch + this.rotationOffset;
}

// Function that generates boat-specific snapshot data.
Player.prototype.getTypeSnap = () => {
    let obj = {
        f: this.walkForward,
        s: this.walkSideward,
        u: this.use,
        p: this.pitch,
        j: this.jumping,
        m: this.movementSpeedBonus,
        g: this.armorBonus,
        w: this.activeWeapon,
        c: this.checkedItemsList,
        d: this.itemId,
        o: this.ownsCannon,
        r: this.ownsFishingRod,
        v: this.availablePoints,
        e: {
            e: this.experience,
            p: {
                fr: this.fireRate,
                ds: this.distance,
                dm: this.damage,
            },
            l: this.level
        }
    }
    return obj;
}

Player.prototype.getTypeDelta = () => {
    let delta = {
        f: this.deltaTypeCompare(`f`, this.walkForward),
        s: this.deltaTypeCompare(`s`, this.walkSideward),
        u: this.deltaTypeCompare(`u`, this.use),
        p: this.deltaTypeCompare(`p`, this.pitch.toFixed(2)),
        j: this.deltaTypeCompare(`j`, this.jumping),
        w: this.deltaTypeCompare(`w`, this.activeWeapon),
        c: this.deltaTypeCompare(`c`, this.checkedItemsList),
        d: this.deltaTypeCompare(`d`, this.itemId),
        o: this.deltaTypeCompare(`o`, this.ownsCannon),
        r: this.deltaTypeCompare(`r`, this.ownsFishingRod),
        v: this.deltaTypeCompare(`v`, this.availablePoints)
    }
    if (isEmpty(delta)) delta = undefined;
    return delta;
}

Player.prototype.setName = name => {
    let clan = ``;
    if(this.clan && this.clan != ``) clan = `[${this.clan}] `;

    if(this.geometry) {
        if(!this.label) {
            // Set the name.
            this.label = new THREE.TextSprite({
                textSize: 0.7,
                redrawInterval: CONFIG.Labels.redrawInterval,
                texture: {
                    text: `${clan + name} (lvl ${this.level})`,
                    fontFamily: CONFIG.Labels.fontFamily
                },
                material: {
                    color:
                        this.isPlayer ? labelcolors.myself:
                        this.isCaptain ? labelcolors.captain:
                        labelcolors.player,
                    fog: false
                }
            });

            this.label.name = `label`;
            this.label.position.set(0, 2, 0);
            this.geometry.add(this.label);
        }
        this.label.material.map.text = `${clan + name} (lvl ${this.level})`;
        this.label.visible = myPlayer && myPlayer.parent && this.inRange && this.parent && (this.parent.netType == 5 || this.parent.inRange);
    }
    this.name = name;
}

Player.prototype.getName = () => {
    return this.name;
}

// Function that parses a snapshot.
Player.prototype.parseTypeSnap = function(snap) {
    if(snap.f) this.walkForward = parseInt(snap.f);
    if(snap.s) this.walkSideward = parseInt(snap.s);
    if(snap.u) this.use = parseBool(snap.u);
    if(snap.p) this.pitch = parseFloat(snap.p);
    if(snap.j) this.jumping = parseInt(snap.j);
    if(snap.m) this.moveemntSpeedBonus = parseInt(snap.m);
    if(snap.v && snap.v != this.availablePoints) this.availablePoints = parseInt(snap.v);
    if(snap.o && snap.o != this.ownsCannon) {
        this.ownsCannon = parseBool(snap.o);
        if(ui) ui.updateStore($(`.btn-shopping-modal.active`));
    }
    if(snap.r && snap.r != this.ownsFishingRod) {
        this.ownsFishingRod = parseBool(snap.r);
        if(ui) ui.updateStore($(`.btn-shopping-modal.active`));
    }
    if(snap.c && snap.c != this.checkedItemsList) this.checkedItemsList = parseBool(snap.c);
    if(snap.d && snap.d != this.itemId) {
        this.itemId = parseInt(snap.d);
        if(ui) ui.updateStore($(`.btn-shopping-modal.active`));
    }
    if(snap.w && snap.w != this.activeWeapon) {
        this.activeWeapon = parseInt(snap.w);
        this.changeWeapon();
    }
    if(snap.f || snap.s || snap.u || snap.p) this.lastMoved = new Date();
}

Player.prototype.onDestroy = () => {
    Entity.prototype.onDestroy.call(this);
    if(this == myPlayer) myPlayer = undefined;

    if(this.parent) {
        delete this.parent.children[this.id];
        if(this.parent.netType == 1) {
            this.parent.updateProps();
            if(Object.keys(this.parent.cihldren).length == 0) removeEntity(this.parent);
        }
    }
    if(players[this.id]) delete players[this.id];
}

Player.prototype.setPlayerBody = function(idx) {
    idx = idx || 0;

    let bodyModel = playerModels[idx];

    this.playerBody = bodyModel.body.clone();
    this.playerBody.scale.set(bodyModel.scale.x, bodyModel.scale.y, bodyModel.scale.z);
    this.playerBody.position.set(bodyModel.offset.x, bodyModel.offset.y, bodyModel.offset.z);
    this.playerBody.rotation.set(bodyModel.rotation.x, bodyModel.rotation.y, bodyModel.rotation.z);
    this.geometry.add(this.playerBody);

    this.weapon = models.cannon.clone();
    this.weapon.scale.set(0.05, 0.05, 0.05);
    this.weapon.position.set(0, 0, -0.4);
    this.weapon.rotation.set(0, 0, 0);
    this.weapon.name = `body`;
    this.geometry.add(this.weapon);

    this.captainHat = models.hat_pirate.clone();
    this.captainHat.scale.set(0.4, 0.4, 0.4);
    this.captainHat.position.set(0, 25, 0);
    this.captainHat.name = `captainHat`;
}

Player.prototype.crossHair = () => {
    this.crosshair = new THREE.TextSprite({
        textSize: 0.0365,
        redrawInterval: 10,
        texture: {
            text: `+`,
            fontFamily: CONFIG.Labels.fontfamily
        },
        material: {
            color: 0x00ff00,
            fog: false
        }
    });
}

Player.prototype.changeWeapon = function() {
    if(this.weapon && this.activeWeapon == 0) {
        this.geometry.remove(this.weapon);
        this.weapon = models.cannon.clone();

        if(this.isPlayer) ui.playAudioFile(false, `switch-rod-cannon`);

        this.weapon.scale.set(0.05, 0.05, 0.05);
        this.weapon.position.set(0, 0.1, -0.4);
        this.weapon.rotation.set(0, 0, 0);
        this.weapon.name = `body`;
        this.geometry.add(this.weapon);
    }
    else if(this.weapon && this.activeWeapon == 1) {
        this.geometry.rmeove(this.weapon);

        let fishingModel = new THREE.Mesh(geometry.fishingrod, materials.fishingrod);
        if(this.isPlayer) ui.playAudioFile(false, `switch-rod-cannon`);

        this.weapon = fishingModel.clone();
        this.weapon.scale.set(0.03, 0.03, 0.03);
        this.weapon.position.set(0, 0.1, -0.2);
        this.weapon.rotation.set(0, Math.PI, 0);
        this.weapon.name = `body`;
        this.geometry.add(this.weapon);
    }
    else if(this.weapon  && this.activeWeapon == 2) {
        this.geometry.remove(this.weapon);
        this.weapon = models.spyglass.clone();
        this.weapon.scale.set(0.7, 0.7, 0.7);
        this.weapon.position.set(0, 0.5, 0.3);
        this.weapon.rotation.set(0.5, Math.PI / 2 + 0.07, 0.5);
        this.weapon.name = `body`;
        this.geometry.add(this.weapon);        
    }
}

let parseBool = b => {
    return b === true || b === `true`;
}

// PLayers are entities, check core_entity.js for the base class
Impact.prototype = new Entity();
Impact.prototype.constructor = Impact;

function Impact(type, x, z) {

    this.createProperties();

    // netcode type
    this.netType = 3;

    // very little net data
    this.sendDelta = false;
    this.sendSnap = false;
    this.sendCreationSnapOnDelta = true;

    // impact type, there are different impact types (in water, in ship, etc)
    this.impactType = type;

    // // size of a Impact
    this.size = new THREE.Vector3(1, 1, 1);

    // impacts have a timeout
    this.timeout = 1.0;

    // set up references to geometry and material
    this.position.y = 0;

    // impacts have a type (impact in water vs impact in boat)
    switch (type) {
        case 0: {// water

            this.baseGeometry = geometry.impact_water;
            this.baseMaterial = materials.impact_water;
            for (var i = 0; i < 3; ++i) {
                createParticle({
                    vx: -5 + Math.random() * 10,
                    vy: 4 + Math.random() * 2,
                    vz: -5 + Math.random() * 10,
                    x: x,
                    z: z,
                    y: 0,
                    w: 0.3,
                    h: 0.3,
                    d: 0.3,
                    gravity: 5,
                    gravity: 5,
                    rotaSpeed: Math.random() * 20,
                    duration: 5,
                    sizeSpeed: -0.6,
                    material: materials.impact_water,
                    geometry: base_geometries.box,
                });
            }

            break;
        }

        case 1: { // ship
            GameAnalytics("addDesignEvent", "Game:Session:Hit");
            for (var i = 0; i < 5; ++i) {
                createParticle({
                    vx: -10 + Math.random() * 20,
                    vy: 5 + Math.random() * 5,
                    vz: -10 + Math.random() * 20,
                    x: x,
                    z: z,
                    y: 0,
                    w: 0.2 + Math.random() * 0.5,
                    h: 0.2 + Math.random() * 0.5,
                    d: 0.2 + Math.random() * 0.5,

                    gravity: 12,
                    rotaSpeed: Math.random() * 10,
                    duration: 2,
                    sizeSpeed: -0.8,
                    material: materials.splinter,
                    geometry: base_geometries.box,

                });
            }

            break;
        }
    }

    this.position.x = x;
    this.position.z = z;
}

Impact.prototype.logic = function (dt) {

    // tick down the timer and delete on end
    this.timeout -= dt * 0.8;
    if (this.timeout <= 0) {
        removeEntity(this);
    }

};

Impact.prototype.clientlogic = function (dt) {

    if (this.impactType == 0) {
        this.geometry.position.set(this.position.x, this.position.y, this.position.z);
        this.geometry.scale.y = (this.timeout < 0.5 ? Ease.easeOutQuad(this.timeout * 2) : 1.0 - Ease.easeInQuint((this.timeout - 0.5) * 2)) * 5;

        var quad = Ease.easeOutQuad(this.timeout);
        this.geometry.scale.x = 1.5 - quad;
        this.geometry.scale.z = 1.5 - quad;
    }

};

Impact.prototype.getTypeSnap = function () {
    var snap = {
        a: this.impactType,
    };
    return snap;
};

Impact.prototype.getTypeDelta = function () {
    if (!this.spawnPacket) {
        this.spawnPacket = true;
        return this.getTypeSnap();
    }

    return undefined;
};

// function that parses a snapshot
Impact.prototype.parseTypeSnap = function (snap) {
    if (snap.a !== undefined) {this.impactType = parseFloat(snap.a);}
};

// PLayers are entities, check core_entity.js for the base class
Pickup.prototype = new Entity();
Pickup.prototype.constructor = Pickup;

function Pickup(size, x, z, type) {
    this.createProperties();

    // netcode type
    this.netType = 4;
    this.bonusValues = [50, 75, 100, 10000];

    // Pickup type, there are different Pickup types. supplies = 0
    this.pickupSize = size;
    this.bonus = this.bonusValues[this.pickupSize] || 25;

    this.captainsCutRatio = 0.3;

    // net data
    this.sendDelta = type == 1? false : true;
    this.sendSnap = type == 1? false : true;
    this.sendCreationSnapOnDelta = true;
    this.spawnPacket = false;

    // // size of a Pickup
    var scale = 1;
    if (type === 0) {
        scale = parseInt(size) + 1;
    }

    if (type === 1) {
        scale = 0.05 * size;
        GameAnalytics("addDesignEvent", "Game:Session:CatchFish");
    }

    if (type === 3 || type === 2) {
        scale = 0.02;
    }

    this.size = new THREE.Vector3(scale, scale, scale);
    this.modelscale = new THREE.Vector3(scale, scale, scale);
    this.position.x = x;
    this.position.z = z;
    this.pickerId = '';
    this.type = type;
    this.picking = type == 1? true : false;
    this.catchingFish = false;
    this.timeout = 1;
    /**
     * Type 0 = supplies
     * Type 1 = sea animals
     * Type 2 = static supplies like shells
     * Type 3 = island animal
     */

    // client side visuals
    if (this.type === 0) {
        this.baseGeometry = geometry.boat;
        //this.baseMaterial = materials.boat;
        this.baseMaterial = materials.crate;
    }

    if (this.type === 1) {
        this.baseModel = models.fish;
        this.modeloffset = vectors.modeloffsetFishShellClam;
    }

    if (this.type === 2) {
        if (Math.round(Math.random())) {
            this.baseModel = models.shell;
            this.modeloffset = vectors.modeloffsetFishShellClam;
        } else {
            this.baseModel = models.clam;
            this.modeloffset = vectors.modeloffsetFishShellClam;
            this.modelscale = new THREE.Vector3(0.03, 0.03, 0.03);
        }

    }

    if (this.type === 3) {
        this.baseModel = models.crab;
        this.modeloffset = vectors.modeloffsetCrab;
        this.modelrotation = new THREE.Vector3(0, Math.PI, 0);
    }

    if (this.type === 4) {
        this.baseModel = models.chest;
        //this.baseMaterial = materials.boat;
        //this.baseMaterial = materials.chest;
    }

    if (this.type <= 1 || this.type === 4) {
        this.floattimer = this.type == 0 ? Math.random() * 5 : (Math.random() * 5 + 0.5);
        this.rotationspeed = Math.random() * 0.5 + 0.5;
    } else {
        this.floattimer = 1;
        this.rotationspeed = 0;
    }
}

Pickup.prototype.randomTime = function (min, max) {
    return (Math.floor(Math.random() * (max - min)) + min) * 1000;
};

Pickup.prototype.logic = function (dt) {
};

Pickup.prototype.timeCounters = {};

Pickup.prototype.dockedLogic = function () {
        var fps = 0.5;

        if (this.timeCounters.dockedLogic === undefined) {
            this.timeCounters.dockedLogic = {
                time: performance.now(),
                previousTime: performance.now(),
            };
        } else {
            this.timeCounters.dockedLogic.time = performance.now();
        }

        if (this.timeCounters.dockedLogic.time - this.timeCounters.dockedLogic.previousTime > 1000 / fps) {
            this.timeCounters.dockedLogic.previousTime = this.timeCounters.dockedLogic.time;
            requestAnimationFrame(function () {
                for (var id in entities) {
                    var $this = entities[id];
                    if (
                        $this.netType === 4 &&
                        ($this.type === 2 || $this.type === 3)
                    ) {
                        var Raycaster = new THREE.Raycaster();
                        var origin;
                        var direction;
                        var height = 100;
                        var object;
                        var collision;
                        var objects = [];
                        var min = {
                            object: undefined,
                            height: height,
                        };
                        var i = 0;
                        var y = 0;

                        if (entities) {
                            direction = new THREE.Vector3(0, -1, 0);
                            origin = $this.geometry.position.clone();
                            origin.set(origin.x, height, origin.z);

                            Raycaster.set(origin, direction);

                            for (var k in entities) {
                                if (entities[k].netType === 5) {
                                    objects.push(entities[k].geometry.children[0]);
                                }
                            }

                            collision = Raycaster.intersectObjects(objects);

                            if (collision.length > 0) {
                                for (; i < collision.length; i++) {
                                    if (collision[i].distance < min.height) {
                                        min = {
                                            height: collision[i].distance,
                                            object: collision[i].object,
                                        };
                                    }
                                }

                                y = height - min.height;
                            }

                            $this.position.y = y;
                            $this.actualY = y;
                            $this.geometry.position.setY(y);
                        }
                    }
                }

            });

        }

    };

Pickup.prototype.clientlogic = function (dt) {
    this.floattimer += dt * 3;
    this.geometry.rotation.x += dt * this.rotationspeed;
    this.geometry.rotation.z += dt * this.rotationspeed;

    if (this.picking == true && entities[this.pickerId]) {

        // Reduce cargo scale and move it towards player
        if (entities[this.pickerId].geometry) {
            var pickerPos = entities[this.pickerId].geometry.getWorldPosition();

            if (this.type === 0 || this.type === 4) {
                this.geometry.translateOnAxis(this.geometry.worldToLocal(pickerPos), 0.05);
                this.geometry.scale.set(this.geometry.scale.x - 0.05, this.geometry.scale.y - 0.05, this.geometry.scale.z - 0.05);
                if(myPlayer && this.pickerId == myPlayer.id && this.geometry.scale.x <= 0.05 && this.geometry.scale.x > 0)
                {
                    ui.playAudioFile(false,'get-crate');
                }
            }

            if (this.type === 1) {
                if (!this.catchingFish)
                    this.geometry.position.y += 0.5
                else
                    this.geometry.translateOnAxis(this.geometry.worldToLocal(pickerPos), 0.05);

                if (this.geometry.position.y >= 20)
                {
                    this.catchingFish = true;
                    if(myPlayer && this.pickerId == myPlayer.id)
                        ui.playAudioFile(false,'catch-fish');
                }

                this.geometry.scale.set(this.geometry.scale.x - 0.009, this.geometry.scale.y - 0.009, this.geometry.scale.z - 0.009);
            }

            if (this.type === 2) {
                this.geometry.translateOnAxis(this.geometry.worldToLocal(pickerPos), 0.05);
                this.geometry.scale.set(this.geometry.scale.x - 0.05, this.geometry.scale.y - 0.05, this.geometry.scale.z - 0.05);

                if ((entities[this.pickerId] !== undefined && entities[this.pickerId].gold > 500  &&
                (!entities[this.pickerId].ownsCannon || !entities[this.pickerId].ownsFishingRod ||
                    (entities[this.pickerId].parent !== undefined &&
                    entities[this.pickerId].parent.netType != 1))
                ))
                {
                    ui.hideSuggestionBox = false;
                }
            }

            if (this.type === 3) {
                this.geometry.translateOnAxis(this.geometry.worldToLocal(pickerPos), 0.05);
                this.geometry.scale.set(this.geometry.scale.x - 0.05, this.geometry.scale.y - 0.05, this.geometry.scale.z - 0.05);
                
                if(myPlayer && this.pickerId == myPlayer.id)
                    ui.playAudioFile(false,'catch-crab');

                if ((entities[this.pickerId] !== undefined && entities[this.pickerId].gold > 500  &&
                (!entities[this.pickerId].ownsCannon || !entities[this.pickerId].ownsFishingRod ||
                    (entities[this.pickerId].parent !== undefined &&
                    entities[this.pickerId].parent.netType != 1))
                ))
                {
                    ui.hideSuggestionBox = false;
                }
            }
        }

        // Send message to server to delete box if it's grabbed by player
        /*if (this.geometry.scale.x <= 0 || this.geometry.scale.y <= 0 || this.geometry.scale.z <= 0) {
            socket.emit('deletePickup', this.id);
        }*/

    } else {
        if (this.type <= 1) {
            //this.geometry.position.set(this.position.x, 0.2 + Math.sin(this.floattimer) * 0.2, this.position.z);
        }

        if (this.type === 2 || this.type === 3) {
            // this.setName();
            this.dockedLogic();
        }

        if (this.type === 3) {
            if (this.geometry !== undefined) {
                if (
                    Math.round(this.geometry.position.x) !== Math.round(this.position.x) ||
                    Math.round(this.geometry.position.z) !== Math.round(this.position.z)
                ) {
                    this.geometry.lookAt(this.position.x, this.actualY || this.position.y, this.position.z);

                    if (Math.round(this.geometry.position.x) !== Math.round(this.position.x)) {
                        this.geometry.position.setX(
                            lerp(
                                this.geometry.position.x,
                                this.position.x,
                                0.01
                            )
                        );
                    }

                    if (Math.round(this.geometry.position.z) !== Math.round(this.position.z)) {
                        this.geometry.position.setZ(
                            lerp(
                                this.geometry.position.z,
                                this.position.z,
                                0.01
                            )
                        );
                    }

                }
            }
        }
    }

    // if (this.PickupSize == 0) {

    //     this.geometry.scale.y = (this.timeout < 0.5 ? Ease.easeOutQuad(this.timeout * 2) : 1.0 - Ease.easeInQuint((this.timeout - 0.5) * 2)) * 3;

    //     var quad = Ease.easeOutQuad(this.timeout)
    //     this.geometry.scale.x = 1.5 - quad
    //     this.geometry.scale.z = 1.5 - quad
    // }

};

Pickup.prototype.setName = function () {
    if (this.geometry !== undefined) {
        if (this.label === undefined) {
            // Set the name
            this.label = new THREE.TextSprite({
                textSize: 3,
                redrawInterval: CONFIG.Labels.redrawInterval,
                texture: {
                    text: this.id,
                    fontFamily: CONFIG.Labels.fontFamily,
                },
                material: {
                    color: labelcolors.player,
                    fog: false,
                },
            });

            this.label.name = 'label';
            this.label.position.set(0, 3, 0);

            this.geometry.add(this.label);
        }

        this.label.material.map.text = this.id;

    }

};

Pickup.prototype.getTypeSnap = function () {
    var snap = {
        s: this.pickupSize,
        p: this.picking,
        i: this.pickerId,
        t: this.type,

    };
    return snap;
};

Pickup.prototype.getTypeDelta = function () {

    if (this.type == 1)
    {
        if (!this.spawnPacket) {
            this.spawnPacket = true;
            return this.getTypeSnap();
        }

        return undefined;
    }
    else
    {
        var delta = {
            s: this.deltaTypeCompare('s', this.pickupSize),
            p: this.deltaTypeCompare('p', this.picking),
            i: this.deltaTypeCompare('i', this.pickerId),
            t: this.deltaTypeCompare('t', this.type),
        };
        if (isEmpty(delta)) {delta = undefined;}

        return delta;
    }

};

// function that parses a snapshot
Pickup.prototype.parseTypeSnap = function (snap) {
    if (snap.s !== undefined && snap.s != this.pickupSize) {this.pickupSize = parseInt(snap.s);}

    if (snap.p !== undefined && snap.p != this.picking) {this.picking = parseBool(snap.p);}

    if (snap.i !== undefined && snap.i != this.pickerId) {this.pickerId = snap.i;}

    if (snap.t !== undefined && snap.t != this.type) {this.type = parseInt(snap.t);}

};

// function that parses a snapshot
Pickup.prototype.onDestroy = function () {

    // makre sure to also call the entity ondestroy
    Entity.prototype.onDestroy.call(this);

    if (pickups[this.id]) {
        delete pickups[this.id];
    }
};

// PLayers are entities, check core_entity.js for the base class
Landmark.prototype = new Entity();
Landmark.prototype.constructor = Landmark;

function Landmark(type, x, z, config) {

    this.createProperties();

    this.name = config.name || ``;

    this.goodsPrice = config.goodsPrice;

    // Netcode type.
    this.netType = 5;

    // Landmark type.
    this.landmarkType = type;
    
    // Docking / anchoring
    this.dockType = 1;
    this.dockRadius = config.dockRadius;
    this.spawnPlayers = config.spawnPlayers;
    this.onlySellOwnShips = config.onlySellOwnShips;

    // Net data.
    this.sendDelta = false;
    this.sendSnap = false;
    this.sendCreationSnapOnDelta = true;

    // Size of a Landmark.
    this.size = new THREE.Vector3(this.dockRadius, 20, this.dockRadius);

    this.position.x = x;
    this.position.z = z;
    this.collisionRadius = 30;

    // Clientside visuals.
    this.baseGeometry = geometry.island;
    this.baseMaterial = materials.colorset;
    if(this.name == `Jamaica`) {
        this.palm = new THREE.Mesh(geometry.palm, materials.colorset);
        this.palm.position.set(850, 0, 850);

        this.palm.scale.x = 8;
        this.palm.scale.y = 8;
        this.palm.scale.z = 8;

        scene.add(this.palm);
    }

    // Christmas snowman + tree.
    models.elka.position.set(860,2,860);
    models.elka.scale.x = 0.35;
    models.elka.scale.y = 0.35;
    models.elka.scale.z = 0.35;

    models.snowman.position.set(880,38,885);
    models.snowman.rotation.set(0,-500,0);

    models.snowman.scale.x = 0.17;
    models.snowman.scale.y = 0.17;
    models.snowman.scale.z = 0.17;

    scene.add(models.elka, models.snowman);

    let modelscale = this.dockRadius / 10 / 8 * 9;
  
    this.modelscale.set(modelscale, modelscale, modelscale);
    this.modeloffset.set(0, 1, 0);

    this.visualCue = new THREE.Mesh(new THREE.RingBufferGeometry(this.dockRadius - 1, this.dockRadius, 30), materials.islandradius);
    this.visualCue.rotation.x = - Math.PI / 2;

    this.visualCue.position.set(this.position.x, 1, this.position.z);
    this.wavetimer = 0;

    scene.add(this.visualCue);
    this.setName(this.name);
}

Landmark.prototype.setName = function(name) {
    if(this.geometry != undefined) {
        if(this.label == undefined) {
            // Set the crews name
            this.label = new THREE.TextSprite({
                textSize: 12,
                redrawInterval: CONFIG.Labels.redrawInterval,
                texture: {
                    text: name,
                    fontFamily: CONFIG.Labels.fontFamily,
                },
                material: {
                    color: 0x5e9628,
                    fog: false,
                }
            });

            this.label.name = `label`;
            this.label.position.set(0, 42, 0);
            this.geometry.add(this.label);
        }

        this.label.material.map.text = name;
        this.label.visible = this.inRange;
    }

    this.name = name;
}

Landmark.prototype.getTypeSnap = () => {
    let snap = {
        t: this.landmarkType,
        name: this.name,
        dockRadius: this.dockRadius
    }
    return snap;
}

// function that parses a snapshot
Landmark.prototype.parseTypeSnap = function(snap) {
    if(snap.t != undefined) this.pickupSize = parseInt(snap.t);
}

Landmark.prototype.clientlogic = dt => {
    this.wavetimer += dt;

    let scale = 0.5 + Math.sin(this.wavetimer) * 0.5;
    water.position.y = 0.1 + scale * 0.5;
}

Landmark.prototype.logic = dt => {
    // If the landmark is dockable (rocks etc. don't have docks).
    if(this.dockType > 0) return; // Does nothing; is the func necessary?
}

Landmark.prototype.isWithinDockingRadius = (x, z) => {
    return distance({ x, z }, this.position) < this.dockRadius - 2;
}

Projectile.prototype = new Entity();
Projectile.prototype.constructor = Projectile;

function Projectile(shooter) {
    this.createProperties();

    // Netcode type.
    this.netType = 2;

    // Size of a projectile.
    this.size = new THREE.Vector3(0.3, 0.3, 0.3);
    
    // Projectiles don't send a lot of delta data.
    this.sendDelta = false;
    this.sendSnap = false;
    this.sendCreationSnapOnDelta = true;
    this.muted = [`x`, `z`];
    this.shooterid = ``;
    this.shooterStartPos = new THREE.Vector3(); // Initial world position of shooter.
    this.reel = false;
    this.impact = undefined;

    this.type = -1; // 0 = cannon ball, 1 = fishing hook.

    // Duration of projectile being airborne.
    this.airtime = 0;

    // This is a flag that is used to make sure the info is sent instantly once hte ball spawns.
    this.spawnPacket = false;

    // Setup references to geometry and material.
    this.setProjectileModel = true;

    this.particletimer = 0;
    this.startPoint = new THREE.Vector3(0, 0, 0);
    this.endPoint = new THREE.Vector3(0, 0, 0);
}

Projectile.prototype.logic = function(dt) {
    // Remove if the shooter does not exist.
    if(this.shooterid == ``
    || entities[this.shooterid] == undefined
    || (entities[this.shooterid] != undefined
    && this.type != -1
    && this.type != entities[this.shooterid].activeWeapon)) {
        if(this.impact) this.impact.destroy = true;
        removeEntity(this);
        return;
    }

    if(entities[this.shooterid] != undefined && entities[this.shooterid].use == false) entities[this.shooterid].isFishing = false;

    if(this.position.y >= 0) {
        // Gravity is acting on the velocity.
        this.velocity.y -= 25.0 * dt;
        this.position.y += this.velocity.y * dt;
    }

    if(entities[this.shooterid] != undefined && entities[this.shooterid].parent) {
        let playerPos = entities[this.shooterid].worldPos();

        // If the player is on a boat, don't destroy the fishing rod if they are moving unless it's far from the player.
        if(entities[this.shooterid].parent != undefined && entities[this.shooterid].parent.netType == 5) {
            if(playerPos.z.toFixed(2) != this.shooterStartPos.z.toFixed(2)
            && playerPos.x.toFixed(2) != this.shooterStartPos.x.toFixed(2)) {
                this.reel = true;
                entities[this.shooterid].isFishing = false;
            }
        }
        else {
            let fromPlayerToRod = playerPos.distanceTo(this.shooterStartPos);
            if(fromPlayerToRod >= 40) {
                this.reel = true;
                entities[this.shooterid].isFishing = false;
            }
        }
    }

    if(this.position.y < 10) {
        // If the cannonball is below surface level, remove it.
        let hasHitBoat = false;

        // If boat was hit or we fall in water, remove.
        if(this.position.y < 0 || hasHitBoat) {

            // If boat was hit, shooter does not exist, shooter's weapon is not that of the impact's parent, or impact is outside of the world boundary, remove the impact.
            if(this.reel
            || this.shooterid == ``
            || entities[this.shooterid] == undefined
            || entities[this.shooterid].use == true
            || entities[this.shooterid].activeWeapon == 0
            || this.position.x > worldsize
            || this.position.z > worldsize
            || this.position.x < 0
            || this.position.z < 0) {
                if(this.impact) this.impact.destroy = true;
                removeEntity(this);
            }
            else {
                this.velocity.x = 0;
                this.velocity.z = 0;
                entities[this.shooterid].isFishing = true;

                if(myPlayer && this.shooterid == myPlayer.id) ui.playAudioFile(false, `fishing`);
                entities[this.shooterid].isFishing = true;
            }
        }
    }
    this.airtime += dt;
}

Projectile.prototype.clientlogic = function(dt) {
    // Check if we didn't set a model yet.
    let shootingPlayer = entities[this.shooterid];

    if(!shootingPlayer || (shootingPlayer && shootingPlayer.parent && shootingPlayer.parent.hp <= 0)) {
        scene.remove(this.geometry);
        if(this.line) {
            scene.remove(thisline);
            this.line.geometry.dispose();
        }
    }

    if(shootingPlayer && this.setProjectileModel) {
        scene.remove(this.geometry);

        if(shootingPlayer.activeWeapon == 0) this.geometry = new THREE.Sprite(materials.cannonball);
        else if(shootingPlayer.activeWeapon == 1) {
            this.baseGeometry = geometry.hook;
            this.baseMaterial = materials.hook;

            let lineGeometry = base_geometries.line.clone();

            lineGeometry.vertices.push(this.startPoint);
            lineGeometry.vertices.push(this.endPoint);

            this.line = new THREE.Line(lineGeometry, new THREE.MeshBasicMaterial({ color: 0x000 }));
            sceneLines[this.id] = this.line;

            this.linefrustumCulled = false;
            if(entities[this.shooterid].weapon) {
                let boundariesBox = new THREE.Box3();
                boundariesBox.setFromObject(entites[this.shooterid].weapon);
                this.startPoint.set(boundariesox.max.x - 0.5, booundariesBox.max.y, boundariesBox.max.z - 0.5);
            }

            scene.add(this.line);
            this.geometry = new THREE.Mesh(this.baseGeometry, this.baseMaterial);
        }
        sceneCanBalls[this.id] = this.geometry;
        scene.add(this.geometry);
        this.setProjectileModel = false;
    }

    this.geometry.position.set(this.position.x, this.position.y, this.position.z);

    // Check if we have the fishing line, adjust its position dynamically.
    if(this.line) {
        // Make fishing line follow the rod position.
        if(shootingPlayer && shootingPlayer.weapon) {
            let boundariesBox = new THREE.Box3();
            boundariesBox.setFromObject(entities[this.shooterid].weapon);
            this.startPoint.set(boundariesBox.max.x - 0.5, boundariesBox.max.y, boundariesBox.max.z - 0.5);
        }
        this.endPoint.set(this.position.x, this.position.y, this.position.z);
        this.line.geometry.verticesNeedUpdate = true;

        this.geometry.rotation.y += 1.5 * dt;        
    }
    else if(shootingPlayer && shootingPlayer.activeWeapon == 0) {
        this.particletimer -= dt;
        if(this.particletimer < 0) {
            let byPlayer = myPlayer && this.shooterid == myPlayer.id;
            let friendly = myPlayer && myPlayer.parent && myPlayer.parent.children[this.shooterid];
            
            this.particletimer = 0.04;
            createParticle({
                vx: 0,
                vy: 0,
                vz: 0,
                x: this.position.x,
                z: this.position.z,
                y: this.position.y,
                w: byPlayer ? 0.7: 0.4,
                h: byPlayer ? 0.7: 0.4,
                d: byPlayer ? 0.7: 0.4,
                gravity: 0,
                duration: 2,
                rotaSpeed: Math.random() * 5,
                sizeSpeed: -1.8,
                material: byPlayer ? materials.smoke_player: (friendly ? materials.smoke_friendly: materials.smoke_enemy),
                geometry: base_geometries.box
            });
        }
    }
}

Projectile.prototype.getTypeDelta = function () {
    if(!this.spawnPacket) {
        this.spawnPacket = true;
        return this.getTypeSnap();
    }
    return undefined;
}

// Function that parses a snapshot.
Projectile.prototype.parseTypeSnap = function(snap) {
    if(snap.vx !== undefined) this.velocity.x = parseFloat(snap.vx);
    if(snap.vy !== undefined) this.velocity.y = parseFloat(snap.vy);
    if(snap.vz !== undefined) this.velocity.z = parseFloat(snap.vz);
    if(snap.x !== undefined) this.position.x = parseFloat(snap.x);
    if(snap.z !== undefined) this.position.z = parseFloat(snap.z);
    if(snap.y !== undefined) this.position.y = parseFloat(snap.y);
    if(snap.i !== undefined && snap.i != this.shooterid) this.shooterid = snap.i;
    if(snap.r !== undefined && snap.r != this.reel) this.reel = parseBool(snap.r);
    if(snap.sx !== undefined) this.shooterStartPos.x = parseFloat(snap.sx);
    if(snap.sz !== undefined) this.shooterStartPos.z = parseFloat(snap.sz);
}

// These are functions that entities only have on the client (like ThreeJS bodies).
Entity.prototype.clientInit = () => {
    this.createBody();
}

Entity.prototype.createBody = () => {
    // Create base object.
    this.geometry = new THREE.Object3D();
    screen.add(this.geometry);
    this.geometry.rotation.order = `YXZ`;

    if (this.baseGeometry) {
        this.body = new THREE.Mesh(this.baseGeometry, this.baseMaterial);
        this.body.scale.set(this.modelscale.x, this.modelscale.y, this.modelscale.z);
        this.body.position.set(this.modeloffset.x, this.modeloffset.y, this.modeloffset.z);
        this.body.rotation.set(this.modelrotation.x, this.modelrotation.y, this.modelrotation.z);
        this.geometry.add(this.body);
        this.geometry.position.x = this.position.x;
        this.geometry.position.y = this.position.y;
        this.geometry.position.z = this.position.z;
    }

    if (this.baseModel) {
        this.body = this.baseModel.clone();
        this.body.scale.set(this.modelscale.x, this.modelscale.y, this.modelscale.z);
        this.body.position.set(this.modeloffset.x, this.modeloffset.y, this.modeloffset.z);
        this.body.rotation.set(this.modelrotation.x, this.modelrotation.y, this.modelrotation.z);
        this.geometry.add(this.body);
        this.geometry.position.x = this.position.x;
        this.geometry.position.y = this.position.y;
        this.geometry.position.z = this.position.z;
    }

    // If this is the player, then we add the camera.
    if(this.isPlayer) {
        if(camera.parent) camera.parent.remove(camera);

        camera.position.set(0, 1, 5);
        
        camera.rotation.z = 0;
        camera.rotation.y = 0;
        camera.rotation.x = -0.4;

        this.geometry.add(camera);
        this.geometry.add(this.crosshair);
    }

    if(this.netType == 0) this.setPlayerBody();
    this.clientlogic(0);
}

Entity.prototype.onClientDestroy = () => {
    if(this.parent) this.parent.geometry.remove(this.geometry);
    scene.remove(this.geometry);

    if(!this.line) {
        scene.remove(this.line);
        this.line.geometry.dispose();
    }
}

Entity.prototype.clientlogic = dt => {
    this.geometry.psoition.set(this.position.x, this.position.y, this.position.z);
    this.goemetry.rotation.y = this.rotation;
}

let removeEntity = entity => {
    if(entities.hasOwnProperty(entity.id)) {
        entity.onDestroy();
        delete entities[entity.id];
    }
}

let setShipModels = () => {
    for(let i in boatTypes) {
        let boat = boatTypes[i];
        
        if(models[boat.body]) boat.body = models[boat.body].getObjectByName(`body`);
        if(boat.sail && models[boat.sail]) boat.sail = models[boat.sail].getObjectByName(`sail`);
        if(boat.mast && models[boat.mast]) boat.mast = models[boat.mast].getObjectByName(`mast`);
    }
}

Boat.prototype.changeBoatModel = function(id) {
    if(!this.geometry || !boatTypes[id]) return;

    if(this.body) this.geometry.remove(this.body);
    if(this.sail) this.geometry.remove(this.sail);
    if(this.mast) this.geometry.remove(this.mast);

    // Body.
    this.body = boatTypes[id].body.clone();
    this.body.material = boatTypes[id].body.material.clone();
 
    this.body.material.transparent = true;
 
    this.body.scale.set(boatTypes[id].scale[0], boatTypes[id].scale[1], boatTypes[id].scale[2]);
    this.body.position.set(boatTypes[id].offset[0], boatTypes[id].offset[1], boatTypes[id].offset[2]);
    this.body.rotation.set(boatTypes[id].rotation[0], boatTypes[id].rotation[1], boatTypes[id].rotation[2]);
 
    this.geometry.add(body);

    if (boatTypes[id].sail) {
        this.sail = boatTypes[id].sail.clone();
        this.sail.material = boatTypes[id].sail.material.clone();
        
        this.sail.material.transparent = true;

        this.sail.scale.set(boatTypes[id].scale[0], boatTypes[id].scale[1], boatTypes[id].scale[2]);
        this.sail.position.set(boatTypes[id].offset[0], boatTypes[id].offset[1], boatTypes[id].offset[2]);
        this.sail.rotation.set(boatTypes[id].rotation[0], boatTypes[id].rotation[1], boatTypes[id].rotation[2]);

        this.geometry.add(this.sail);
    }

    if (boatTypes[id].mast) {
        this.mast = boatTypes[id].mast.clone();
        this.mast.material = boatTypes[id].mast.material.clone();

        this.mast.material.transparent = true;

        this.mast.scale.set(boatTypes[id].scale[0], boatTypes[id].scale[1], boatTypes[id].scale[2]);
        this.mast.position.set(boatTypes[id].offset[0], boatTypes[id].offset[1], boatTypes[id].offset[2]);
        this.mast.rotation.set(boatTypes[id].rotation[0], boatTypes[id].rotation[1], boatTypes[id].rotation[2]);

        this.geometry.add(this.mast);
    }
}

Boat.prototype.docking = stateId => {
    let shipId = this.shipclassId;
    let isPlayer = myPlayer && this == myPlayer.parent;
}

let lookingDownLimit = -1;
let lookingUpLimit = 1;

let currControls = new GameControls();
let lastCheck = Date.now();

// Used to handle refreshing of the krew list.
let refreshTimer = 0;

let playerModels = [];
let PlayerRaycaster = new THREE.Raycaster();

let setPlayerModels = () => {
    materials.dog_1 = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        map: textures.dog_diffuse
    });

    playerModels.push({
        body: new THREE.Mesh(geometry.dog_1, materials.dog_1),
        scale: new THREE.Vector3(0.04, 0.04, 0.04),
        offset: new THREE.Vector3(0, -0.4, 0.8),
        rotation: new THREE.Vector3(0.4, Math.PI, 0)
    });
}

Player.prototype.timeCounters = {}
Player.prototype.namesLogic = () => {
    if(this.isPlayer) {
        let fps = 5;

        if(!this.timeCounters.namesLogic) {
            this.timeCounters.namesLogic = {
                time: performance.now(),
                previousTime: performance.now()
            }
        }
        else this.timeCounters.namesLogic.time = performance.now();

        if(this.timeCounters.namesLogic.time - this.timeCounters.namesLogic.previousTime > 1e3 / fps) {
            this.timeCounters.namesLogic.previousTime = this.timeCounters.namesLogic.time;
            requestAnimationFrame(() => {
                // Call the getWorldPosition methof of the camera just once for optimization.
                let cameraWorldPosition = camera.getWorldPosition();

                // Check distance between each player / boat and camera in world position, and set if it is in the players vision range.
                for(let id in entities) {
                    if(entities[id].netType == 0
                    || entities[id].netType == 1
                    || entities[id].netType == 5) {
                        let actualDistance = disatnce(cameraWorldPosition, entities[id].geometry.getWorldPosition());
                        let length = CONFIG.Labels.distanceMultiplier[entities[id].netType];

                        entities[id].inRange = actualDistance <= length;

                        // Do not set this property if it is not used for better performance.
                        if(CONFIG.setProperties.inVision) entities[id].inRange && inPlayersVision(entities[id], camera);

                        if(entities[id].netType == 0) entities[id].setName(entities[id].name);
                        if(entities[id].netType == 1) entities[id].setName(entities[id].crewName);
                        if(entities[id].netType > 1) entities[id].setName(entities[id].name);
                    }
                }
            });
        }
    }
}

Player.prototype.dockedLogic = () => {
    if(this.isPlayer) {
        let fps = 20;
        let _this = this;

        if(!this.timeCounters.dockedLogic) {
            this.timeCounters.dockedLogic = {
                time: performance.now(),
                previousTime: performance.now()
            }
        }
        else this.timeCounters.dockedLogic.time = performance.now();

        if(this.timeCounters.dockedLogic.time - this.timeCounters.dockedLogic.previousTime > 1e3 / fps) {
            this.timeCounters.dockedLogic.previousTime = this.timeCounters.dockedLogic.time;

            let origin, direction, object, collision;
            let height = 100;
            let objects = [];
            let min = {
                object: undefined,
                height
            }

            let i, y = 0;

            if(_this.parent && entities) {
                direction = new THREE.Vector3(0, -1, 0);
                origin = _this.geometry.getWorldPosition().clone();
                origin.set(origin.x, height, origin.z);

                PlayerRaycaster.set(origin, direction);

                if(_this.parent) {
                    if(_this.parent.anchorIslandId && entities[_this.parent.anchorIslandId]) {
                        objects.push(entities[_this.parent.anchorIslandId].geometry.children[0]);
                        if(entities[_this.parent.id].palm) objects.push(entities[_this.parent.id].palm);
                    }
                    if(entities[_this.parent.id]) {
                        if(entities[_this.parent.id].netType == 5) {
                            objects.push(entities[_this.parent.id].geometry.children[0]);
                            if(entities[_this.parent.id].palm) objects.push(entities[_this.parent.id].palm)
                        }
                        if(entities[_this.parent.id].netType == 1 && entities[_this.parent.id].mast) objects.push(entities[_this.parent.id].geometry.getObjectByName(`body`));
                    }
                }

                collision = PlayerRaycaster.intersectObjects(objects);

                if(collision.length > 0) {
                    for(; i < collision.length; i++) {
                        if(collision[i].disatnce < min.height) {
                            min = {
                                height: collision[i].distance,
                                object: collision[i].object
                            }
                        }
                    }
                    y = height - min.height;
                }

                if(min.object && min.object.name == `body`) {
                    y -= boatTypes[entities[_this.parent.id].shipclassId].baseheight;
                    right = _this.position.x < 0;
                    halfWidth = boatTypes[entities[_this.parent.id].shipclassId].width / 2;

                    if(_this.position.x != 0) {
                        if(_this.isCaptain) y += Math.abs(entities[_this.parent.id].leanvalue / 2);
                        else {
                            if(right) y -= (entities[_this.parent.id].leanvalue / 2) * (Math.abs(_this.position.x) / halfWidth);
                            else y += (entities[_this.parent.id].leanvalue / 2) * (Math.abs(_this.position.x) / halfWidth);
                        }
                    }
                }
                if(min.object && min.object.name != `body` && entities[_this.parent.id] && entities[_this.parent.id].netType == 1) y -= boatTypes[entities[_this.parent.id].shipclassId].baseheight;
                _this.position.y = y;
            }
        }
    }
}

Player.prototype.clientlogic = dt => {
    if(this.isPlayer && !isEmpty(this.notificationsHeap)) this.notifications();
    this.namesLogic();

    // If this is the player, walk via keyboard.
    if(this.isPlayer) {
        this.walkForward = 0;
        this.walkSideward = 0;

        if(keys_walkFwd) this.walkForward = 1;
        if(keys_walkBwd) this.walkForward = -1;
        if(keys_walkRight) this.walkSideward = 1;
        if(keys_walkLeft) this.walkSideward = -1;

        this.jumping = keys_jump ? 1: 0;

        // Respawn bug workaround.
        if(this.state == 1 && !$(`#game-over-modal`).is(`:visible`)) $(`#game-over-modal`).modal(`show`);

        // If the player is respawning, attach the camera to it and set its state to alive.
        if(this.state == 2) {
            camera.position.set(0, 1, 5);

            camera.rotation.z = 0;
            camera.rotation.y = 0;
            camera.rotation.x = -0.4;

            this.geometry.add(camera);
            this.state = 0;
        }

        if(camera.parent == this.geometry) {
            let lookingDownOffset;
            let cameraPosition = new THREE.Vector3();

            if(this.activeWeapon != 2) {
                // To overcome discrepancy between the cannon's angle of aim, and the actual angle of the projectile.
                if($(`#fps-mode-button`).is(`:checked`)) {
                    lookingDownOffset = 2 - Math.max(controls.cameraX, 2);
                    cameraPosition = new THREE.Vector3(
                        camera.position.x,
                        1.5 + Math.min(8, Math.max(0, controls.cameraX * 0.5)),
                        1.21 + (lookingDownOffset * 0.21)
                    );
                }
                else {
                    lookingDownOffset = 0.2 - Math.max(controls.cameraX * 0.5);
                    cameraPosition = new THREE.Vector3(
                        camera.position.x,
                        2 + Math.min(8, Math.max(0, controls.cameraX * 10)),
                        8 + (lookingDownOffset * 8)
                    );
                }

                if(camera.zoom == 2) {
                    camera.zoom = 1;
                    camera.updateProjectionMatrix();

                    screen.fog.density = 0.007;
                    ui.showHideSpyglassBlackout(`hide`);
                }
            }
            else if(this.activeWeapon == 2) {
                ui.showHideSpyglassBlackout(`show`);
                lookingDownOffset = 0.4 - Math.max(controls.cameraX, 0.2);
                cameraPosition = new THREE.Vector3(
                    camera.position.x,
                    2,
                    -0.01
                );
                screen.fog.density = 0.005;
                camera.zoom = 2;
                camera.updateProjectionMatrix();
            }

            // myPlayer's cannon rotation.
            this.goemetry.rotation.x = lerp(this.geometry.rotation.x, Math.min(lookingUpLimit, Math.max(-1, controls.cameraX + this.rotationOffset)), 0.8);
            this.rotation = controls.cameraY;

            camera.position.lerp(cameraPosition, 1);
            camera.rotation.x = lerp(camera.rotation.x, lookingDownOffset, 1);

            this.pitch = controls.cameraX;

            this.crosshair.position.x = camera.position.x;
            this.crosshair.position.y = camera.position.y + 0.01;
            this.crosshair.position.z = camera.position.z - 0.3;
        }

        if(controls.isMouseLookLocked) this.use = controls.lmb;
        else this.use = false;
    }

    // Jumping.
    if(this.jumping == 1) this.tryJump();

    this.jumpVel = this.fly == 0 ? this.jumpVel - 80 * dt: Math.max(0, this.jumpVel - 80 * dt);
    this.jump += this.jumpVel * dt;

    if(this.jump < 0) this.jump = 0.0;

    if(this.isPlayer && this.parent) {
        if(this.parent.shipState == 0 || this.parent.shipState == 1) {
            if(this.walkForward != 0) ui.playAudioFile(false, `step-wood01`);
            if(this.walkSideward != 0) ui.playAudioFile(false, `step-wood02`);
        }
        else {
            if(this.walkForward != 0) ui.playAudioFile(false, `step-sand01`);
            if(this.walkSideward != 0) ui.playAudioFile(false, `step-sand02`);
        }
    }

    // Handle movement around the sialdn fi the boat is docked.
    if(this.isPlayer && this.parent && ((this.parent.shipState == 3 || this.parent.shipState == 2 || this.parent.shipState == -1 || this.parent.shipState == 4) || this.parent.netType == 5)) {
        ui.updateKrewList();

        if(!ui.hideSuggestionBox) {
            if(!$(`#shopping-modal`).is(`:visible`) & myPlayer.gold > 500) {
                if($(`#earn-gold`).is(`:visible`)) $(`#earn-gold`).hide();
            }
        }

        let island = entities[this.parent.anchorIslandId || this.parent.id];
        let islandPosition = new THREE.Vector3(0, 0, 0);

        if(this.parent.netType == 5) {
            let playerPosition = this.goemetry.position.clone();

            islandPosition.y = playerPosition.y;

            let distanceFromIsland = playerPosition.distanceTo(islandPosition);
            if(island.dockRadius - 2 < distanceFromIsland) {
                playerPosition.lerp(islandPosition, 1 - ((island.dockRadius - 2.5) / distanceFromIsland));

                playerPosition = island.geometry.localToWorld(playerPosition); // What is this?
                playerPosition = boat.geometry.worldToLocal(playerPosition);

                this.position.x = playerPosition.x;
                this.position.z = playerPosition.z;
            }
        }
    }

    this.dockedLogic();

    this.geometry.position.set(this.position.x, this.position.y + this.jump, this.position.z);
    this.geometry.rotation.y = this.rotation;

    if(this.weapon) {
        if(this.activeWeapon == 1) {
            this.weapon.rotation.x += dt * this.rodRotationSpeed;
            if(this.weapon.rotation.x > 0.75) this.weapon.rotation.x = 0;
        }
        else this.weapon.rotation.x = -this.rotationOffset + 0.1;
    }

    // Check if we turned into the captain (or lost captainship).
    if(this.isCaptain != this.oldCaptainState) {
        if(this.parent && this.isPlayer && !this.isCaptain) {
            ui.showCenterMessage(`You are not the captaina nymore!`, 4, 4e3);
            if(this.parent.shipState == 3 || this.parent.shipState == 4 || this.parent.shipState == -1) {
                $(`#toggle-shop-modal-button`).removeClass(`disabled`).addClass(`enabled`);
                $(`#toggle-krew-list-button`).removeClass(`disabled`).addClass(`enabled`);

                $(`#exit-island-button`).hide();
                $(`#toggle-invite-link-button`).show();
                $(`#quests-button`).show();
            }
            else if(this.parent.shipState == 1) $(`#docking-modal`).hide();
            $(`#abandon-ship-button`).show();
        }

        if(this.parent && this.isPlayer && this.isCaptain) {
            ui.showCenterMessage(`You are the captain now!`, 4, 4e3);
            refreshTimer = 0;

            if(this.parent.shipState == 3 || this.parent.shipState == 4 || this.parent.shipState == -1) {
                $(`#toggle-shop-modal-button`).removeClass(`disabled`).addClass(`enabled`);
                $(`#toggle-krew-list-modal-button`).removeClass(`disabled`).addClass(`enabled`);

                $(`#exit-island-button`).show();
                $(`#toggle-invite-link-button`).show();
                $(`#quests-button`).show();
            }
            else if(this.parent.shipState == 1) $(`#docking-modal`).show();
            $(`#abandon-ship-button`).hide();
        }

        if(this.isCaptain) {
            this.playerBody.add(this.captainHat);
            if(this.label) {
                this.label.material.color = 
                    this.isPlayer ? labelcolors.myself:
                    this.isStaff ? labelcolors.staff:
                    this.isClanMember ? labelcolors.clanmember:
                    this.isCaptain ? labelcolors.captain:
                    labelcolors.player;
            }
        }
    }
}

Player.prototype.tryJump = dt => {
    if(this.fly == 0 && (this.jumpVel > 0.0 || this.jump > 0)) return;
    this.jumpVel = 16;
}

let uiSuggest = {
    setItems: () => {
        if(myPlayer && myPlayer.gold > 500 && (!myPlayer.ownsCannon || myPlayer.ownsFishingRod || (myPlayer.parent && myPlayer.parent.netType != 1))) {}
    }
};

(function (window) {
    var h = hyperapp.h;
    var state = {
        boats: [],
    };
    var actions = {
        boats: function () {
            return function (state) {
                var id;
                var boat;
                var boats = [];
                if (typeof entities === 'object' && entities !== null) {
                    for (id in entities) {
                        boat = entities[id];

                        if (krewListUpdateManually)
                        {
                            if (
                                myPlayer &&
                                boat &&
                                boat.anchorIslandId &&
                                boat.shipState === 4 &&
                                boat.recruiting === true &&
                                boat.isLocked !== true
                            ) {
                                if (
                                    (myPlayer.parent.netType === 1 && boat.anchorIslandId === myPlayer.parent.anchorIslandId) ||
                                    boat.anchorIslandId === myPlayer.parent.id
                                ) {
                                    boats.push(boat);
                                }
                            }
                        }
                        else
                        {
                            if (
                                myPlayer &&
                                boat &&
                                boat.anchorIslandId &&
                                (boat.shipState === 3 || boat.shipState === 2 || boat.shipState === -1 || boat.shipState === 4) &&
                                boat.recruiting === true
                            ) {
                                if (
                                    (myPlayer.parent.netType == 1 && boat.anchorIslandId == myPlayer.parent.anchorIslandId) ||
                                    boat.anchorIslandId == myPlayer.parent.id
                                ) {
                                    boats.push(boat);
                                    $('#docked-krews-count').html(boats.length);
                                }
                            }
                        }

                    }
                }

                boats.sort(
                    function (a, b) {
                        if (a.departureTime === b.departureTime) {
                            return a.id < b.id ? -1 : a.id == b.id ? 0 : 1;
                        }

                        return a.departureTime - b.departureTime;
                    }
                );
                if (boats.length == 0)
                    $('#toggle-krew-list-modal-button').popover('hide');
                //$('#docked-krews-count').html(boats.length);
                return { boats: boats };
            };
        },
    };
    var view = function (state, actions) {
        return h('div', {}, [
            h('table', { class: 'table table-sm' }, [
                h('thead', { class: 'thead-inverse' }, [
                    h('tr', {}, [
                        h('th', {}, 'Krew Name'),
                        h('th', {}, 'Capacity'),
                        h('th'),
                    ]),
                ]),
                h('tbody', {}, state.boats.map(function (boat) {
                    if (myPlayer !== undefined && myPlayer.parent !== undefined && boat !== undefined && entities[boat.captainId] !== undefined) {

                    var test = "'#"+boat.id+"'";
                    $(document).on('click',"#"+boat.id, function() {

                        var id = boat.id;
                        if (
                                           entities[id] === undefined ||
                                           entities[id].maxKrewCapacity == entities[id].krewCount ||
                                           entities[id].captainId === myPlayerId
                                       ) {
                            return;
                        }
                        socket.emit('joinKrew', id, function (callback) {
                            if (callback === 0) {
                                // $('#island-menu-div').show();
                                $('#exit-island-button').hide();
                                $('#toggle-invite-link-button').hide();
                                $('#invite-div').hide();

                                if ($('#departure-modal').is(':visible')) {
                                    $('#departure-modal').hide();
                                }

                                GameAnalytics("addDesignEvent", "Game:Session:JoinedBoat");

                                $("#krew-div").show();
                                $('#abandon-ship-button').show();

                                // if (krewListUpdateManually)
                                // {
                                //     DEPARTINGKREWLISTCOMPONENT.boats();
                                //     $('#toggle-krew-list-modal-button').popover('show');
                                // }
                                // else
                                //     KREWLISTCOMPONENT.boats();
                                //
                                // if ((myPlayer !== undefined && myPlayer.gold > 500  &&
                                // (!myPlayer.ownsCannon || !myPlayer.ownsFishingRod ||
                                //     (myPlayer.parent !== undefined &&
                                //     myPlayer.parent.netType != 1))
                                // ))
                                //     $('#toggle-shop-modal-button').popover('show');
                            }
                            // } else {
                            //     ui.showCenterMessage('You can not join (too much cargo)', 1)
                            // }
                        });
                    });

                        return h('tr', { key: boat.id }, [
                            h('td', {}, [
                                boat.crewName + '(' + boatTypes[boat.shipclassId].name + ')',
                                h('br'),
                                h('small', {}, boat.shipState == 4 ? 'Departing in ' + Math.round(boat.departureTime) + ' seconds' : ''),
                            ]),
                            h('td', {}, boat.krewCount + '/' + boatTypes[boat.shipclassId].maxKrewCapacity),
                            h('td', {}, boat.id === myPlayer.parent.id ? 'My Krew' : h('button', {
                                id: boat.id,
                                class: 'btn btn-primary btn-md',
                                role: 'button',
                                disabled: entities[boat.id] === undefined ||
                                    entities[boat.id].maxKrewCapacity == entities[boat.id].krewCount ||
                                    entities[boat.id].captainId === myPlayerId,

                            }, 'Join')),
                        ]);
                    }
                })),
            ]),
        ]);
    };

        window.KREWLISTCOMPONENT = hyperapp.app(state, actions, view, document.getElementById('krews-list'));
        window.DEPARTINGKREWLISTCOMPONENT = hyperapp.app(state, actions, view, document.getElementById('departing-krews-list'));
})(window);

(function (window) {
    var Store = {
        $shoppingList: $('#shopping-item-list'),
    };

    var GoodsComponent = {
        getList: function () {
            GoodsComponent
                .removeListeners()
                .clearStore()
                .setStore(function () {
                    GoodsComponent
                        .setContent()
                        .setListeners();
                });
        },

        removeListeners: function () {
            if (Store.$html !== undefined) {
                Store.$html.children().off();
                Store.$html.off();
            }

            return GoodsComponent;
        },

        clearStore: function () {
            Object.assign(Store, {
                goodsPrice: {},
                goods: {},
                cargo: 0,
                cargoUsed: 0,
                gold: 0,
                $html: undefined,
                inventory: {},
                stock: {},
            });
            return GoodsComponent;
        },

        setStore: function (callback) {
            if (myPlayer && myPlayer.parent && (myPlayer.parent.netType == 5 || myPlayer.parent.shipState !== 1 && myPlayer.parent.shipState !== 0 )){
                socket.emit('getGoodsStore', function (err, data) {
                    if (err) {
                        console.warn(err);
                    }

                    if (!err) {
                        Object.assign(Store, data);
                    }

                    callback && callback.call && callback();
                });
            }
        },

        setContent: function () {
            var $html = $('<div class="stock"/>');

            if (
              Object.keys(Store.goodsPrice).length === 0  &&
              (myPlayer.parent && myPlayer.parent.netType !== 1)
            ) {
                $html.append(
                  '<div class="col-xs-12 trading">' +
                  '<h5 class="text-warning">You must own a ship, or join a krew before buying supplies</h5>' +
                  '</div>'
                );
            }

            if (Object.keys(Store.goodsPrice).length > 0) {
                $html.append(GoodsComponent.getInventory());
                $html.append(GoodsComponent.getGoods());
            }

            Store.$html = $html;
            Store.$shoppingList.html(Store.$html);
            return GoodsComponent;
        },

        setListeners: function () {
            $('input[type=range]').each(function () {
                inputRange($(this));
            });

            for (var i in Store.inventory) {
                GoodsComponent.setInputRangeListeners(Store.inventory[i], i, 'sell');
            }

            for (var i in Store.stock) {
                GoodsComponent.setInputRangeListeners(Store.stock[i], i, 'buy');
            }

            return GoodsComponent;
        },

        setInputRangeListeners: function ($tr, good, action) {
            var $btn = $tr.find('.btn-' + action);
            var $slider = $tr.find('.ui-slider');
            var $handle = $slider.find('.ui-slider-handle');
            var options = {
                    create: function () {
                        $handle.text($slider.slider('value'));
                    },

                    slide: function (event, ui) {
                        $handle.text(ui.value);
                        var val = (+ui.value * Store.goodsPrice[good]);
                        var sign = (action === 'sell' ?  '+' : '-');

                        $btn.html((val > 0 ? sign : '') + val);
                    },
                };

            if (action === 'sell') {
                options.max = Store.goods[good];
            }

            if (action === 'buy') {
                var max = parseInt(Store.gold / Store.goodsPrice[good]);
                var maxCargo = (Store.cargo - Store.cargoUsed) / goodsTypes[good].cargoSpace;
                var tr = '';

                if (max > maxCargo) {
                    max = maxCargo;
                }

                max = Math.floor(max);
                options.max = max;
            }

            $slider.slider(options);

            $btn.one('click', function (e) {
                e.preventDefault();
                GameAnalytics("addDesignEvent", "Game:Session:Trade");
                if ($slider.slider('value') > 0) {
                    socket.emit('buy-goods', {
                        quantity: $slider.slider('value'),
                        action: action,
                        good: good,
                    }, function (err, data) {
                        if (err) {
                            console.log(err);
                        }

                        if (!err) {
                            myPlayer.gold = data.gold;
                            myPlayer.goods = data.goods;
                        }

                        GoodsComponent.getList();
                    });
                }
            });
        },

        getInventory: function () {
            var html = '';
            var $html;
            var $tbody;

            html += '<div class="col-xs-12 col-sm-6 trading">',
            html += '    <h6>Your ship\'s cargo ' + Store.cargoUsed + '/' + Store.cargo + '</h6>',
            html += '    <table class="table table-sm">',
            html += '        <thead><tr><th>Name</th><th>Quantity</th><th></th><th>Sell</th></tr></thead>',
            html += '        <tbody></tbody>',
            html += '    </table>',
            html += '    <br>',
            html += '</div>';

            $html = $(html);
            $tbody = $html.find('tbody');

            for (var i in Store.goods) {
                if (Store.goods[i] > 0 && Store.goodsPrice[i] !== undefined) {
                    var tr = '';
                    tr += '<tr>';
                    tr += '    <td>';
                    tr += '        ' + i;
                    tr += '        <label>$' + Store.goodsPrice[i] + ' each</label>';
                    tr += '        <label>' + goodsTypes[i].cargoSpace + ' cargo</label>';
                    tr += '    </td>';
                    tr += '    <td>';
                    tr += '        <div class="ui-slider" style="margin-top: 10px">';
                    tr += '            <div class="ui-slider-handle" style="width: 3em;height: 1.6em;top: 50%;margin-top: -.8em;text-align: center;line-height: 1.6em;"></div>';
                    tr += '        </div>';
                    tr += '    </td>';
                    tr += '    <td style="padding-top: 5px">' + Store.goods[i] + '</td>';
                    tr += '    <td>';
                    tr += '        <button class="btn btn-success btn-sm btn-sell">0</button>';
                    tr += '    </td>';
                    tr += '</tr>';

                    Store.inventory[i] = $(tr);
                    $tbody.append(Store.inventory[i]);
                }
            }

            return $html;
        },

        getGoods: function () {
            var html = '';
            var $html;
            var $tbody;

            html += '<div class="col-xs-12 col-sm-6 trading">',
            html += '    <h6>Merchant</h6>',
            html += '    <table class="table table-sm">',
            html += '        <thead><tr><th>Name</th><th>Quantity</th><th></th><th>Buy</th></tr></thead>',
            html += '        <tbody></tbody>',
            html += '    </table>',
            html += '    <br>',
            html += '</div>';

            $html = $(html);
            $tbody = $html.find('tbody');

            for (var i in Store.goodsPrice) {
                if (Store.goods[i] !== undefined) {
                    var max = parseInt(Store.gold / Store.goodsPrice[i]);
                    var maxCargo = (Store.cargo - Store.cargoUsed) / goodsTypes[i].cargoSpace;
                    var tr = '';

                    if (max > maxCargo) {
                        max = maxCargo;
                    }

                    max = Math.floor(max);

                    tr += '<tr>';
                    tr += '    <td>';
                    tr += '        ' + i;
                    tr += '        <label>$' + Store.goodsPrice[i] + ' each</label>';
                    tr += '        <label>' + goodsTypes[i].cargoSpace + ' cargo</label>';
                    tr += '    </td>';
                    tr += '    <td>';
                    tr += '        <div class="ui-slider" style="margin-top: 10px">';
                    tr += '            <div class="ui-slider-handle" style="width: 3em;height: 1.6em;top: 50%;margin-top: -.8em;text-align: center;line-height: 1.6em;"></div>';
                    tr += '        </div>';
                    tr += '    </td>';
                    tr += '    <td style="padding-top: 5px">' + max + '</td>';
                    tr += '    <td>';
                    tr += '        <button class="btn btn-success btn-sm btn-buy">0</button>';
                    tr += '    </td>';
                    tr += '</tr>';

                    Store.stock[i] = $(tr);
                    $tbody.append(Store.stock[i]);
                }
            }

            return $html;
        },
    };

    window.GOODSCOMPONENT = GoodsComponent;
})(window);

(window => {
    let Store = {
        $shoppingList: $(`#shopping-item-list`)
    }

    let ExperiencePointsComponent = {
        keys: {
            53: `fireRate`,
            54: `distance`,
            55: `damage`
        },
        getList: () => {
            if(myPlayer || !myPlayer.parent) return;
            ExperiencePointsComponent
                .removeListeners()
                .clearStore()
                .setStore(() => {
                    ExperiencePointsComponent
                        .setContent()
                        .setListeners();
                });
        },
        removeListeners: () => {
            if(Store.$html) {
                Store.$html.children().off();
                Store.$html.off();
            }
            return ExperiencePointsComponent;
        },
        clearStore: () => {
            Object.assign(Store, {
                $html: undefined,
                points: {},
                originalPoints: 0,
                availablePoints: 0,
                usedPoints: 0,
                allocatedPoints: {},
                pointsTr: {},
                experience: myPlayer ? myPlayer.experience: 0
            });
            return ExperiencePointsComponent;
        },
        setStore: callback => {
            socket.emit(`getExperiencePoints`, (err, data) => {
                if(err) return console.warn(err);
                Object.assign(Store, data);

                if(myPlayer) {
                    myPlayer.experience = data.experience;
                    myPlayer.points = data.points;
                }
                for(let i in Store.points) Store.allocatedPoints[i] = 0;
                Store.originalPoints = Store.availablePoints;
                callback && callback.call && callback(Store);
            });
        },
        setContent: () => {
            let $html = $(`<div>`);
            $html.append(ExperiencePointsComponent.getPointsList());
            if(Store.originalPoints == 0) $html.find(`.btn-allocate-points`).attr(`disabled`, true);

            Store.$html = $html;
            Store.$shoppingList.html(Store.$html);
            return ExperiencePointsComponent;
        },
        setListeners: () => {
            let $btn = Store.$html.find(`.btn-allocate-points`);

            $(`input[type=range]`).each(() => {
                inputRange($(this));
            });
            for(let i in Store.pointsTr) ExperiencePointsComponent.setInputRangeListeners(Store.pointsTr[i], i);
            $btn.one(`click`, e => {
                e.preventDefault();
                ExperiencePointsComponent.allocatedPoints(() => ExperiencePointsComponent.getList());
            });
            return ExperiencePointsComponent;
        },
        allocatePoints: callback => {
            socket.emit(`allocatePoints`, Store.allocatedPoints, err => {
                if(err) console.log(err);
                if(typeof callback == `function`) callback();
            });
        },
        setInputRangeListeners: ($tr, name) => {
            let $input = $tr.find(`input`);
            $input.on(`change input`, () => {
                ExperiencePointsComponent.updateAvailablePoints();

                let val = parseInt($input.val()) - Store.points[name];
                if(val <= 0) val =0;

                if(val > Store.allocatedPoints[name] + Store.availablePoints) val = Store.allocatedPoints[name];

                Store.allocatedPoints[name] = val;
                val += Store.points[name];

                $input.val(val);
                updateInputRange($input);

                ExperiencePointsComponent.updateAvailablePoints();
                Store.$html.find(`h6`).html(`Available points: ${Store.originalPoints} <span class="float-right">Points left: ${Store.availablePoints}</span>`);
                ui.updateUiExperience();
            }).trigger(`change`);
        },
        updateAvailablePoints: () => {
            Store.usedPoints = 0;
            for(let i in Store.allocatedPoints) Store.usedPoints += Store.allocatedPoints[i];

            Store.availablePoints = Store.originalPoints - Store.usedPoints;
            return ExperiencePointsComponent;
        },
        getPointsList: () => {
            let html = ``;
            let $html, $tbody;

            html += `<div>`,
            html += `    <h6>Available points: ${Store.originalPoints} <span class="float-right">Points left: ${Store.availablePoints}</span></h6>`,
            html += `    <table class="table table-sm">`,
            html += `        <thead><tr><th>Name</th><th>Quantity</th></tr></thead>`,
            html += `        <tbody></tbody>`,
            html += `    </table>`,
            html += `    <button class="btn btn-primary float-right btn-allocate-points">Allocate points</button>`,
            html += `</div>`;

            $html = $(html);
            $tbody = $html.find(`tbody`);

            for(let i in Store.points) {
                let tr = ``;
                tr += `<tr>`;
                tr += `    <td>${i}</td>`;
                tr += `    <td>`;
                tr += `        <div class="range-group">`;
                tr += `            <input type="range" min="0" max="50" step="1" value="' + Store.points[i] + '">`;
                tr += `            <output></output>`;
                tr += `        </div>`;
                tr += `    </td>`;
                tr += `</tr>`;

                Store.pointsTr[i] = $(tr);
                $tbody.append(Store.pointsTr[i]);
            }
            return $html;
        },
        checkButtonTab: () => {
            ExperiencePointsComponent.clearStore().setStore(Store => {
                let $btnExperiencePoints = $(`#experience-points`);
                if(Store.originalPoints > 0) return $btnExperiencePoints.show();
                $btnExperiencePoints.hide();
            });
        }
    }
    window.EXPEREINCEPOINTSCOMPONENT = ExperiencePointsComponent;
})(window);
// Setup some global variables that will be used throughout all the engine.
let renderer, scene, camera, myPlayer, myBoat, domEvents, raycaster, canvas, gl, defaultWidth, defaultHeight;
let SERVER = false;
let playerName = ``;
let countDown = 8;
let threeJSStarted = false;
let markers = {}

// Test adblock.
let adBlockEnabled = false;
let testAd = document.createElement(`div`);
testAd.innerHTML = `&nbsp;`;
testAd.className = `adsblox`;

document.body.appendChild(testAd);
window.setTimeout(() => {
    if(testAd.offsetHeight == 0) adBlockEnabled = true;
    testAd.remove();

    if(adBlockEnabled) {
        $(`#KRW_krew-io_300x250_2`).parent().html(`<img src="/assets/img/251sbb.jpg" alt="" style="width: 100%"/>`);
        $(`#div-gpt-ad-1491569839954-0`).parent().html(`<img src="/assets/img/251s91.jpg" alt="" style="width: 100%"/>`);
        $(`#disable-adblock-message`).show();
    }
}, 1e3);

let createMinimap = () => {
    let map = CanvasMap(document.querySelector(`.minimap`), worldsize, worldsize);
    map.useRadians = true;
    map.zoom = 0.9;

    let middle = worldsize / 2;
    
    let fps = 24;
    let time = performance.now();

    let compass = {
        x: map.text({ x: middle, y: middle, text: `+`, fill: `rgba(84,48,13,0.7)`, size: 260, baseline: `middle` }),
        n: map.text({ x: middle, y: middle - 300, text: `N`, fill: `rgba(84,48,13,0.7)`, size: 160, baseline: `middle` }),
        s: map.text({ x: middle, y: middle + 300, text: `S`, fill: `rgba(84,48,13,0.7)`, size: 160, baseline: `middle` }),
        w: map.text({ x: middle - 300, y: middle, text: `W`, fill: `rgba(84,48,13,0.7)`, size: 160, baseline: `middle` }),
        e: map.text({ x: middle + 300, y: middle, text: `E`, fill: `rgba(84,48,13,0.7)`, size: 160, baseline: `middle` }),
        boundary: map.rect({ x: 0, y: 0, width: worldsize, height: worldsize, stroke: { color: `rgba(84,48,13,1)`, width: 8 } })
    }

    map
        .add(compass.x)
        .add(compass.n)
        .add(compass.s)
        .add(compass.w)
        .add(compass.e)
        .add(compass.boundary);

    let loop = () => {
        if(performance.now() - time > 1e3 / fps) {
            if(entities == undefined) map.elements = {}
            else {
                for(let i in map.elements) {
                    let element = map.elements[i];
                    if((element.netType == 5 || element.netType == 0 || element.netType == 4) && entity == undefined) map.remove(element);
                }

                for(let i in entities) {
                    let entity = entities[i];
                    if(entity.netType == 5) {
                        if(map.elements[i] == undefined) {
                            map
                                .add(map.point({
                                    x: entity.position.x,
                                    y: entity.position.z,
                                    r: entity.dockRadius,
                                    fill: `green`,
                                    id: i,
                                    netType: 5
                                }))
                                .add(map.text({
                                    x: entity.position.x,
                                    y: entity.position.z - 120,
                                    text: entity.name,
                                    fill: `rgba(84, 48, 13, 1)`,
                                    font: `serif`, 
                                    id: `${i}-label`,
                                    size: 140
                                }));
                        }
                    }
                    else if(entity.netType == 4 && entity.type == 4) {
                        if(map.elements[i] == undefined) {
                            map.add(map.text({
                                x: entity.position.x,
                                y: entity.position.z,
                                text: `x`,
                                fill: `rgba(204, 10, 10, 1)`,
                                font: `sans-serif`,
                                id: i,
                                size: 140,
                                netType: 4
                            }));
                        }
                    }
                }

                for(let i in markers) {
                    let marker = markers[i];
                    let element = map.elements[i]
                    if(element == undefined) {
                        map.add(map.point({
                            x: marker.x,
                            y: marker.y,
                            r: 30,
                            d: 0.5,
                            id: i,
                            createTime: performance.now(),
                            fill: `rgba(255, 0, 0, 0.5)`
                        }));
                    }
                    else {
                        if(element.createTime < performance.now() - 1e4) {
                            map.remove(element);
                            delete map.elements[i];
                        }
                        else {
                            element.r += Math.sin(element.d) * 5;
                            element.d += 0.2;
                        }
                    }
                }
            }

            if(myPlayer && myPlayer.geometry) {
                let position = myPlayer.geometry.getWorldPosition();

                let rotation = myPlayer.parent && myPlayer.parent.netType == 1 && myPlayer.parent.shipState == 0 ? myPlayer.parent.geometry.getWorldRotation().y + Math.PI: myPlayer.geometry.getWorldRotation().y;
                rotation *= -1;

                let playerElement = map.elements[myPlayer.id];
                if(!playerElement) {
                    map.add(map.triangle({
                        x: myPlayer.position.x,
                        y: myPlayer.position.z,
                        size: 60,
                        rotation,
                        fill: `white`,
                        stroke: {
                            color: `black`,
                            width: 15
                        },
                        id: myPlayer.id,
                        netType: 0
                    }));
                }
                else  {
                    playerElement.x = position.x;
                    playerElement.y = position.z;
                    playerElement.rotation = rotation;
                }
            }
            map.draw();
            time = performance.now();
        }
    }
    map.update = loop;
    return map;
}

let timer = setInterval(() => islandTimer(), 1e3);
let cleanup = setInterval(() => cleanScene(), 9e4);

window.logoutUser = () => {
    // Remove the player`s cookie.
    ui.invalidateCookie(`username`);
    ui.invalidateCookie(`token`);
    window.location.pathname = `/logout`;
}

let createGame = () => {
    let minimap = createMinimap();

    // Create THREE.js renderer.
    renderer = new THREE.WebGLRenderer({ antialias: true }); // Add option for disabling antialiasing? Could also be left to be disabled globally in the browser.

    // Add renderer to the document.
    document.body.appendChild(renderer.domElement);
    
    // Create the controls object. Configure pointer lock.
    controls = new GameControls();
    setUpKeyboard(renderer);

    // Setup the scene.
    scene = new THREE.Scene();

    // Camera.
    camera = new THREE.PerspectiveCamera(75, 1.8, 0.1, 1e4);
    camera.position.set(0, 10, 0);

    // Raycaster.
    raycaster = new THREE.Raycaster();

    // Setup environmental values.
    setUpEnvironment();

    // Make the renderer fit the window size.
    updateViewport();

    canvas = renderer.domElement;

    gl = canvas.getContext(`webgl2`);
    if(!gl) gl = canvas.getContext(`experimental-webgl`);

    defaultWidth = gl.canvas.width;
    defaultHeight = gl.canvas.height;

    // Render scene.
    lastFrameTime = performance.now();
    let loop = () => {
        // Calcualte delta time since last frame. (Minimum 0.1s).
        let thisFrame = performance.now();
        water.material.uniforms.time.value += 1.0 / 60.0;

        let dt = Math.min((thisFrame - lastFrameTime) / 1e3, 0.1);
        lastFrameTime = thisFrame;

        // Do engine logic.
        iterateEntities(dt);

        // Do particle logic.
        tickParticles(dt);
        minimap.update();

        // Render the scene.
        requestAnimationFrame(loop);
        renderer.clear();
        renderer.render(scene, camera);
    }
    // Execute the loop.
    loop();
}

// Show island window for non-kaptains.
let showIslandMenu = () => {
    $(`.toggle-shop-menu-btn`).removeClass(`disabled`).addClass(`enabled`);
    $(`.toggle-krew-list-btn`)/removeClass(`disabled`).addClass(`enabled`);
    if(entities[myPlayer.parent.anchorIslandId].name == `Labrador`) $(`.toggle-bank-menu-btn`).removeClass(`disabled`).addClass(`enabled`).attr(`data-tooltip`, `Deposit or withdraw gold`);

    $(`.exit-island-btn`).hide();
    ui.updateStore($(`.btn-shopping-modal.active`));
    ui.updateKrewList();
}

let enterIsland = data => {
    if(data.captainId == myPlayerId && myPlayer && myPlayer.parent && myPlayer.parent.shipState != 2) $(`.docking-modal`).show();
    
    if($(`.toggle-shop-modal-btn`).hasClass(`enabled`)) $(`.docking-modal`).hide();

    if(myPlayer) {
        ui.stopAudioFile(`ocean-music`);
        ui.playAudioFile(true, `island-music`);
    }
}

let dockingModalBtn = $(`.docking-modal.btn`);
let dockingModalBtnTxt = dockingModalBtn.find(`span`);

let portName = $(`.port-name`);

let cancelExitBtn = $(`.cancel-exit.btn`);
let cancelExitBtnTxt = cancelExitBtn.find(`span`);

let dockingModal = $(`.docking-modal`);

let cleanScene = () => {
    if(!scene) return; // Do not clean the scene if it has not been created yet.
    scene.traverse(node => {
        if(node instanceof THREE.Mesh) {
            for(let i in sceneCanBalls) {
                if(sceneCanBalls[i] == node) {
                    scene.remove(node);
                    delete sceneCanBalls[i];
                }
            }
        }
        if(node instanceof THREE.Line) {
            for(let i in sceneLines) {
                let line = sceneLines[i];
                if(line == node) {
                    scene.remove(node);
                    sceneLines[i].geometry.dispose();
                    delete sceneLines[i];
                }
            }
        }
    });
}

// Calculate values for alive timer.
let pad = val => {
    let valString = val + ``;
    if(valString.length < 2) return `0${valString}`;
    else return valString;
}

let secondsAlive = 0;

let islandTimer = () => {
    // Update the alive timer every second.
    secondsAlive++;
    $(`.timer-seconds`).html(pad(secondsAlive % 60));
    $(`.timer-minutes`).html(pad(parseInt(secondsAlive % 3600 / 60)));
    $(`.timer-hours`).html(pad(parseInt(secondsAlive / 3600)));

    if(myPlayer && myPlayer.parent) {
        if(myPlayer.parent.shipState == -1 || myPlayer.parent.shipState == 3) {
            dockingModalBtn.removeClass(`disabled`).addClass(`enabled`);
            portName.text(entities[myPlayer.parent.anchorIslandId].name);

            dockingModalBtnTxt.text(`Docking...`);
            cancelExitBtnTxt.text(`Sail (c)`);
            return;
        }
        if(myPlayer.parent.netType == 5) {
            portName.text(myPlayer.parent.name);
            if(dockingModal.is(`visible`)) {
                dockingModal.hide();
                showIslandMenu();
            }
        }
        if(dockingModal.hasClass(`initial`)) dockingModal.removeClass(`initial`).find(`.you-are-docked-msg`).remove();
        if(myPlayer.parent.shipState != 1) countDown = 8;
        if(myPlayer.parent.shipState == 1) {
            if(countDown == 8) socket.emit(`dock`);
            cancelExitBtnTxt.text(`Cancel (c)`);

            if(countDown != 0 && countDown > 0) dockingModalBtnTxt.text(`Docking in ${countDown} seconds`);
            else {
                dockingModalBtnTxt.text(`Dock (z)`);
                dockingModalBtn.removeClass(`disabled`).addClass(`enabled`);
            }
            countDown--;
        }

        if(myPlayer.parent.shipState == 4) {
            $(`.docking-modal`).hide();
            if(!$(`.departure.modal`).is(`visible`)) $(`.departure-modal`).show();

            $(`.cancel-departure-btn`).find(`span`).text(`${myPLayer && myPlayer.isCaptain ? `Departing in `: `Krew departing in`} ${entities[myPlayer.id].parent.departureTime} seconds`);
        }

        if(((!myPlayer.isCaptain && myPlayer.parent.shipState != 4) || (myPlayer.isCaptain && myPlayer.parent.shipState == 0)) && $(`.departure-modal`).is(`:visible`)) $(`.departure-modal`).hide();
    }
}

let departure = () => {
    if(myPlayer && entities[myPlayer.id] & entities[myPlayer.id].parent) {
        ui.playAudioFile(false, `sail`);
        $(`.docking-modal`).hide();

        this.departureCounter = this.departureCounter || 0;
        socket.emit(`depature`, this.departureCounter);

        this.departureCounter++;
        if(this.depatureCounter > 2) this.departureCounter = 0;
    }
}

// Called from connection.js when exitIsland socekt message is received from the server.
let exitIsland = data => {
    // Lock mouse.
    controls.lockMouseLook();

    if(data.captainId == myPlayerId) {
        $(`.docking-modal`).hide();
        $(`.departure-modal`).hide();
    }

    krewListUpdateManually = false;
    ui.hideSuggestionBox = true;

    if(myPlayer) {
        ui.stopAudioFile(`island-music`);
        ui.playAudioFile(true, `ocean-music`);
    }

    $(`.toggle-bank-menu-btn`).removeClass(`enabled`).addClass(`disabled`).attr(`data-tooltip`, `Bank is available at Labrador`);

    $(`.exit-island-btn`).hide();
    $(`.shopping-menu`).hide();
    $(`.krew-list-menu`).hide();

    ui.updateStore($(`.btn-shopping-modal.active`));

    $(`.docking-modal-btn`).removeClass(`enabled`).addClass(`disabled`);
    $(`.toggle-shop-menu-btn`).removeClass(`enabled`).addClass(`disabled`);
    $(`.toggle-krew-list-menu-btn`).removeClass(`enabled`).addClass(`disabled`);
}

let login = () => {
    connect($(`#server-list`).val());
    ui.setQualitySettings();

    $(`.fps-mode-btn`).attr(`checked`, false);
    $(`.quality-list`).val(2);
    $(`.quality-list`).trigger(`change`);
}

let sendMessage = () => {
    socket.emit(`chat message`, {
        message: $(`.chat-message`).val(),
        recipient: staffChatOn ? `staff`: clanChatOn ? `clan`: localChatOn ? `local`: `global`
    });
    $(`.chat-message`).val(``).focus();
}

let makeDeposit = () => {
    let deposit = +$(`.make-deposit`).val();
    let sumDeposits = parseInt($(`.my-deposits`).text()) + deposit;

    if(deposit <= myPlayer.gold && sumDeposits <= 15e4) {
        socket.emit(`bank`, { deposit });
        ui.playAudioFile(false, `deposit`);

        $(`.make-deposit`).val(``).focus();
        $(`.successMakeDepoMess`).show();
        $(`.errorMakeDepoMess`).hide();
        $(`.successTakeDepoMess`).hide();
        $(`.errorTakeDepoMess`).hide();
        $(`.errorFullDepoMess`).hide();
    }
    else if(sumDeposits > 15e4) {
        $(`.errorFullDepoMess`).show();
        $(`.successMakeDepoMess`).hide();
        $(`.errorMakeDepoMess`).hide();
        $(`.successTakeDepoMess`).hide();
        $(`.errorTakeDepoMess`).hide();
    }
    else {
        $(`.errorMakeDepoMess`).show();
        $(`.successMakeDepoMess`).hide();
        $(`.successTakeDepoMess`).hide();
        $(`.errorTakeDepoMess`).hide();
        $(`.errorFullDepoMess`).hide();
    }
}

// Share a link and caption on Facebook.
let fbShare = (message, link) => {
    FB.login(res => {
        let token = res.authResponse.accessToken;

        if(res.authResponse) {
            FB.api(`/me`, `get`, { access_token: token }, res => {});
            FB.ui({
                method: `share_open_graph`,
                action_type: `og.shares`,
                action_properties: JSON.stringify({
                    object: {
                        'og:url': `https://${link}`, // The URL to share.
                        'og:title': `Krew.io`,
                        'og:description': message,
                        'og:image': `https://krew.io/assets/img/logo.png/`
                    }
                })
            });
        }
    }, { scope: `publish_actions` });
}

let isAlphaNumeric = str => {
    let code;

    for(let i = 0; i < str.length; i++) {
        code = str.charCodeAt(i);
        if(!(code > 47 && code < 58) // Numeric (0-9)
        && !(code > 64 && code < 91) // Upper Alphabet (A-Z)
        && !(code > 96 && code < 123)) { // Lower Alphabet (a-z) 
            return false;
        }
    }
    return true;
}

// Once the document has been fulyl loaded. Start the engine initiation process.
$(document).ready(() => {
    loader.loadObjWithMtl(`/assets/models/cannon/cannon.obj`);
    loader.loadObjWithMtl(`/assets/models/hat_pirate.obj`);
    loader.loadObjWithMtl(`/assets/models/ships/bigship.obj`);
    loader.loadObjWithMtl(`/assets/models/ships/schooner.obj`);
    loader.loadObjWithMtl(`/assets/models/ships/sloop.obj`);
    loader.loadObjWithMtl(`/assets/models/ships/vessel.obj`);
    loader.loadObjWithMtl(`/assets/models/fish.obj`);
    loader.loadObjWithMtl(`/assets/models/shell.obj`);
    loader.loadObjWithMtl(`/assets/models/crab.obj`);
    loader.loadObjWithMtl(`/assets/models/clam.obj`);
    loader.loadObjWithMtl(`/assets/models/chest.obj`);
    loader.loadObjWithMtl(`/assets/models/spyglass.obj`);

    // Christmas tree and snowman.
    loader.loadObjWithMtl(`/assets/models/elka.obj`);
    loader.loadObjWithMtl(`/assets/models/snowman.obj`);

    loader.loadModel(`/assets/models/ships/raft.obj`);
    loader.loadModel(`/assets/models/ships/trader.obj`);
    loader.loadModel(`/assets/models/ships/boat.obj`);
    loader.loadModel(`/assets/models/ships/destroyer.obj`);
    loader.loadModel(`/assets/models/island.obj`);
    loader.loadModel(`/assets/models/dogs/dog_1.obj`);
    loader.loadModel(`/assets/models/fishingrod.obj`);

    loader.loadTexture(`/assets/models/colorset.png`);
    loader.loadTexture(`/assets/models/hook.png`);
    loader.loadTexture(`/assets/models/dogs/dog_diffuse.tga`);
    loader.loadTexture(`/assets/models/props_diffuse1.tga`);
    loader.loadTexture(`/assets/img/water.jpg`);
    loader.loadTexture(`/assets/img/cannonball.png`);
    loader.loadTexture(`/assets/img/crate.jpg`);
    loader.loadTexture(`/assets/models/tex_chest.png`);

    loader.onFinish(() => {
        // Create materials and game world.
        createModels();
        createMaterials();
        createGame();

        threeJSStarted = true;
        $(`.play-btn`).text(`Play as guest`).attr(`disabled`, false);
    });

    $(`.show-more`).on(`click`, () => {
        if($(`.show-more`).text().indexOf(`Show more`) > -1) {
            $(`.top20`).show();
            $(`.show-more`).html(`<i class="icofont icofont-medal"></i> Show less`);
        }
        else {
            $(`.top20`).hide();
            $(`.show-more`).html(`<i class="icofont icofont-medal</i> Show more`);
        }

        $(`.chat-message`).on(`keyup`, () => {
            let $this = $(this);
            let val = $this.val();

            if(val.trim().length > 150) $this.val(val.slice(0, 150));
        });

        // Play by pressing login button.
        $(`.play-btn`).on(`click`, () => {
            GameAnalytics(`addDesignEvent`, `Game:Session:ClickedPlayButton`);
            if(threeJSStarted) {
                login();
                setUpKeybinds();
                ui.LoadingWheel(`show`);
                ui.playAudioFile(false, `wheelspin`);
                ui.playAudioFile(true, `ocean-ambience`);
            }
        }).text(`Loading...`).attr(`disabled`, true);

        $(`.play-again-btn`).on(`click`, () => {
            if(threeJSStarted) {
                ui.showAdinplayCentered();
                secondsAlive = 0;
                socket.emit(`respawn`);
                myPlayer.itemId = undefined;
                myPlayer.state = 2;

                $(`.toggle-shop-modal-btn`).removeClass(`enabled`).addClass(`disabled`);
                $(`.toggle-krew-list-modal-btn`).removeClass(`enabled`).addClass(`disabled`);
                $(`.toggle-bank-modal-btn`).removeClass(`enabled`).addClass(`disabled`).attr(`data-tooltip`, `Bank is available at Labrador`);
            }
        });

        $(`.share-link`).on(`click`, () => {
            let message = `I just had an amazing game of Krew.io and my score was ${lastScore}!`;
            let link = `${window.location.hostname}/`;
            fbShare(message, link);
            ui.showAdinplayCentered();
            secondsAlive = 0;

            socket.emit(`respawn`);
            myPlayer.state = 2;
            myPlayer.itemId = undefined;

            $(`.toggle-shop-modal-btn`).removeClass(`enabled`).addClass(`disabled`);
            $(`.toggle-krew-list-modal-btn`).removeClass(`enabled`).addClass(`disabled`);
            $(`.toggle-bank-modal-btn`).removeClass(`enabled`).addClass(`disabled`).attr(`data-tooltip`, `Bank is available at Labrador`);

            ui.updateStore($(`.btn-shopping-modal.active`));
            
            $(`.krew-list-modal`).show();
            ui.updateKrewList();
        });

        $(`.quality-list`).on(`change`, () => {
            let newW = defaultWidth / 2.5;
            let newH = defaultHeight / 2.5;
            switch(parseInt($(`.quality-list`).val())) {
                case 2: {
                    newW = defaultWidth / 1.45;
                    newH = defaultWidth / 1.45;
                    break;
                }
                case 3: {
                    newW = defaultWidth;
                    newH = defaultWidth;
                    break;
                }
            }
            
            if(gl != undefined) {
                gl.canvas.height = newH;
                gl.canvas.width = newW;

                gl.viewport(0, 0, newW, newH); // Originally newW, newW.
                renderer.setSize(newW, newH, false); // Originally newW, newW.
            }
        });

        $(`.share-invite-link`).on(`click`, () => {
            let message = `Join my krew!`;
            let link = ui.getInviteLink();
            fbShare(message, link);
        });

        // Initialize listeners for the UI.
        ui.setListeners();

        $(window).on(`unload`, () => {
            if(socket) socket.close();
        });

        // Submit on enter key.
        $(`.chat-message`).on(`keypress`, e => {
            if(e.keyCode == 13) sendMessage();
        });
        $(`.make-deposit`).on(`keypress`, e => {
            if(e.keyCode == 13) makeDeposit();
        });
        $(`.take-deposit`).on(`keypress`, e => {
            if(e.keyCode == 13) takeDeposit();
        });

        ui.updateServerList();
        ui.createWallOfFame();

        // Sen chat message by pressing send message button.
        $(`.send-message-btn`).on(`click`, () => {
            sendMessage();
        });

        if(getUrlVars().sid && getUrlVars().bid) {
            // If invite link is being used.
            $(`.invite-is-used`).show();
            $(`.select-server`).hide();
            $(`.select-spawn`).hide();
        }

        $(`.crew-count, .ship-health`).slider();

        $(`.crew-count`).on(`slide`, e => $(`.crew-count-val`).text(e.value));
        $(`.ship-health`).on(`slide`, e => $(`.ship-health-val`).text(e.value));

        let shoppingModalBtn = $(`.btn-shopping-modal`);
        shoppingModalBtn.each(() => {
            let $this = $(this);
            $this.on(`click`, () => {
                shoppingModalBtn.removeClass(`active`);
                $this.addClass(`active`);
                ui.updateStore($this);
            });
        });

        $(`.docking-modal-btn`).on(`click`, () => {
            if($(`.docking-modal-btn`).hasClass(`enabled`)) {
                if(myPlayer && myPlayer.parent) {
                    ui.playAudioFile(false, `dock`);
                    socket.emit(`anchor`);
                    shoppingModalBtn.eq(2).trigger(`click`);

                    if(entities[myPlayer.parent.anchorIslandId].name == `Labrador`) $(`.toggle-bank-modal-btn`).removeClass(`disabled`).addClass(`enabled`).attr(`data-tooltip`, `Deposit or withdraw gold`);
                    if(myPlayer.parent.netType == 1 && !$(`.exit-island-btn`).is(`:visible`)) $(`.exit-island-btn`).show();
                }

                lastScore = 0;
                controls.unLockMouseLook();

                $(`.docking-modal`).hide();
                $(`.supply`).tooltip(`show`);

                $(`.toggle-shop-modal-btn`).removeClass(`disabled`).addClass(`enabled`);
                $(`.toggle-krew-list-modal-btn`).removeClass(`disabled`).addClass(`enabled`);

                ui.updateStore($(`.btn-shopping-modal.active`));
                $(`.recruiting-wrapper`).fadeIn(`slow`);
            }
        });

        $(`.login-modal`).modal({
            show: true,
            backdrop: `static`,
            keyboard: false
        });
        $(`.modal-custom`).on(`show.bs.modal`, e => {
            setTimeout(() => {
                $(`.modal-backdrop`).addClass(`modal-backdrop-custom`);
                $(`.modal-custom`).removeClass(`modal-open`);
            });
        });

        $(`.game-over-modal`).modal({
            show: false,
            backdrop: `static`,
            keyboard: false
        });

        $(`.chat-global`).on(`click`, () => toggleGlobalChat());
        $(`.chat-local`).on(`click`, () => toggleLocalChat());
        $(`.chat-clan`).on(`click`, () => toggleClanChat());
        $(`.chat-staff`).on(`click`, () => toggleStaffChat());

        $(`.hide-chat`).on(`click`, () => {
            $(`.show-chat`).show();
            $(`.chat-wrapper`).hide();
        });
        $(`.show-chat`).on(`click`, () => {
            $(`.hide-chat`).show();
            $(`.chat-wrapper`).show();
        });

        $(`.toggle-invite-link-btn`).on(`click`, () => {
            if($(`.invite-wrapper`).is(`:visible`)) $(`.invite-wrapper`).hide();
            else {
                $(`.invite-link`).val(ui.getInviteLink());
                $(`.invite-wrapper`).show();
            }
        });

        $(`.exit-island-btn`).on(`click`, () => departure());

        $(`.toggle-help-btn`).on(`click`, () => {
            if($(`.help-modal`).is(`:visible`)) $(`.help-modal`).hide();
            else {
                ui.closeAllPagesExcept(`.help-modal`);
                $(`.help-modal`).show();
            }
        });

        $(`.close-help-btn`).on(`click`, () => $(`.help-modal`).hide());
        $(`.close-bank-btn`).on(`click`, () => $(`.bank-modal`).hide());
        $(`.btn-make-deposit`).on(`click`, () => makeDeposit());
        $(`.btn-take-deposit`).on(`click`, () => takeDeposit());

        $(`.toggle-quest.btn`).on(`click`, () => {
            if($(`.quest-modal`).is(`:visible`)) $(`.quest-modal`).hide();
            else {
                // After clicking on the quest button, get all information needed for stats from the server.
                socket.emit(`getStats`, data => {
                    let jsonData = JSON.parse(data);

                    // Pirate quests.
                    $(`.pirate-progress`).text(jsonData.shipsSank);
                    $(`.crew-pirate-progress`).text(jsonData.overallKills);

                    if (json_data.shipsSank >= 1){
                        // If pirate quest 1 is achieved, display the checkbox icon and show the next quest.
                        $(`#completed-quest-table`).append($(`#pirate-quest-1`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#pirate-quest-2`).show();
                        $(`#crew-pirate-quest-1`).show();
                    }
                    if (json_data.shipsSank >= 5){
                        $(`#completed-quest-table`).append($(`#pirate-quest-2`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#pirate-quest-3`).show();
                    }
                    if (json_data.shipsSank >= 10){
                        $(`#completed-quest-table`).append($(`#pirate-quest-3`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#pirate-quest-4`).show();
                    }
                    if (json_data.shipsSank >= 20){
                        $(`#completed-quest-table`).append($(`#pirate-quest-4`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                    }
                    if (json_data.overall_kills >= 10){
                        $(`#completed-quest-table`).append($(`#crew-pirate-quest-1`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#crew-pirate-quest-2`).show();
                    }
                    if (json_data.overall_kills >= 20){
                        $(`#completed-quest-table`).append($(`#crew-pirate-quest-2`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#crew-pirate-quest-3`).show();
                    }
                    if (json_data.overall_kills >= 50){
                        $(`#completed-quest-table`).append($(`#crew-pirate-quest-3`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                    }

                    // Trade quests.
                    $(`.trade-progress`).text(json_data.overall_cargo);
                    $(`.crew-trade-progress`).text(json_data.crew_overall_cargo);

                    // After completing the quest, display the new status in the quest window.
                    if (json_data.overall_cargo >= 1000){
                        $(`#completed-quest-table`).append($(`#trade-quest-1`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#trade-quest-2`).show();
                        $(`#crew-trade-quest-1`).show();
                    }
                    if (json_data.overall_cargo >= 6000){
                        $(`#completed-quest-table`).append($(`#trade-quest-2`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#trade-quest-3`).show();
                    }
                    if (json_data.overall_cargo >= 15000){
                        $(`#completed-quest-table`).append($(`#trade-quest-3`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#trade-quest-4`).show();
                    }
                    if (json_data.overall_cargo >= 30000){
                        $(`#completed-quest-table`).append($(`#trade-quest-4`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                    }
                    if (json_data.crew_overall_cargo >= 12000){
                        $(`#completed-quest-table`).append($(`#crew-trade-quest-1`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#crew-trade-quest-2`).show();
                    }
                    if (json_data.crew_overall_cargo >= 50000){
                        $(`#completed-quest-table`).append($(`#crew-trade-quest-2`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#crew-trade-quest-3`).show();
                    }
                    if (json_data.crew_overall_cargo >= 150000){
                        $(`#completed-quest-table`).append($(`#crew-trade-quest-3`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                    }
    
                    // Other quests.
                    $(`#other-progress-1`).text(myPlayer.jump_count);
                    if (myPlayer.jump_count >= 50){
                        $(`#completed-quest-table`).append($(`#other-quest-1`).last());
                        $(`#completed-quest-table .quest-progress`).html(`<i class="icofont icofont-check-circled"></i>`);
                        $(`#other-quest-2`).show();
                    }
                });
            }
        });

        $(`.close-quests-btn`).on(`click`, () => $(`.quests-modal`).css(`display`, `none`));

        $(`.cancel-exit-btn`).on(`click`, () => {
            if(cancelExitBtnTxt.text() == `Cancel (c)`) {
                socket.emit(`exitIsland`);
                dockingModalBtnTxt.text(`Countdown...`);
            }
        });

        $(`.abandon-ship-btn`).on(`click`, () => {
            if(myBoat.hp <= 0) return;
            if(myPlayer.goods && (myBoat.shipState == 3 || myBoat.shipState == 4)) {
                for(let i in myPlayer.goods) {
                    if(myPlayer.goods[i] > 0) {
                        socket.emit(`buyGoods`, {
                            quantity: myPlayer.goods[i],
                            action: `sell`,
                            good: i
                        }, (err, data) => {
                            if(err) return console.log(err);
                            myPlayer.gold = data.gold;
                            myPlayer.goods = data.goods;
                        });
                    }
                }
            }

            socket.emit(`abandonShip`);
            $(`.abandon-ship-btn`).hide();

            if(myBoat != undefined) {
                if(myBoat.shipState == 3 || myBoat.shipState == -1 || myBoat.shipState == 4) {
                    $(`.supply`).tooltip(`show`);

                    $(`.toggle-shop-modal-btn`).removeClass(`disabled`).addClass(`enabled`);
                    $(`.toggle-krew-list-modal-btn`).removeClass(`disabled`).addClass(`enabled`)

                    if(entities[myPlayer.parent.anchorIslandId].name == `Labrador`) $(`.toggle-bank-modal-btn`).removeClass(`disabled`).addClass(`enabled`).attr(`data-tooltip`, `Deposit or withdraw gold`);
                    ui.updateStore($(`.btn-shopping-modal.active`));
                }
                else if(myBoat.shipState == 1) $(`.docking-modal`).show();
            }
        });
    });

    $(`.lock-krew-btn`).on(`click`, () => {
        if($(`.lock-krew-btn`).is(`:checked`)) {
            $ (`lock-krew-text`).removeClass(`text-info`).addClass(`text-danger`).text(`Unlock krew...`);
            socket.emit(`lockKrew`, true);
        }
        else {
            $ (`lock-krew-text`).removeClass(`text-info`).addClass(`text-danger`).text(`Lock krew...`);
            socket.emit(`lockKrew`, false);
        }
    });
    localStorage.setItem(`lastAdTime`, Date.now() - 1e7);

    let aiptag = aiptag || {};
    aiptag.cmd = aiptag.cmd || [];
    aiptag.cmd.display = aiptag.cmd.display || [];
    aiptag.cmd.display.push(() => aipDisplayTag.display(`krew-io_300x250`));
    aiptag.gdprShowConsentTool = true; // Show the GDPR consent tool.
    aiptag.gdprShowConsentToolButton = true;
    initAipPreroll();

    let aipGDPRCallback_OnAccept = googleConsent => {
        if(googleConsent) initAipPreroll();
    }

    let initAipPreroll = () => {
        if(typeof aipPlayer != `undefined`) {
            adplayer = new aipPlayer({
                AD_WIDTH: 960,
                AD_HEIGHT: 540,
                AD_FULLSCREEN: true,
                PREROLL_ELEM: document.querySelector(`#preroll`),
                AIP_COMPLETE: () => {},
                AIP_REMOVE: () => {}
            });
            window.adplayerCentered = new aipPlayer({
                AD_WIDTH: 560,
                AD_HEIGHT: 315,
                AD_FULLSCREEN: false,
                PREROLL_ELEM: document.querySelector(`#preroll-centered`),
                AIP_COMPLETE: () => {},
                AIP_REMOVE: () => {}
            });
        }
    }
});

// Bootstrap shows elements inside .tab by default.
$(`.global-chat-alert`).hide();

let toggleGlobalChat = () => {
    $(`.chat-global`).addClass(`active`);
    $(`.chat-local`).removeClass(`active`);
    $(`.chat-clan`).removeClass(`active`);
    $(`.chat-staff`).removeClass(`active`);

    $(`.chat-global`).show();
    $(`.chat-local`).hide();
    $(`.chat-clan`).hide();
    $(`.chat-staff`).hide();

    globalChatOn = true;
    localChatOn = false;
    clanChatOn = false;
    staffChatOn = false;

    $(`.global-chat-alert`).hide();

    // Scroll down to the bottom of the chat.
    $(`.chat-history`).scrollTop(() => {
        return this.scrollHeight;
    });
}

let toggleLocalChat = () => {
    $(`.chat-global`).removeClass(`active`);
    $(`.chat-local`).addClass(`active`);
    $(`.chat-clan`).removeClass(`active`);
    $(`.chat-staff`).removeClass(`active`);

    $(`.chat-global`).hide();
    $(`.chat-local`).show();
    $(`.chat-clan`).hide();
    $(`.chat-staff`).hide();

    globalChatOn = false;
    localChatOn = true;
    clanChatOn = false;
    staffChatOn = false;

    $(`.local-chat-alert`).hide();

    // Scroll down to the bottom of the chat.
    $(`.chat-history`).scrollTop(() => {
        return this.scrollHeight;
    });
}

let toggleClanChat = () => {
    $(`.chat-global`).removeClass(`active`);
    $(`.chat-local`).removeClass(`active`);
    $(`.chat-clan`).addClass(`active`);
    $(`.chat-staff`).removeClass(`active`);

    $(`.chat-global`).hide();
    $(`.chat-local`).hide();
    $(`.chat-clan`).show();
    $(`.chat-staff`).hide();

    globalChatOn = false;
    localChatOn = false;
    clanChatOn = true;
    staffChatOn = false;

    $(`.clan-chat-alert`).hide();

    // Scroll down to the bottom of the chat.
    $(`.chat-history`).scrollTop(() => {
        return this.scrollHeight;
    });
}

let toggleStaffChat = () => {
    $(`.chat-global`).addClass(`active`);
    $(`.chat-local`).removeClass(`active`);
    $(`.chat-clan`).removeClass(`active`);
    $(`.chat-staff`).addClass(`active`);

    $(`.chat-global`).hide();
    $(`.chat-local`).hide();
    $(`.chat-clan`).hide();
    $(`.chat-staff`).show();

    globalChatOn = false;
    localChatOn = false;
    clanChatOn = false;
    staffChatOn = true;

    $(`.staff-chat-alert`).hide();

    // Scroll down to the bottom of the chat.
    $(`.chat-history`).scrollTop(() => {
        return this.scrollHeight;
    });
}

let Ease = {
    // No easing, no acceleration.
    linear: function (t) { return t; },

    // Accelerating from zero velocity.
    easeInQuad: function (t) { return t * t; },

    // Decelerating to zero velocity.
    easeOutQuad: function (t) { return t * (2 - t); },

    // Acceleration until halfway, then deceleration.
    easeInOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },

    // Accelerating from zero velocity.
    easeInCubic: function (t) { return t * t * t; },

    // Decelerating to zero velocity.
    easeOutCubic: function (t) { return (--t) * t * t + 1; },

    // Acceleration until halfway, then deceleration.
    easeInOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },

    // Accelerating from zero velocity.
    easeInQuart: function (t) { return t * t * t * t; },

    // Decelerating to zero velocity.
    easeOutQuart: function (t) { return 1 - (--t) * t * t * t; },

    // Acceleration until halfway, then deceleration.
    easeInOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t; },

    // Accelerating from zero velocity.
    easeInQuint: function (t) { return t * t * t * t * t; },

    // Decelerating to zero velocity.
    easeOutQuint: function (t) { return 1 + (--t) * t * t * t * t; },

    // Acceleration until halfway, then deceleration.
    easeInOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; },
}

let particles = [];

let Particle = params => {
    // Parse parameters.
    this.vx = params.vx;
    this.vy = params.vy;
    this.vz = params.vz;

    this.gravity = params.gravity;
    this.rotaSpeed = params.rotaSpeed;
    this.duration = params.duration;

    this.timeleft = this.duration;
    this.sizeSpeed = params.sizeSpeed;
    this.globalscale = 1;

    this.w = params.w;
    this.h = params.h;

    this.d = params.d;

    this.x = params.x;
    this.y = params.y;
    this.z = params.z;

    // Create geometry.
    this.geometry = new THREE.Mesh(params.geometry, params.material);
    this.geometry.position.set(this.x, this.y, this.z);
    this.geometry.scale.set(this.w, this.h, this.d);

    // Set this to true and the particle will be removed.
    this.deleteMe = false;
    scene.add(this.geometry);
}

Particle.prototype.tick = dt => {
    // Subtract gravity.
    this.vy -= this.gravity * dt;

    // Update position.
    this.geometry.position.set(
        this.geometry.position.x + this.vx * dt,
        this.geometry.position.y + this.vy * dt,
        this.geometry.position.z + this.vz * dt
    );

    // Update rotation.
    this.geometry.rotation.set(
        this.geometry.rotation.x + this.rotaSpeed * dt,
        this.geometry.rotation.y + this.rotaSpeed * dt,
        this.geometry.rotation.z + this.rotaSpeed * dt
    );

    // Update scale.
    this.globalscale += this.sizeSpeed * dt;
    this.geometry.scale.set(
        this.w * this.globalscale,
        this.h * this.globalscale,
        this.d * this.globalscale
    );

    this.timeleft -= dt;
    if(this.timeleft <= 0 || this.globalscale <= 0) {
        scene.remove(this.goemetry);
        this.deleteMe = true;
    }
}

// Creating a new particle.
let createParticle = params => {
    if(!myPlayer || !myPlayer.parent || ((Math.pow(params.x - myPlayer.parent.position.x, 2) + Math.pow(params.z - myPlayer.parent.position.z, 2)) > 1e4)) return;
    particles.push(new Particle(params));
}

// Ticking the particles.
let tickParticles = dt => {
    let i = particles.length;
    while(i--) {
        particles[i].tick(dt);
        if(particles[i].deleteMe) particles.splice(i, 1);
    }
}

// Predefined variables.
let socket;
let playerID;
let address = document.location.host;

// Chat toggle options for where to send a message.
let chatOptions = {
    clan: false,
    local: false,
    global: false
}

let maxPlayers = 100;
let intervalUpdate = undefined;

// Define clientside account perms.
const staff = {
    admins: [`devclied`, `DamienVesper`, `LeoLeoLeo`, `harderman`, `itsdabomb`],
    mods: [`Fiftyyyyy`, `Sloth`, `Sjmun`, `TheChoco`, `Kekmw`, `Headkeeper`],
    devs: [`Yaz`]
}

let connect = pid => {
    // If player is already connected to the game.
    if(socket != undefined) return;

    // Connect to each gameserver to get info about it.
    if(getUrlVars().pid && ui.serverList[getUrlVars().pid]) pid = getUrlVars().pid;

    // Determine the selected gameserver.
    let server = ui.servers[pid];
    if(window.location.hostname == `localhost`) server = { ip: `http://localhost`, port: `2001` }

    // Concatenate this information into a url to use.
    let url = window.location.hostname == `localhost` ? `http://localhost`: `https://krew.io`;
    if(!isNaN(parseInt(server.port)) && parseInt(server.port) != 80) url += `:${server.port}`;

    // Connect to the gameserver.
    socket = io.connect(url, {
        secure: true,
        rejectUnauthorized: false
    });
    initSocketBinds();

    $(`.game-ui`).style.display = `block`;
    $(`.login-ui`).style.display = `none`;
}

let initSocketBinds = () => {
    // Await handshake (recognition from master of client connection to gameserver).
    socket.on(`handshake`, msg => {
        // Send a message before player closes game window.
        document.addEventListener(`beforeunload`, () => {
            return `Do you really want to leave your ship and lose your progress?`;
        });

        // Clear previous data (if any) from last connection.
        deleteEverything();

        // Assign player ID.
        myPlayer.id = msg.socketID;

        // Let the gameserver know to create a player and send data for the player.
        socket.emit(`createPlayer`, {
            boatID: getUrlVars().bid,
            token: ui.token,
            spawn: ui.setSpawnPlace(),
            cookie: sessionCookie,
            user: currentUser
        });

        // Reset the alive timer.
        secondsAlive = 0;

        // Setup UI for initial jump into game.
        socket.on(`startGame`, () => {
            ui.LoadingWheel(`hide`);
            ui.showCenterMessage(`Use WASD to move. Click to shoot or fish. Use 1, 2, and 3 to switch weapons.`, 4, 15e3);
        });

        // Receive data for player usernames.
        socket.on(`playerNames`, data => playerNames = data);

        // Receive data for world snapshot.
        socket.on(`snapshot`, data => {
            data = JSON.parse(LZString.decompress(data));
            for(let i in data) parseSnap(i, data[i]);
        });

        // Handle disconnecting from game / death.
        socket.on(`disconnect`, deleteEverything);
        socket.on(`end`, endTheGame);

        // Receive data for player scores for leaderboard.
        socket.on(`scores`, data => {
            data = JSON.parse(LZString.decompress(data));
            ui.updateLeaderboard(data);
        });

        // Receive and set data for player in bank.
        socket.on(`setBankData`, data => ui.setBankData());

        // Receive and update krews list (alternative method).
        socket.on(`updateKrewsList`, () => ui.updateKrewList());

        // Receive and update ship cargo.
        socket.on(`updateCargo`, () => {
            if($(`#buy-goods`).hasClass(`active`)) GOODSCOMPONENT.getList();
        });

        // Receive docking menu and update ui to reflect.
        socket.on(`enterIsland`, data => enterIsland(data));

        // Show island menus when ship docks.
        socket.on(`showIslandMenu`, () => showIslandMenu());

        // Remove island menus when ship sails.
        socket.on(`exitIsland`, () => exitIsland(data));

        // Show ad.
        socket.on(`showAd`, () => ui.showAd());

        // Departure warning for other ships that depart at the same island.
        socket.on(`departureWarning`, () => {
            let krewListBtn = $(`.toggle-krew-list-button`);
            if(krewListBtn.hasClass(`enabled`)) {
                krewListBtn.addClass(`glowing`);
                setTimeout(() => krewListBtn.removeClass(`glowing`), 5e3);
            }
        });

        // Show message in message bar (top center) to user.
        socket.on(`showCenterMessage`, (msg, type, time) => {
            if(ui && ui.showCenterMessage) ui.showCenterMessage(message, type || 3, time);
            if(message.startsWith(`Achievement trading`)) $(`.shopping-modal`).style.display = `none`;
        });

        // Show killfeed to user.
        socket.on(`showKillMessage`, killChain => {
            if(ui && ui.showKillMessage) ui.showKillMessage(killChain);
        });

        // Show damage dealt / damage being dealt to user.
        socket.on(`showDamageMessage`, (msg, type) => {
            if(ui && ui.showDamageMessage) {
                if(type == 2) ui.playAudioFile(false, `cannon-hit`);
                ui.showDamageMessage(msg, type);
            }
        });

        // Show admin message to user.
        socket.on(`showAdminMessage`, msg => {
            if(ui && ui.showAdminMessage) ui.showAdminMessage(msg);
        });

        // Show level up notification to user.
        socket.on(`levelUpdate`, data => {
            if(entities[data.id] != undefined && entities[data.id].netType == 0) {
                entities[data.id].level = data.level;

                if(data.id == myPlayerID) {
                    ui.playAudioFile(false, `level-up`);

                    myPlayer.updateExperience();
                    myPlayer.notificationsHeap[Math.random().toString(36).substring(6, 10)] = { text: `Level Up!`, type: 2, isNew: true }
                }
            }
        });

        // Clan marker.
        socket.on(`clanMarker`, data => {
            let randID = Math.random().toString(36).substring(6, 10);
            markers[randID] = data;
        });

        // Remove old interval, if existent.
        if(intervalUpdate != undefined) {
            clearInterval(intervalUpdate);
            intervalUpdate = undefined;
        }

        // Create a new interval to send current snapshot.
        let snapCounter = 0;
        intervalUpdate = setInterval(() => {
            if(!myPlayer) return;

            msg = myPlayer.getDelta();
            if(msg) socket.emit(`u`, msg);

        }, 100);

        // Receive chat messages and show them in the chat menu.
        socket.on(`chatMessage`, data => {
            if(myPlayer && myPlayer.parent && (myPlayer.parent.hasChild(data.playerID) || data.recipent == `global` || data.recipent == `local` || data.recipient == `clan`) && entities[data.playerID] != undefined) {
                let chatHistory = $(`.chat-history`);

                let isKrewmate = myPlayer.parent.netType == 1 && myPlayer.parent.hasChild(data.myPlayerID);
                let playerClan = entities[data.playerID].clan;
                let isClanMember = myPlayer.clan != `` && myPlayer.clan != undefined && myPlayer.clan == playerClan && !isPlayer;
                
                let isAdmin = staff.admins.includes(data.playerName);
                let isMod = staff.mods.includes(data.playerName);
                let isDev = staff.devs.includes(data.playerName);

                let classRec = `global-chat`;
                classRec = `${data.recipient}-chat`;

                // Create message data wrappers.
                let msgWrapper = document.createElement(`span`);
                let tagWrapper = document.createElement(`span`);
                let contentWrapper = document.createElement(`span`);

                // Create tag wrappers.
                let staffTag = document.createElement(`span`);
                let clanTag = document.createElement(`span`);
                let krewTag = document.createElement(`span`);

                // Set the tags and color them.
                staffTag.html(isAdmin ? `[admin]`: isMod ? `[mod]`: isDev ? `[dev]`: ``);
                clanTag.html(playerClan ? `[${playerClan}]`: ``);
                krewTag.html(isKrewmate ? `[krew]`: ``);

                tagWrapper.appendChild(staffTag);
                tagWrapper.appendChild(clanTag);
                tagWrapper.appendChild(krewTag);

                if(isAdmin || isMod || isDev) staffTag.addClass(`text-staff`);
                if(playerClan) clanTag.addClass(`text-warning`);
                isKrewmate ? entitites[data.playerId].isCaptain ? `text-danger`: `text-primary`: null;

                // Set the content of the message.
                contentWrapper.html(`${data.playerName}: ${data.message}`);

                // Concatenate both into a wrapper.
                msgWrapper.appendChild(tagWrapper);
                msgWrapper.appendChild(contentWrapper);

                // hide message based on what chat is currently selected by the user.
                if((data.recipient == `global` && !chatOptions.global)
                || (data.recipient == `local` && !chatOptions.local)
                || (data.recipient == `clan` && !chatOptions.clan))
                    msgWrapper.hide();

                let chatAlerts = document.querySelectorAll(`.chat-alerts`);
                if(data.recipient == `global` && !chatOptions.global) chatAlerts[2].show();
                if(data.recipient == `local` && !chatOptions.local) chatAlerts[1].show();
                if(data.recipient == `clan` && !chatOptions.clan) chatAlerts[0].show();

                chatHistory.appendChild(msgWrapper);
            }
        });
    });
}

let getUrlVars = () => {
    let vars = {}
    let parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, (m, key, value) => vars[key] = value);
    return vars;
}

let deleteEverything = () => {
    for(let e in entities) if(entities.hasOwnProperty(e)) entities[e].onDestroy();
}

// Disconnect player from socket.
let endTheGame = (gold, fired, hit, sank) => {
    miniplaySend2API(`gameover`, 1);
    miniplaySend2API(`ships`, sank);

    controls.unLockMouseLook();

    $(`.local-chat`).remove();
    $(`#game-over-modal`).modal(`show`);

    setHighlights(gold, fired, hit, sank);
    myPlayer.state = 1;
}

// Set player session highlights for respawn window.
let setHighlights = (gold, fired, hit, sank) => {
    miniplaySend2API(`gameover`, 1);
    miniplaySend2API(`ships`, sank);

    $(`#total-score`).html(lastScore);
    $(`#total-damage`).html(lastScore);
    $(`#total-gold-collected`).html(gold.toFixed(0));
    $(`#total-shots-fired`).html(fired);
    $(`#total-shots-hit`).html(Math.round((hit / fired) * 100));
    $(`#total-ships-sank`).html(sank);
    $(`#supplies-cut`).html((0.3 * gold).toFixed(0));

    if($(`#docking-modal`).is(`:visible`)) $(`#docking-modal`).hide();
}
